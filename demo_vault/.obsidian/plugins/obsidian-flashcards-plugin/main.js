/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/sql.js/dist/sql-wasm.js
var require_sql_wasm = __commonJS({
  "node_modules/sql.js/dist/sql-wasm.js"(exports, module2) {
    var initSqlJsPromise = void 0;
    var initSqlJs2 = function(moduleConfig) {
      if (initSqlJsPromise) {
        return initSqlJsPromise;
      }
      initSqlJsPromise = new Promise(function(resolveModule, reject) {
        var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
        var originalOnAbortFunction = Module["onAbort"];
        Module["onAbort"] = function(errorThatCausedAbort) {
          reject(new Error(errorThatCausedAbort));
          if (originalOnAbortFunction) {
            originalOnAbortFunction(errorThatCausedAbort);
          }
        };
        Module["postRun"] = Module["postRun"] || [];
        Module["postRun"].push(function() {
          resolveModule(Module);
        });
        module2 = void 0;
        var f;
        f || (f = typeof Module != "undefined" ? Module : {});
        var aa = "object" == typeof window, ba = "undefined" != typeof WorkerGlobalScope, ca = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && "renderer" != process.type;
        "use strict";
        f.onRuntimeInitialized = function() {
          function a(g, l) {
            switch (typeof l) {
              case "boolean":
                dc(g, l ? 1 : 0);
                break;
              case "number":
                ec(g, l);
                break;
              case "string":
                fc(g, l, -1, -1);
                break;
              case "object":
                if (null === l)
                  lb(g);
                else if (null != l.length) {
                  var n = da(l, ea);
                  gc(g, n, l.length, -1);
                  fa(n);
                } else
                  va(g, "Wrong API use : tried to return a value of an unknown type (" + l + ").", -1);
                break;
              default:
                lb(g);
            }
          }
          function b(g, l) {
            for (var n = [], r = 0; r < g; r += 1) {
              var t = m(l + 4 * r, "i32"), y = hc(t);
              if (1 === y || 2 === y)
                t = ic(t);
              else if (3 === y)
                t = jc(t);
              else if (4 === y) {
                y = t;
                t = kc(y);
                y = lc(y);
                for (var L = new Uint8Array(t), J = 0; J < t; J += 1)
                  L[J] = p[y + J];
                t = L;
              } else
                t = null;
              n.push(t);
            }
            return n;
          }
          function c(g, l) {
            this.Qa = g;
            this.db = l;
            this.Oa = 1;
            this.lb = [];
          }
          function d(g, l) {
            this.db = l;
            l = ha(g) + 1;
            this.eb = ia(l);
            if (null === this.eb)
              throw Error("Unable to allocate memory for the SQL string");
            u(g, x, this.eb, l);
            this.kb = this.eb;
            this.Za = this.pb = null;
          }
          function e(g) {
            this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
            if (null != g) {
              var l = this.filename, n = "/", r = l;
              n && (n = "string" == typeof n ? n : ja(n), r = l ? ka(n + "/" + l) : n);
              l = la(true, true);
              r = ma(r, l);
              if (g) {
                if ("string" == typeof g) {
                  n = Array(g.length);
                  for (var t = 0, y = g.length; t < y; ++t)
                    n[t] = g.charCodeAt(t);
                  g = n;
                }
                na(r, l | 146);
                n = oa(r, 577);
                pa(n, g, 0, g.length, 0);
                qa(n);
                na(r, l);
              }
            }
            this.handleError(q(this.filename, h));
            this.db = m(h, "i32");
            ob(this.db);
            this.fb = {};
            this.Sa = {};
          }
          var h = z(4), k = f.cwrap, q = k("sqlite3_open", "number", ["string", "number"]), w = k("sqlite3_close_v2", "number", ["number"]), v = k("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), C = k("sqlite3_changes", "number", ["number"]), G = k("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), pb = k("sqlite3_sql", "string", ["number"]), nc = k("sqlite3_normalized_sql", "string", ["number"]), qb = k("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), oc = k("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), rb = k("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), pc = k("sqlite3_bind_double", "number", ["number", "number", "number"]), qc = k(
            "sqlite3_bind_int",
            "number",
            ["number", "number", "number"]
          ), rc = k("sqlite3_bind_parameter_index", "number", ["number", "string"]), sc = k("sqlite3_step", "number", ["number"]), tc = k("sqlite3_errmsg", "string", ["number"]), uc = k("sqlite3_column_count", "number", ["number"]), vc = k("sqlite3_data_count", "number", ["number"]), wc = k("sqlite3_column_double", "number", ["number", "number"]), sb = k("sqlite3_column_text", "string", ["number", "number"]), xc = k("sqlite3_column_blob", "number", ["number", "number"]), yc = k("sqlite3_column_bytes", "number", [
            "number",
            "number"
          ]), zc = k("sqlite3_column_type", "number", ["number", "number"]), Ac = k("sqlite3_column_name", "string", ["number", "number"]), Bc = k("sqlite3_reset", "number", ["number"]), Cc = k("sqlite3_clear_bindings", "number", ["number"]), Dc = k("sqlite3_finalize", "number", ["number"]), tb = k("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), hc = k("sqlite3_value_type", "number", ["number"]), kc = k("sqlite3_value_bytes", "number", ["number"]), jc = k(
            "sqlite3_value_text",
            "string",
            ["number"]
          ), lc = k("sqlite3_value_blob", "number", ["number"]), ic = k("sqlite3_value_double", "number", ["number"]), ec = k("sqlite3_result_double", "", ["number", "number"]), lb = k("sqlite3_result_null", "", ["number"]), fc = k("sqlite3_result_text", "", ["number", "string", "number", "number"]), gc = k("sqlite3_result_blob", "", ["number", "number", "number", "number"]), dc = k("sqlite3_result_int", "", ["number", "number"]), va = k("sqlite3_result_error", "", ["number", "string", "number"]), ub = k(
            "sqlite3_aggregate_context",
            "number",
            ["number", "number"]
          ), ob = k("RegisterExtensionFunctions", "number", ["number"]), vb = k("sqlite3_update_hook", "number", ["number", "number", "number"]);
          c.prototype.bind = function(g) {
            if (!this.Qa)
              throw "Statement closed";
            this.reset();
            return Array.isArray(g) ? this.Cb(g) : null != g && "object" === typeof g ? this.Db(g) : true;
          };
          c.prototype.step = function() {
            if (!this.Qa)
              throw "Statement closed";
            this.Oa = 1;
            var g = sc(this.Qa);
            switch (g) {
              case 100:
                return true;
              case 101:
                return false;
              default:
                throw this.db.handleError(g);
            }
          };
          c.prototype.wb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            return wc(this.Qa, g);
          };
          c.prototype.Gb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            g = sb(this.Qa, g);
            if ("function" !== typeof BigInt)
              throw Error("BigInt is not supported");
            return BigInt(g);
          };
          c.prototype.Hb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            return sb(this.Qa, g);
          };
          c.prototype.getBlob = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            var l = yc(this.Qa, g);
            g = xc(this.Qa, g);
            for (var n = new Uint8Array(l), r = 0; r < l; r += 1)
              n[r] = p[g + r];
            return n;
          };
          c.prototype.get = function(g, l) {
            l = l || {};
            null != g && this.bind(g) && this.step();
            g = [];
            for (var n = vc(this.Qa), r = 0; r < n; r += 1)
              switch (zc(this.Qa, r)) {
                case 1:
                  var t = l.useBigInt ? this.Gb(r) : this.wb(r);
                  g.push(t);
                  break;
                case 2:
                  g.push(this.wb(r));
                  break;
                case 3:
                  g.push(this.Hb(r));
                  break;
                case 4:
                  g.push(this.getBlob(r));
                  break;
                default:
                  g.push(null);
              }
            return g;
          };
          c.prototype.getColumnNames = function() {
            for (var g = [], l = uc(this.Qa), n = 0; n < l; n += 1)
              g.push(Ac(this.Qa, n));
            return g;
          };
          c.prototype.getAsObject = function(g, l) {
            g = this.get(g, l);
            l = this.getColumnNames();
            for (var n = {}, r = 0; r < l.length; r += 1)
              n[l[r]] = g[r];
            return n;
          };
          c.prototype.getSQL = function() {
            return pb(this.Qa);
          };
          c.prototype.getNormalizedSQL = function() {
            return nc(this.Qa);
          };
          c.prototype.run = function(g) {
            null != g && this.bind(g);
            this.step();
            return this.reset();
          };
          c.prototype.sb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            g = ra(g);
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(oc(this.Qa, l, n, g.length - 1, 0));
          };
          c.prototype.Bb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(rb(
              this.Qa,
              l,
              n,
              g.length,
              0
            ));
          };
          c.prototype.rb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            this.db.handleError((g === (g | 0) ? qc : pc)(this.Qa, l, g));
          };
          c.prototype.Eb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            rb(this.Qa, g, 0, 0, 0);
          };
          c.prototype.tb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            switch (typeof g) {
              case "string":
                this.sb(g, l);
                return;
              case "number":
                this.rb(g, l);
                return;
              case "bigint":
                this.sb(g.toString(), l);
                return;
              case "boolean":
                this.rb(g + 0, l);
                return;
              case "object":
                if (null === g) {
                  this.Eb(l);
                  return;
                }
                if (null != g.length) {
                  this.Bb(
                    g,
                    l
                  );
                  return;
                }
            }
            throw "Wrong API use : tried to bind a value of an unknown type (" + g + ").";
          };
          c.prototype.Db = function(g) {
            var l = this;
            Object.keys(g).forEach(function(n) {
              var r = rc(l.Qa, n);
              0 !== r && l.tb(g[n], r);
            });
            return true;
          };
          c.prototype.Cb = function(g) {
            for (var l = 0; l < g.length; l += 1)
              this.tb(g[l], l + 1);
            return true;
          };
          c.prototype.reset = function() {
            this.freemem();
            return 0 === Cc(this.Qa) && 0 === Bc(this.Qa);
          };
          c.prototype.freemem = function() {
            for (var g; void 0 !== (g = this.lb.pop()); )
              fa(g);
          };
          c.prototype.free = function() {
            this.freemem();
            var g = 0 === Dc(this.Qa);
            delete this.db.fb[this.Qa];
            this.Qa = 0;
            return g;
          };
          d.prototype.next = function() {
            if (null === this.eb)
              return { done: true };
            null !== this.Za && (this.Za.free(), this.Za = null);
            if (!this.db.db)
              throw this.mb(), Error("Database closed");
            var g = sa(), l = z(4);
            ta(h);
            ta(l);
            try {
              this.db.handleError(qb(this.db.db, this.kb, -1, h, l));
              this.kb = m(l, "i32");
              var n = m(h, "i32");
              if (0 === n)
                return this.mb(), { done: true };
              this.Za = new c(n, this.db);
              this.db.fb[n] = this.Za;
              return { value: this.Za, done: false };
            } catch (r) {
              throw this.pb = ua(this.kb), this.mb(), r;
            } finally {
              wa(g);
            }
          };
          d.prototype.mb = function() {
            fa(this.eb);
            this.eb = null;
          };
          d.prototype.getRemainingSQL = function() {
            return null !== this.pb ? this.pb : ua(this.kb);
          };
          "function" === typeof Symbol && "symbol" === typeof Symbol.iterator && (d.prototype[Symbol.iterator] = function() {
            return this;
          });
          e.prototype.run = function(g, l) {
            if (!this.db)
              throw "Database closed";
            if (l) {
              g = this.prepare(g, l);
              try {
                g.step();
              } finally {
                g.free();
              }
            } else
              this.handleError(v(this.db, g, 0, 0, h));
            return this;
          };
          e.prototype.exec = function(g, l, n) {
            if (!this.db)
              throw "Database closed";
            var r = sa(), t = null;
            try {
              var y = xa(g), L = z(4);
              for (g = []; 0 !== m(y, "i8"); ) {
                ta(h);
                ta(L);
                this.handleError(qb(this.db, y, -1, h, L));
                var J = m(h, "i32");
                y = m(L, "i32");
                if (0 !== J) {
                  var I = null;
                  t = new c(J, this);
                  for (null != l && t.bind(l); t.step(); )
                    null === I && (I = { columns: t.getColumnNames(), values: [] }, g.push(I)), I.values.push(t.get(null, n));
                  t.free();
                }
              }
              return g;
            } catch (M) {
              throw t && t.free(), M;
            } finally {
              wa(r);
            }
          };
          e.prototype.each = function(g, l, n, r, t) {
            "function" === typeof l && (r = n, n = l, l = void 0);
            g = this.prepare(g, l);
            try {
              for (; g.step(); )
                n(g.getAsObject(
                  null,
                  t
                ));
            } finally {
              g.free();
            }
            if ("function" === typeof r)
              return r();
          };
          e.prototype.prepare = function(g, l) {
            ta(h);
            this.handleError(G(this.db, g, -1, h, 0));
            g = m(h, "i32");
            if (0 === g)
              throw "Nothing to prepare";
            var n = new c(g, this);
            null != l && n.bind(l);
            return this.fb[g] = n;
          };
          e.prototype.iterateStatements = function(g) {
            return new d(g, this);
          };
          e.prototype["export"] = function() {
            Object.values(this.fb).forEach(function(l) {
              l.free();
            });
            Object.values(this.Sa).forEach(A);
            this.Sa = {};
            this.handleError(w(this.db));
            var g = ya(this.filename);
            this.handleError(q(
              this.filename,
              h
            ));
            this.db = m(h, "i32");
            ob(this.db);
            return g;
          };
          e.prototype.close = function() {
            null !== this.db && (Object.values(this.fb).forEach(function(g) {
              g.free();
            }), Object.values(this.Sa).forEach(A), this.Sa = {}, this.Ya && (A(this.Ya), this.Ya = void 0), this.handleError(w(this.db)), za("/" + this.filename), this.db = null);
          };
          e.prototype.handleError = function(g) {
            if (0 === g)
              return null;
            g = tc(this.db);
            throw Error(g);
          };
          e.prototype.getRowsModified = function() {
            return C(this.db);
          };
          e.prototype.create_function = function(g, l) {
            Object.prototype.hasOwnProperty.call(
              this.Sa,
              g
            ) && (A(this.Sa[g]), delete this.Sa[g]);
            var n = Aa(function(r, t, y) {
              t = b(t, y);
              try {
                var L = l.apply(null, t);
              } catch (J) {
                va(r, J, -1);
                return;
              }
              a(r, L);
            }, "viii");
            this.Sa[g] = n;
            this.handleError(tb(this.db, g, l.length, 1, 0, n, 0, 0, 0));
            return this;
          };
          e.prototype.create_aggregate = function(g, l) {
            var n = l.init || function() {
              return null;
            }, r = l.finalize || function(I) {
              return I;
            }, t = l.step;
            if (!t)
              throw "An aggregate function must have a step function in " + g;
            var y = {};
            Object.hasOwnProperty.call(this.Sa, g) && (A(this.Sa[g]), delete this.Sa[g]);
            l = g + "__finalize";
            Object.hasOwnProperty.call(this.Sa, l) && (A(this.Sa[l]), delete this.Sa[l]);
            var L = Aa(function(I, M, Ra) {
              var X = ub(I, 1);
              Object.hasOwnProperty.call(y, X) || (y[X] = n());
              M = b(M, Ra);
              M = [y[X]].concat(M);
              try {
                y[X] = t.apply(null, M);
              } catch (Fc) {
                delete y[X], va(I, Fc, -1);
              }
            }, "viii"), J = Aa(function(I) {
              var M = ub(I, 1);
              try {
                var Ra = r(y[M]);
              } catch (X) {
                delete y[M];
                va(I, X, -1);
                return;
              }
              a(I, Ra);
              delete y[M];
            }, "vi");
            this.Sa[g] = L;
            this.Sa[l] = J;
            this.handleError(tb(this.db, g, t.length - 1, 1, 0, 0, L, J, 0));
            return this;
          };
          e.prototype.updateHook = function(g) {
            this.Ya && (vb(this.db, 0, 0), A(this.Ya), this.Ya = void 0);
            g && (this.Ya = Aa(function(l, n, r, t, y) {
              switch (n) {
                case 18:
                  l = "insert";
                  break;
                case 23:
                  l = "update";
                  break;
                case 9:
                  l = "delete";
                  break;
                default:
                  throw "unknown operationCode in updateHook callback: " + n;
              }
              r = r ? B(x, r) : "";
              t = t ? B(x, t) : "";
              if (y > Number.MAX_SAFE_INTEGER)
                throw "rowId too big to fit inside a Number";
              g(l, r, t, Number(y));
            }, "viiiij"), vb(this.db, this.Ya, 0));
          };
          f.Database = e;
        };
        var Ba = { ...f }, Ca = "./this.program", Da = (a, b) => {
          throw b;
        }, D = "", Ea, Fa;
        if (ca) {
          var fs = require("fs");
          require("path");
          D = __dirname + "/";
          Fa = (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs.readFileSync(a);
          };
          Ea = async (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs.readFileSync(a, void 0);
          };
          !f.thisProgram && 1 < process.argv.length && (Ca = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          "undefined" != typeof module2 && (module2.exports = f);
          Da = (a, b) => {
            process.exitCode = a;
            throw b;
          };
        } else if (aa || ba)
          ba ? D = self.location.href : "undefined" != typeof document && document.currentScript && (D = document.currentScript.src), D = D.startsWith("blob:") ? "" : D.slice(0, D.replace(/[?#].*/, "").lastIndexOf("/") + 1), ba && (Fa = (a) => {
            var b = new XMLHttpRequest();
            b.open("GET", a, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          }), Ea = async (a) => {
            if (Ga(a))
              return new Promise((c, d) => {
                var e = new XMLHttpRequest();
                e.open("GET", a, true);
                e.responseType = "arraybuffer";
                e.onload = () => {
                  200 == e.status || 0 == e.status && e.response ? c(e.response) : d(e.status);
                };
                e.onerror = d;
                e.send(null);
              });
            var b = await fetch(a, { credentials: "same-origin" });
            if (b.ok)
              return b.arrayBuffer();
            throw Error(b.status + " : " + b.url);
          };
        var Ha = f.print || console.log.bind(console), Ia = f.printErr || console.error.bind(console);
        Object.assign(f, Ba);
        Ba = null;
        f.thisProgram && (Ca = f.thisProgram);
        var Ja = f.wasmBinary, Ka, La = false, Ma, p, x, Na, E, F, Oa, H, Pa, Ga = (a) => a.startsWith("file://");
        function Qa() {
          var a = Ka.buffer;
          f.HEAP8 = p = new Int8Array(a);
          f.HEAP16 = Na = new Int16Array(a);
          f.HEAPU8 = x = new Uint8Array(a);
          f.HEAPU16 = new Uint16Array(a);
          f.HEAP32 = E = new Int32Array(a);
          f.HEAPU32 = F = new Uint32Array(a);
          f.HEAPF32 = Oa = new Float32Array(a);
          f.HEAPF64 = Pa = new Float64Array(a);
          f.HEAP64 = H = new BigInt64Array(a);
          f.HEAPU64 = new BigUint64Array(a);
        }
        var K = 0, Sa = null;
        function Ta(a) {
          var _a;
          (_a = f.onAbort) == null ? void 0 : _a.call(f, a);
          a = "Aborted(" + a + ")";
          Ia(a);
          La = true;
          throw new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
        }
        var Ua;
        async function Va(a) {
          if (!Ja)
            try {
              var b = await Ea(a);
              return new Uint8Array(b);
            } catch (e) {
            }
          if (a == Ua && Ja)
            a = new Uint8Array(Ja);
          else if (Fa)
            a = Fa(a);
          else
            throw "both async and sync fetching of the wasm failed";
          return a;
        }
        async function Wa(a, b) {
          try {
            var c = await Va(a);
            return await WebAssembly.instantiate(c, b);
          } catch (d) {
            Ia(`failed to asynchronously prepare wasm: ${d}`), Ta(d);
          }
        }
        async function Xa(a) {
          var b = Ua;
          if (!Ja && "function" == typeof WebAssembly.instantiateStreaming && !Ga(b) && !ca)
            try {
              var c = fetch(b, { credentials: "same-origin" });
              return await WebAssembly.instantiateStreaming(c, a);
            } catch (d) {
              Ia(`wasm streaming compile failed: ${d}`), Ia("falling back to ArrayBuffer instantiation");
            }
          return Wa(b, a);
        }
        class Ya {
          constructor(a) {
            __publicField(this, "name", "ExitStatus");
            this.message = `Program terminated with exit(${a})`;
            this.status = a;
          }
        }
        var Za = (a) => {
          for (; 0 < a.length; )
            a.shift()(f);
        }, $a = [], ab = [], bb = () => {
          var a = f.preRun.shift();
          ab.unshift(a);
        };
        function m(a, b = "i8") {
          b.endsWith("*") && (b = "*");
          switch (b) {
            case "i1":
              return p[a];
            case "i8":
              return p[a];
            case "i16":
              return Na[a >> 1];
            case "i32":
              return E[a >> 2];
            case "i64":
              return H[a >> 3];
            case "float":
              return Oa[a >> 2];
            case "double":
              return Pa[a >> 3];
            case "*":
              return F[a >> 2];
            default:
              Ta(`invalid type for getValue: ${b}`);
          }
        }
        var cb = f.noExitRuntime || true;
        function ta(a) {
          var b = "i32";
          b.endsWith("*") && (b = "*");
          switch (b) {
            case "i1":
              p[a] = 0;
              break;
            case "i8":
              p[a] = 0;
              break;
            case "i16":
              Na[a >> 1] = 0;
              break;
            case "i32":
              E[a >> 2] = 0;
              break;
            case "i64":
              H[a >> 3] = BigInt(0);
              break;
            case "float":
              Oa[a >> 2] = 0;
              break;
            case "double":
              Pa[a >> 3] = 0;
              break;
            case "*":
              F[a >> 2] = 0;
              break;
            default:
              Ta(`invalid type for setValue: ${b}`);
          }
        }
        var db = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, B = (a, b = 0, c = NaN) => {
          var d = b + c;
          for (c = b; a[c] && !(c >= d); )
            ++c;
          if (16 < c - b && a.buffer && db)
            return db.decode(a.subarray(b, c));
          for (d = ""; b < c; ) {
            var e = a[b++];
            if (e & 128) {
              var h = a[b++] & 63;
              if (192 == (e & 224))
                d += String.fromCharCode((e & 31) << 6 | h);
              else {
                var k = a[b++] & 63;
                e = 224 == (e & 240) ? (e & 15) << 12 | h << 6 | k : (e & 7) << 18 | h << 12 | k << 6 | a[b++] & 63;
                65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
              }
            } else
              d += String.fromCharCode(e);
          }
          return d;
        }, ua = (a, b) => a ? B(x, a, b) : "", eb = (a, b) => {
          for (var c = 0, d = a.length - 1; 0 <= d; d--) {
            var e = a[d];
            "." === e ? a.splice(d, 1) : ".." === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);
          }
          if (b)
            for (; c; c--)
              a.unshift("..");
          return a;
        }, ka = (a) => {
          var b = "/" === a.charAt(0), c = "/" === a.slice(-1);
          (a = eb(a.split("/").filter((d) => !!d), !b).join("/")) || b || (a = ".");
          a && c && (a += "/");
          return (b ? "/" : "") + a;
        }, fb = (a) => {
          var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
          a = b[0];
          b = b[1];
          if (!a && !b)
            return ".";
          b && (b = b.slice(0, -1));
          return a + b;
        }, gb = (a) => a && a.match(/([^\/]+|\/)\/*$/)[1], hb = () => {
          if (ca) {
            var a = require("crypto");
            return (b) => a.randomFillSync(b);
          }
          return (b) => crypto.getRandomValues(b);
        }, ib = (a) => {
          (ib = hb())(a);
        }, jb = (...a) => {
          for (var b = "", c = false, d = a.length - 1; -1 <= d && !c; d--) {
            c = 0 <= d ? a[d] : "/";
            if ("string" != typeof c)
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!c)
              return "";
            b = c + "/" + b;
            c = "/" === c.charAt(0);
          }
          b = eb(b.split("/").filter((e) => !!e), !c).join("/");
          return (c ? "/" : "") + b || ".";
        }, kb = [], ha = (a) => {
          for (var b = 0, c = 0; c < a.length; ++c) {
            var d = a.charCodeAt(c);
            127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
          }
          return b;
        }, u = (a, b, c, d) => {
          if (!(0 < d))
            return 0;
          var e = c;
          d = c + d - 1;
          for (var h = 0; h < a.length; ++h) {
            var k = a.charCodeAt(h);
            if (55296 <= k && 57343 >= k) {
              var q = a.charCodeAt(++h);
              k = 65536 + ((k & 1023) << 10) | q & 1023;
            }
            if (127 >= k) {
              if (c >= d)
                break;
              b[c++] = k;
            } else {
              if (2047 >= k) {
                if (c + 1 >= d)
                  break;
                b[c++] = 192 | k >> 6;
              } else {
                if (65535 >= k) {
                  if (c + 2 >= d)
                    break;
                  b[c++] = 224 | k >> 12;
                } else {
                  if (c + 3 >= d)
                    break;
                  b[c++] = 240 | k >> 18;
                  b[c++] = 128 | k >> 12 & 63;
                }
                b[c++] = 128 | k >> 6 & 63;
              }
              b[c++] = 128 | k & 63;
            }
          }
          b[c] = 0;
          return c - e;
        }, ra = (a, b) => {
          var c = Array(ha(a) + 1);
          a = u(a, c, 0, c.length);
          b && (c.length = a);
          return c;
        }, mb = [];
        function nb(a, b) {
          mb[a] = { input: [], output: [], cb: b };
          wb(a, xb);
        }
        var xb = { open(a) {
          var b = mb[a.node.rdev];
          if (!b)
            throw new N(43);
          a.tty = b;
          a.seekable = false;
        }, close(a) {
          a.tty.cb.fsync(a.tty);
        }, fsync(a) {
          a.tty.cb.fsync(a.tty);
        }, read(a, b, c, d) {
          if (!a.tty || !a.tty.cb.xb)
            throw new N(60);
          for (var e = 0, h = 0; h < d; h++) {
            try {
              var k = a.tty.cb.xb(a.tty);
            } catch (q) {
              throw new N(29);
            }
            if (void 0 === k && 0 === e)
              throw new N(6);
            if (null === k || void 0 === k)
              break;
            e++;
            b[c + h] = k;
          }
          e && (a.node.atime = Date.now());
          return e;
        }, write(a, b, c, d) {
          if (!a.tty || !a.tty.cb.qb)
            throw new N(60);
          try {
            for (var e = 0; e < d; e++)
              a.tty.cb.qb(a.tty, b[c + e]);
          } catch (h) {
            throw new N(29);
          }
          d && (a.node.mtime = a.node.ctime = Date.now());
          return e;
        } }, yb = { xb() {
          a: {
            if (!kb.length) {
              var a = null;
              if (ca) {
                var b = Buffer.alloc(256), c = 0, d = process.stdin.fd;
                try {
                  c = fs.readSync(d, b, 0, 256);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    c = 0;
                  else
                    throw e;
                }
                0 < c && (a = b.slice(0, c).toString("utf-8"));
              } else
                "undefined" != typeof window && "function" == typeof window.prompt && (a = window.prompt("Input: "), null !== a && (a += "\n"));
              if (!a) {
                a = null;
                break a;
              }
              kb = ra(a, true);
            }
            a = kb.shift();
          }
          return a;
        }, qb(a, b) {
          null === b || 10 === b ? (Ha(B(a.output)), a.output = []) : 0 != b && a.output.push(b);
        }, fsync(a) {
          var _a;
          0 < ((_a = a.output) == null ? void 0 : _a.length) && (Ha(B(a.output)), a.output = []);
        }, Tb() {
          return { Ob: 25856, Qb: 5, Nb: 191, Pb: 35387, Mb: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
        }, Ub() {
          return 0;
        }, Vb() {
          return [24, 80];
        } }, zb = { qb(a, b) {
          null === b || 10 === b ? (Ia(B(a.output)), a.output = []) : 0 != b && a.output.push(b);
        }, fsync(a) {
          var _a;
          0 < ((_a = a.output) == null ? void 0 : _a.length) && (Ia(B(a.output)), a.output = []);
        } }, O = { Wa: null, Xa() {
          return O.createNode(null, "/", 16895, 0);
        }, createNode(a, b, c, d) {
          if (24576 === (c & 61440) || 4096 === (c & 61440))
            throw new N(63);
          O.Wa || (O.Wa = { dir: { node: { Ta: O.La.Ta, Ua: O.La.Ua, lookup: O.La.lookup, hb: O.La.hb, rename: O.La.rename, unlink: O.La.unlink, rmdir: O.La.rmdir, readdir: O.La.readdir, symlink: O.La.symlink }, stream: { Va: O.Ma.Va } }, file: { node: { Ta: O.La.Ta, Ua: O.La.Ua }, stream: { Va: O.Ma.Va, read: O.Ma.read, write: O.Ma.write, ib: O.Ma.ib, jb: O.Ma.jb } }, link: { node: { Ta: O.La.Ta, Ua: O.La.Ua, readlink: O.La.readlink }, stream: {} }, ub: { node: { Ta: O.La.Ta, Ua: O.La.Ua }, stream: Ab } });
          c = Bb(a, b, c, d);
          P(c.mode) ? (c.La = O.Wa.dir.node, c.Ma = O.Wa.dir.stream, c.Na = {}) : 32768 === (c.mode & 61440) ? (c.La = O.Wa.file.node, c.Ma = O.Wa.file.stream, c.Ra = 0, c.Na = null) : 40960 === (c.mode & 61440) ? (c.La = O.Wa.link.node, c.Ma = O.Wa.link.stream) : 8192 === (c.mode & 61440) && (c.La = O.Wa.ub.node, c.Ma = O.Wa.ub.stream);
          c.atime = c.mtime = c.ctime = Date.now();
          a && (a.Na[b] = c, a.atime = a.mtime = a.ctime = c.atime);
          return c;
        }, Sb(a) {
          return a.Na ? a.Na.subarray ? a.Na.subarray(0, a.Ra) : new Uint8Array(a.Na) : new Uint8Array(0);
        }, La: { Ta(a) {
          var b = {};
          b.dev = 8192 === (a.mode & 61440) ? a.id : 1;
          b.ino = a.id;
          b.mode = a.mode;
          b.nlink = 1;
          b.uid = 0;
          b.gid = 0;
          b.rdev = a.rdev;
          P(a.mode) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.Ra : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;
          b.atime = new Date(a.atime);
          b.mtime = new Date(a.mtime);
          b.ctime = new Date(a.ctime);
          b.blksize = 4096;
          b.blocks = Math.ceil(b.size / b.blksize);
          return b;
        }, Ua(a, b) {
          for (var c of ["mode", "atime", "mtime", "ctime"])
            null != b[c] && (a[c] = b[c]);
          void 0 !== b.size && (b = b.size, a.Ra != b && (0 == b ? (a.Na = null, a.Ra = 0) : (c = a.Na, a.Na = new Uint8Array(b), c && a.Na.set(c.subarray(0, Math.min(b, a.Ra))), a.Ra = b)));
        }, lookup() {
          throw O.vb;
        }, hb(a, b, c, d) {
          return O.createNode(a, b, c, d);
        }, rename(a, b, c) {
          try {
            var d = Q(b, c);
          } catch (h) {
          }
          if (d) {
            if (P(a.mode))
              for (var e in d.Na)
                throw new N(55);
            Cb(d);
          }
          delete a.parent.Na[a.name];
          b.Na[c] = a;
          a.name = c;
          b.ctime = b.mtime = a.parent.ctime = a.parent.mtime = Date.now();
        }, unlink(a, b) {
          delete a.Na[b];
          a.ctime = a.mtime = Date.now();
        }, rmdir(a, b) {
          var c = Q(a, b), d;
          for (d in c.Na)
            throw new N(55);
          delete a.Na[b];
          a.ctime = a.mtime = Date.now();
        }, readdir(a) {
          return [".", "..", ...Object.keys(a.Na)];
        }, symlink(a, b, c) {
          a = O.createNode(a, b, 41471, 0);
          a.link = c;
          return a;
        }, readlink(a) {
          if (40960 !== (a.mode & 61440))
            throw new N(28);
          return a.link;
        } }, Ma: { read(a, b, c, d, e) {
          var h = a.node.Na;
          if (e >= a.node.Ra)
            return 0;
          a = Math.min(a.node.Ra - e, d);
          if (8 < a && h.subarray)
            b.set(h.subarray(e, e + a), c);
          else
            for (d = 0; d < a; d++)
              b[c + d] = h[e + d];
          return a;
        }, write(a, b, c, d, e, h) {
          b.buffer === p.buffer && (h = false);
          if (!d)
            return 0;
          a = a.node;
          a.mtime = a.ctime = Date.now();
          if (b.subarray && (!a.Na || a.Na.subarray)) {
            if (h)
              return a.Na = b.subarray(c, c + d), a.Ra = d;
            if (0 === a.Ra && 0 === e)
              return a.Na = b.slice(c, c + d), a.Ra = d;
            if (e + d <= a.Ra)
              return a.Na.set(b.subarray(
                c,
                c + d
              ), e), d;
          }
          h = e + d;
          var k = a.Na ? a.Na.length : 0;
          k >= h || (h = Math.max(h, k * (1048576 > k ? 2 : 1.125) >>> 0), 0 != k && (h = Math.max(h, 256)), k = a.Na, a.Na = new Uint8Array(h), 0 < a.Ra && a.Na.set(k.subarray(0, a.Ra), 0));
          if (a.Na.subarray && b.subarray)
            a.Na.set(b.subarray(c, c + d), e);
          else
            for (h = 0; h < d; h++)
              a.Na[e + h] = b[c + h];
          a.Ra = Math.max(a.Ra, e + d);
          return d;
        }, Va(a, b, c) {
          1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.Ra);
          if (0 > b)
            throw new N(28);
          return b;
        }, ib(a, b, c, d, e) {
          if (32768 !== (a.node.mode & 61440))
            throw new N(43);
          a = a.node.Na;
          if (e & 2 || !a || a.buffer !== p.buffer) {
            e = true;
            d = 65536 * Math.ceil(b / 65536);
            var h = Db(65536, d);
            h && x.fill(0, h, h + d);
            d = h;
            if (!d)
              throw new N(48);
            if (a) {
              if (0 < c || c + b < a.length)
                a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);
              p.set(a, d);
            }
          } else
            e = false, d = a.byteOffset;
          return { Kb: d, Ab: e };
        }, jb(a, b, c, d) {
          O.Ma.write(a, b, 0, d, c, false);
          return 0;
        } } }, la = (a, b) => {
          var c = 0;
          a && (c |= 365);
          b && (c |= 146);
          return c;
        }, Eb = null, Fb = {}, Gb = [], Hb = 1, R = null, Ib = false, Jb = true, Kb = {}, N = class {
          constructor(a) {
            __publicField(this, "name", "ErrnoError");
            this.Pa = a;
          }
        }, Lb = class {
          constructor() {
            __publicField(this, "gb", {});
            __publicField(this, "node", null);
          }
          get flags() {
            return this.gb.flags;
          }
          set flags(a) {
            this.gb.flags = a;
          }
          get position() {
            return this.gb.position;
          }
          set position(a) {
            this.gb.position = a;
          }
        }, Mb = class {
          constructor(a, b, c, d) {
            __publicField(this, "La", {});
            __publicField(this, "Ma", {});
            __publicField(this, "ab", null);
            a || (a = this);
            this.parent = a;
            this.Xa = a.Xa;
            this.id = Hb++;
            this.name = b;
            this.mode = c;
            this.rdev = d;
            this.atime = this.mtime = this.ctime = Date.now();
          }
          get read() {
            return 365 === (this.mode & 365);
          }
          set read(a) {
            a ? this.mode |= 365 : this.mode &= -366;
          }
          get write() {
            return 146 === (this.mode & 146);
          }
          set write(a) {
            a ? this.mode |= 146 : this.mode &= -147;
          }
        };
        function S(a, b = {}) {
          var _a;
          if (!a)
            throw new N(44);
          (_a = b.nb) != null ? _a : b.nb = true;
          "/" === a.charAt(0) || (a = "//" + a);
          var c = 0;
          a:
            for (; 40 > c; c++) {
              a = a.split("/").filter((q) => !!q);
              for (var d = Eb, e = "/", h = 0; h < a.length; h++) {
                var k = h === a.length - 1;
                if (k && b.parent)
                  break;
                if ("." !== a[h])
                  if (".." === a[h])
                    e = fb(e), d = d.parent;
                  else {
                    e = ka(e + "/" + a[h]);
                    try {
                      d = Q(d, a[h]);
                    } catch (q) {
                      if (44 === (q == null ? void 0 : q.Pa) && k && b.Jb)
                        return { path: e };
                      throw q;
                    }
                    !d.ab || k && !b.nb || (d = d.ab.root);
                    if (40960 === (d.mode & 61440) && (!k || b.$a)) {
                      if (!d.La.readlink)
                        throw new N(52);
                      d = d.La.readlink(d);
                      "/" === d.charAt(0) || (d = fb(e) + "/" + d);
                      a = d + "/" + a.slice(h + 1).join("/");
                      continue a;
                    }
                  }
              }
              return { path: e, node: d };
            }
          throw new N(32);
        }
        function ja(a) {
          for (var b; ; ) {
            if (a === a.parent)
              return a = a.Xa.zb, b ? "/" !== a[a.length - 1] ? `${a}/${b}` : a + b : a;
            b = b ? `${a.name}/${b}` : a.name;
            a = a.parent;
          }
        }
        function Nb(a, b) {
          for (var c = 0, d = 0; d < b.length; d++)
            c = (c << 5) - c + b.charCodeAt(d) | 0;
          return (a + c >>> 0) % R.length;
        }
        function Cb(a) {
          var b = Nb(a.parent.id, a.name);
          if (R[b] === a)
            R[b] = a.bb;
          else
            for (b = R[b]; b; ) {
              if (b.bb === a) {
                b.bb = a.bb;
                break;
              }
              b = b.bb;
            }
        }
        function Q(a, b) {
          var c = P(a.mode) ? (c = Ob(a, "x")) ? c : a.La.lookup ? 0 : 2 : 54;
          if (c)
            throw new N(c);
          for (c = R[Nb(a.id, b)]; c; c = c.bb) {
            var d = c.name;
            if (c.parent.id === a.id && d === b)
              return c;
          }
          return a.La.lookup(a, b);
        }
        function Bb(a, b, c, d) {
          a = new Mb(a, b, c, d);
          b = Nb(a.parent.id, a.name);
          a.bb = R[b];
          return R[b] = a;
        }
        function P(a) {
          return 16384 === (a & 61440);
        }
        function Pb(a) {
          var b = ["r", "w", "rw"][a & 3];
          a & 512 && (b += "w");
          return b;
        }
        function Ob(a, b) {
          if (Jb)
            return 0;
          if (!b.includes("r") || a.mode & 292) {
            if (b.includes("w") && !(a.mode & 146) || b.includes("x") && !(a.mode & 73))
              return 2;
          } else
            return 2;
          return 0;
        }
        function Qb(a, b) {
          if (!P(a.mode))
            return 54;
          try {
            return Q(a, b), 20;
          } catch (c) {
          }
          return Ob(a, "wx");
        }
        function Rb(a, b, c) {
          try {
            var d = Q(a, b);
          } catch (e) {
            return e.Pa;
          }
          if (a = Ob(a, "wx"))
            return a;
          if (c) {
            if (!P(d.mode))
              return 54;
            if (d === d.parent || "/" === ja(d))
              return 10;
          } else if (P(d.mode))
            return 31;
          return 0;
        }
        function Sb(a) {
          if (!a)
            throw new N(63);
          return a;
        }
        function T(a) {
          a = Gb[a];
          if (!a)
            throw new N(8);
          return a;
        }
        function Tb(a, b = -1) {
          a = Object.assign(new Lb(), a);
          if (-1 == b)
            a: {
              for (b = 0; 4096 >= b; b++)
                if (!Gb[b])
                  break a;
              throw new N(33);
            }
          a.fd = b;
          return Gb[b] = a;
        }
        function Ub(a, b = -1) {
          var _a, _b;
          a = Tb(a, b);
          (_b = (_a = a.Ma) == null ? void 0 : _a.Rb) == null ? void 0 : _b.call(_a, a);
          return a;
        }
        function Vb(a, b, c) {
          var d = a == null ? void 0 : a.Ma.Ua;
          a = d ? a : b;
          d != null ? d : d = b.La.Ua;
          Sb(d);
          d(a, c);
        }
        var Ab = { open(a) {
          var _a, _b;
          a.Ma = Fb[a.node.rdev].Ma;
          (_b = (_a = a.Ma).open) == null ? void 0 : _b.call(_a, a);
        }, Va() {
          throw new N(70);
        } };
        function wb(a, b) {
          Fb[a] = { Ma: b };
        }
        function Wb(a, b) {
          var c = "/" === b;
          if (c && Eb)
            throw new N(10);
          if (!c && b) {
            var d = S(b, { nb: false });
            b = d.path;
            d = d.node;
            if (d.ab)
              throw new N(10);
            if (!P(d.mode))
              throw new N(54);
          }
          b = { type: a, Wb: {}, zb: b, Ib: [] };
          a = a.Xa(b);
          a.Xa = b;
          b.root = a;
          c ? Eb = a : d && (d.ab = b, d.Xa && d.Xa.Ib.push(b));
        }
        function Xb(a, b, c) {
          var d = S(a, { parent: true }).node;
          a = gb(a);
          if (!a)
            throw new N(28);
          if ("." === a || ".." === a)
            throw new N(20);
          var e = Qb(d, a);
          if (e)
            throw new N(e);
          if (!d.La.hb)
            throw new N(63);
          return d.La.hb(d, a, b, c);
        }
        function ma(a, b = 438) {
          return Xb(a, b & 4095 | 32768, 0);
        }
        function U(a, b = 511) {
          return Xb(a, b & 1023 | 16384, 0);
        }
        function Yb(a, b, c) {
          "undefined" == typeof c && (c = b, b = 438);
          Xb(a, b | 8192, c);
        }
        function Zb(a, b) {
          if (!jb(a))
            throw new N(44);
          var c = S(b, { parent: true }).node;
          if (!c)
            throw new N(44);
          b = gb(b);
          var d = Qb(c, b);
          if (d)
            throw new N(d);
          if (!c.La.symlink)
            throw new N(63);
          c.La.symlink(c, b, a);
        }
        function $b(a) {
          var b = S(a, { parent: true }).node;
          a = gb(a);
          var c = Q(b, a), d = Rb(b, a, true);
          if (d)
            throw new N(d);
          if (!b.La.rmdir)
            throw new N(63);
          if (c.ab)
            throw new N(10);
          b.La.rmdir(b, a);
          Cb(c);
        }
        function za(a) {
          var b = S(a, { parent: true }).node;
          if (!b)
            throw new N(44);
          a = gb(a);
          var c = Q(b, a), d = Rb(b, a, false);
          if (d)
            throw new N(d);
          if (!b.La.unlink)
            throw new N(63);
          if (c.ab)
            throw new N(10);
          b.La.unlink(b, a);
          Cb(c);
        }
        function ac(a, b) {
          a = S(a, { $a: !b }).node;
          return Sb(a.La.Ta)(a);
        }
        function bc(a, b, c, d) {
          Vb(a, b, { mode: c & 4095 | b.mode & -4096, ctime: Date.now(), Fb: d });
        }
        function na(a, b) {
          a = "string" == typeof a ? S(a, { $a: true }).node : a;
          bc(null, a, b);
        }
        function cc(a, b, c) {
          if (P(b.mode))
            throw new N(31);
          if (32768 !== (b.mode & 61440))
            throw new N(28);
          var d = Ob(b, "w");
          if (d)
            throw new N(d);
          Vb(a, b, { size: c, timestamp: Date.now() });
        }
        function oa(a, b, c = 438) {
          if ("" === a)
            throw new N(44);
          if ("string" == typeof b) {
            var d = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[b];
            if ("undefined" == typeof d)
              throw Error(`Unknown file open mode: ${b}`);
            b = d;
          }
          c = b & 64 ? c & 4095 | 32768 : 0;
          if ("object" == typeof a)
            d = a;
          else {
            var e = a.endsWith("/");
            a = S(a, { $a: !(b & 131072), Jb: true });
            d = a.node;
            a = a.path;
          }
          var h = false;
          if (b & 64)
            if (d) {
              if (b & 128)
                throw new N(20);
            } else {
              if (e)
                throw new N(31);
              d = Xb(a, c | 511, 0);
              h = true;
            }
          if (!d)
            throw new N(44);
          8192 === (d.mode & 61440) && (b &= -513);
          if (b & 65536 && !P(d.mode))
            throw new N(54);
          if (!h && (e = d ? 40960 === (d.mode & 61440) ? 32 : P(d.mode) && ("r" !== Pb(b) || b & 576) ? 31 : Ob(d, Pb(b)) : 44))
            throw new N(e);
          b & 512 && !h && (e = d, e = "string" == typeof e ? S(e, { $a: true }).node : e, cc(null, e, 0));
          b &= -131713;
          e = Tb({ node: d, path: ja(d), flags: b, seekable: true, position: 0, Ma: d.Ma, Lb: [], error: false });
          e.Ma.open && e.Ma.open(e);
          h && na(d, c & 511);
          !f.logReadFiles || b & 1 || a in Kb || (Kb[a] = 1);
          return e;
        }
        function qa(a) {
          if (null === a.fd)
            throw new N(8);
          a.ob && (a.ob = null);
          try {
            a.Ma.close && a.Ma.close(a);
          } catch (b) {
            throw b;
          } finally {
            Gb[a.fd] = null;
          }
          a.fd = null;
        }
        function mc(a, b, c) {
          if (null === a.fd)
            throw new N(8);
          if (!a.seekable || !a.Ma.Va)
            throw new N(70);
          if (0 != c && 1 != c && 2 != c)
            throw new N(28);
          a.position = a.Ma.Va(a, b, c);
          a.Lb = [];
        }
        function Ec(a, b, c, d, e) {
          if (0 > d || 0 > e)
            throw new N(28);
          if (null === a.fd)
            throw new N(8);
          if (1 === (a.flags & 2097155))
            throw new N(8);
          if (P(a.node.mode))
            throw new N(31);
          if (!a.Ma.read)
            throw new N(28);
          var h = "undefined" != typeof e;
          if (!h)
            e = a.position;
          else if (!a.seekable)
            throw new N(70);
          b = a.Ma.read(a, b, c, d, e);
          h || (a.position += b);
          return b;
        }
        function pa(a, b, c, d, e) {
          if (0 > d || 0 > e)
            throw new N(28);
          if (null === a.fd)
            throw new N(8);
          if (0 === (a.flags & 2097155))
            throw new N(8);
          if (P(a.node.mode))
            throw new N(31);
          if (!a.Ma.write)
            throw new N(28);
          a.seekable && a.flags & 1024 && mc(a, 0, 2);
          var h = "undefined" != typeof e;
          if (!h)
            e = a.position;
          else if (!a.seekable)
            throw new N(70);
          b = a.Ma.write(a, b, c, d, e, void 0);
          h || (a.position += b);
          return b;
        }
        function ya(a) {
          var b = "binary";
          if ("utf8" !== b && "binary" !== b)
            throw Error(`Invalid encoding type "${b}"`);
          var c;
          var d = oa(a, d || 0);
          a = ac(a).size;
          var e = new Uint8Array(a);
          Ec(d, e, 0, a, 0);
          "utf8" === b ? c = B(e) : "binary" === b && (c = e);
          qa(d);
          return c;
        }
        function V(a, b, c) {
          var _a;
          a = ka("/dev/" + a);
          var d = la(!!b, !!c);
          (_a = V.yb) != null ? _a : V.yb = 64;
          var e = V.yb++ << 8 | 0;
          wb(e, { open(h) {
            h.seekable = false;
          }, close() {
            var _a2;
            ((_a2 = c == null ? void 0 : c.buffer) == null ? void 0 : _a2.length) && c(10);
          }, read(h, k, q, w) {
            for (var v = 0, C = 0; C < w; C++) {
              try {
                var G = b();
              } catch (pb) {
                throw new N(29);
              }
              if (void 0 === G && 0 === v)
                throw new N(6);
              if (null === G || void 0 === G)
                break;
              v++;
              k[q + C] = G;
            }
            v && (h.node.atime = Date.now());
            return v;
          }, write(h, k, q, w) {
            for (var v = 0; v < w; v++)
              try {
                c(k[q + v]);
              } catch (C) {
                throw new N(29);
              }
            w && (h.node.mtime = h.node.ctime = Date.now());
            return v;
          } });
          Yb(a, d, e);
        }
        var W = {};
        function Gc(a, b, c) {
          if ("/" === b.charAt(0))
            return b;
          a = -100 === a ? "/" : T(a).path;
          if (0 == b.length) {
            if (!c)
              throw new N(44);
            return a;
          }
          return a + "/" + b;
        }
        function Hc(a, b) {
          E[a >> 2] = b.dev;
          E[a + 4 >> 2] = b.mode;
          F[a + 8 >> 2] = b.nlink;
          E[a + 12 >> 2] = b.uid;
          E[a + 16 >> 2] = b.gid;
          E[a + 20 >> 2] = b.rdev;
          H[a + 24 >> 3] = BigInt(b.size);
          E[a + 32 >> 2] = 4096;
          E[a + 36 >> 2] = b.blocks;
          var c = b.atime.getTime(), d = b.mtime.getTime(), e = b.ctime.getTime();
          H[a + 40 >> 3] = BigInt(Math.floor(c / 1e3));
          F[a + 48 >> 2] = c % 1e3 * 1e6;
          H[a + 56 >> 3] = BigInt(Math.floor(d / 1e3));
          F[a + 64 >> 2] = d % 1e3 * 1e6;
          H[a + 72 >> 3] = BigInt(Math.floor(e / 1e3));
          F[a + 80 >> 2] = e % 1e3 * 1e6;
          H[a + 88 >> 3] = BigInt(b.ino);
          return 0;
        }
        var Ic = void 0, Jc = () => {
          var a = E[+Ic >> 2];
          Ic += 4;
          return a;
        }, Kc = 0, Lc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Mc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Nc = {}, Oc = (a) => {
          var _a;
          Ma = a;
          cb || 0 < Kc || ((_a = f.onExit) == null ? void 0 : _a.call(f, a), La = true);
          Da(a, new Ya(a));
        }, Pc = (a) => {
          if (!La)
            try {
              if (a(), !(cb || 0 < Kc))
                try {
                  Ma = a = Ma, Oc(a);
                } catch (b) {
                  b instanceof Ya || "unwind" == b || Da(1, b);
                }
            } catch (b) {
              b instanceof Ya || "unwind" == b || Da(1, b);
            }
        }, Qc = {}, Sc = () => {
          if (!Rc) {
            var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: Ca || "./this.program" }, b;
            for (b in Qc)
              void 0 === Qc[b] ? delete a[b] : a[b] = Qc[b];
            var c = [];
            for (b in a)
              c.push(`${b}=${a[b]}`);
            Rc = c;
          }
          return Rc;
        }, Rc, xa = (a) => {
          var b = ha(a) + 1, c = z(b);
          u(a, x, c, b);
          return c;
        }, Tc = (a, b, c, d) => {
          var e = { string: (v) => {
            var C = 0;
            null !== v && void 0 !== v && 0 !== v && (C = xa(v));
            return C;
          }, array: (v) => {
            var C = z(v.length);
            p.set(v, C);
            return C;
          } };
          a = f["_" + a];
          var h = [], k = 0;
          if (d)
            for (var q = 0; q < d.length; q++) {
              var w = e[c[q]];
              w ? (0 === k && (k = sa()), h[q] = w(d[q])) : h[q] = d[q];
            }
          c = a(...h);
          return c = function(v) {
            0 !== k && wa(k);
            return "string" === b ? v ? B(x, v) : "" : "boolean" === b ? !!v : v;
          }(c);
        }, ea = 0, da = (a, b) => {
          b = 1 == b ? z(a.length) : ia(a.length);
          a.subarray || a.slice || (a = new Uint8Array(a));
          x.set(a, b);
          return b;
        }, Uc, Vc = [], Y, A = (a) => {
          Uc.delete(Y.get(a));
          Y.set(a, null);
          Vc.push(a);
        }, Aa = (a, b) => {
          if (!Uc) {
            Uc = /* @__PURE__ */ new WeakMap();
            var c = Y.length;
            if (Uc)
              for (var d = 0; d < 0 + c; d++) {
                var e = Y.get(d);
                e && Uc.set(e, d);
              }
          }
          if (c = Uc.get(a) || 0)
            return c;
          if (Vc.length)
            c = Vc.pop();
          else {
            try {
              Y.grow(1);
            } catch (w) {
              if (!(w instanceof RangeError))
                throw w;
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            c = Y.length - 1;
          }
          try {
            Y.set(c, a);
          } catch (w) {
            if (!(w instanceof TypeError))
              throw w;
            if ("function" == typeof WebAssembly.Function) {
              var h = WebAssembly.Function;
              d = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
              e = { parameters: [], results: "v" == b[0] ? [] : [d[b[0]]] };
              for (var k = 1; k < b.length; ++k)
                e.parameters.push(d[b[k]]);
              b = new h(e, a);
            } else {
              d = [1];
              e = b.slice(0, 1);
              b = b.slice(1);
              k = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
              d.push(96);
              var q = b.length;
              128 > q ? d.push(q) : d.push(q % 128 | 128, q >> 7);
              for (h of b)
                d.push(k[h]);
              "v" == e ? d.push(0) : d.push(1, k[e]);
              b = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              h = d.length;
              128 > h ? b.push(h) : b.push(h % 128 | 128, h >> 7);
              b.push(...d);
              b.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              b = new WebAssembly.Module(new Uint8Array(b));
              b = new WebAssembly.Instance(b, { e: { f: a } }).exports.f;
            }
            Y.set(c, b);
          }
          Uc.set(a, c);
          return c;
        };
        R = Array(4096);
        Wb(O, "/");
        U("/tmp");
        U("/home");
        U("/home/web_user");
        (function() {
          U("/dev");
          wb(259, { read: () => 0, write: (d, e, h, k) => k, Va: () => 0 });
          Yb("/dev/null", 259);
          nb(1280, yb);
          nb(1536, zb);
          Yb("/dev/tty", 1280);
          Yb("/dev/tty1", 1536);
          var a = new Uint8Array(1024), b = 0, c = () => {
            0 === b && (ib(a), b = a.byteLength);
            return a[--b];
          };
          V("random", c);
          V("urandom", c);
          U("/dev/shm");
          U("/dev/shm/tmp");
        })();
        (function() {
          U("/proc");
          var a = U("/proc/self");
          U("/proc/self/fd");
          Wb({ Xa() {
            var b = Bb(a, "fd", 16895, 73);
            b.Ma = { Va: O.Ma.Va };
            b.La = { lookup(c, d) {
              c = +d;
              var e = T(c);
              c = { parent: null, Xa: { zb: "fake" }, La: { readlink: () => e.path }, id: c + 1 };
              return c.parent = c;
            }, readdir() {
              return Array.from(Gb.entries()).filter(([, c]) => c).map(([c]) => c.toString());
            } };
            return b;
          } }, "/proc/self/fd");
        })();
        O.vb = new N(44);
        O.vb.stack = "<generic error, no stack>";
        var Xc = { a: (a, b, c, d) => Ta(`Assertion failed: ${a ? B(x, a) : ""}, at: ` + [b ? b ? B(x, b) : "" : "unknown filename", c, d ? d ? B(x, d) : "" : "unknown function"]), i: function(a, b) {
          try {
            return a = a ? B(x, a) : "", na(a, b), 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, L: function(a, b, c) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            if (c & -8)
              return -28;
            var d = S(b, { $a: true }).node;
            if (!d)
              return -44;
            a = "";
            c & 4 && (a += "r");
            c & 2 && (a += "w");
            c & 1 && (a += "x");
            return a && Ob(d, a) ? -2 : 0;
          } catch (e) {
            if ("undefined" == typeof W || "ErrnoError" !== e.name)
              throw e;
            return -e.Pa;
          }
        }, j: function(a, b) {
          try {
            var c = T(a);
            bc(c, c.node, b, false);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, h: function(a) {
          try {
            var b = T(a);
            Vb(b, b.node, { timestamp: Date.now(), Fb: false });
            return 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, b: function(a, b, c) {
          Ic = c;
          try {
            var d = T(a);
            switch (b) {
              case 0:
                var e = Jc();
                if (0 > e)
                  break;
                for (; Gb[e]; )
                  e++;
                return Ub(d, e).fd;
              case 1:
              case 2:
                return 0;
              case 3:
                return d.flags;
              case 4:
                return e = Jc(), d.flags |= e, 0;
              case 12:
                return e = Jc(), Na[e + 0 >> 1] = 2, 0;
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, g: function(a, b) {
          try {
            var c = T(a), d = c.node, e = c.Ma.Ta;
            a = e ? c : d;
            e != null ? e : e = d.La.Ta;
            Sb(e);
            var h = e(a);
            return Hc(b, h);
          } catch (k) {
            if ("undefined" == typeof W || "ErrnoError" !== k.name)
              throw k;
            return -k.Pa;
          }
        }, H: function(a, b) {
          b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
          try {
            if (isNaN(b))
              return 61;
            var c = T(a);
            if (0 > b || 0 === (c.flags & 2097155))
              throw new N(28);
            cc(c, c.node, b);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, G: function(a, b) {
          try {
            if (0 === b)
              return -28;
            var c = ha("/") + 1;
            if (b < c)
              return -68;
            u("/", x, a, b);
            return c;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, K: function(a, b) {
          try {
            return a = a ? B(x, a) : "", Hc(b, ac(a, true));
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, C: function(a, b, c) {
          try {
            return b = b ? B(x, b) : "", b = Gc(a, b), U(b, c), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, J: function(a, b, c, d) {
          try {
            b = b ? B(x, b) : "";
            var e = d & 256;
            b = Gc(a, b, d & 4096);
            return Hc(c, e ? ac(b, true) : ac(b));
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, x: function(a, b, c, d) {
          Ic = d;
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            var e = d ? Jc() : 0;
            return oa(b, c, e).fd;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, v: function(a, b, c, d) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            if (0 >= d)
              return -28;
            var e = S(b).node;
            if (!e)
              throw new N(44);
            if (!e.La.readlink)
              throw new N(28);
            var h = e.La.readlink(e);
            var k = Math.min(d, ha(h)), q = p[c + k];
            u(h, x, c, d + 1);
            p[c + k] = q;
            return k;
          } catch (w) {
            if ("undefined" == typeof W || "ErrnoError" !== w.name)
              throw w;
            return -w.Pa;
          }
        }, u: function(a) {
          try {
            return a = a ? B(x, a) : "", $b(a), 0;
          } catch (b) {
            if ("undefined" == typeof W || "ErrnoError" !== b.name)
              throw b;
            return -b.Pa;
          }
        }, f: function(a, b) {
          try {
            return a = a ? B(x, a) : "", Hc(b, ac(a));
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, r: function(a, b, c) {
          try {
            return b = b ? B(x, b) : "", b = Gc(a, b), 0 === c ? za(b) : 512 === c ? $b(b) : Ta("Invalid flags passed to unlinkat"), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, q: function(a, b, c) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b, true);
            var d = Date.now(), e, h;
            if (c) {
              var k = F[c >> 2] + 4294967296 * E[c + 4 >> 2], q = E[c + 8 >> 2];
              1073741823 == q ? e = d : 1073741822 == q ? e = null : e = 1e3 * k + q / 1e6;
              c += 16;
              k = F[c >> 2] + 4294967296 * E[c + 4 >> 2];
              q = E[c + 8 >> 2];
              1073741823 == q ? h = d : 1073741822 == q ? h = null : h = 1e3 * k + q / 1e6;
            } else
              h = e = d;
            if (null !== (h != null ? h : e)) {
              a = e;
              var w = S(b, { $a: true }).node;
              Sb(w.La.Ua)(w, { atime: a, mtime: h });
            }
            return 0;
          } catch (v) {
            if ("undefined" == typeof W || "ErrnoError" !== v.name)
              throw v;
            return -v.Pa;
          }
        }, m: () => Ta(""), l: () => {
          cb = false;
          Kc = 0;
        }, A: function(a, b) {
          a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a);
          a = new Date(1e3 * a);
          E[b >> 2] = a.getSeconds();
          E[b + 4 >> 2] = a.getMinutes();
          E[b + 8 >> 2] = a.getHours();
          E[b + 12 >> 2] = a.getDate();
          E[b + 16 >> 2] = a.getMonth();
          E[b + 20 >> 2] = a.getFullYear() - 1900;
          E[b + 24 >> 2] = a.getDay();
          var c = a.getFullYear();
          E[b + 28 >> 2] = (0 !== c % 4 || 0 === c % 100 && 0 !== c % 400 ? Mc : Lc)[a.getMonth()] + a.getDate() - 1 | 0;
          E[b + 36 >> 2] = -(60 * a.getTimezoneOffset());
          c = new Date(
            a.getFullYear(),
            6,
            1
          ).getTimezoneOffset();
          var d = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
          E[b + 32 >> 2] = (c != d && a.getTimezoneOffset() == Math.min(d, c)) | 0;
        }, y: function(a, b, c, d, e, h, k) {
          e = -9007199254740992 > e || 9007199254740992 < e ? NaN : Number(e);
          try {
            if (isNaN(e))
              return 61;
            var q = T(d);
            if (0 !== (b & 2) && 0 === (c & 2) && 2 !== (q.flags & 2097155))
              throw new N(2);
            if (1 === (q.flags & 2097155))
              throw new N(2);
            if (!q.Ma.ib)
              throw new N(43);
            if (!a)
              throw new N(28);
            var w = q.Ma.ib(q, a, e, b, c);
            var v = w.Kb;
            E[h >> 2] = w.Ab;
            F[k >> 2] = v;
            return 0;
          } catch (C) {
            if ("undefined" == typeof W || "ErrnoError" !== C.name)
              throw C;
            return -C.Pa;
          }
        }, z: function(a, b, c, d, e, h) {
          h = -9007199254740992 > h || 9007199254740992 < h ? NaN : Number(h);
          try {
            var k = T(e);
            if (c & 2) {
              c = h;
              if (32768 !== (k.node.mode & 61440))
                throw new N(43);
              if (!(d & 2)) {
                var q = x.slice(a, a + b);
                k.Ma.jb && k.Ma.jb(k, q, c, b, d);
              }
            }
          } catch (w) {
            if ("undefined" == typeof W || "ErrnoError" !== w.name)
              throw w;
            return -w.Pa;
          }
        }, n: (a, b) => {
          Nc[a] && (clearTimeout(Nc[a].id), delete Nc[a]);
          if (!b)
            return 0;
          var c = setTimeout(() => {
            delete Nc[a];
            Pc(() => Wc(a, performance.now()));
          }, b);
          Nc[a] = {
            id: c,
            Xb: b
          };
          return 0;
        }, B: (a, b, c, d) => {
          var e = (/* @__PURE__ */ new Date()).getFullYear(), h = new Date(e, 0, 1).getTimezoneOffset();
          e = new Date(e, 6, 1).getTimezoneOffset();
          F[a >> 2] = 60 * Math.max(h, e);
          E[b >> 2] = Number(h != e);
          b = (k) => {
            var q = Math.abs(k);
            return `UTC${0 <= k ? "-" : "+"}${String(Math.floor(q / 60)).padStart(2, "0")}${String(q % 60).padStart(2, "0")}`;
          };
          a = b(h);
          b = b(e);
          e < h ? (u(a, x, c, 17), u(b, x, d, 17)) : (u(a, x, d, 17), u(b, x, c, 17));
        }, d: () => Date.now(), s: () => 2147483648, c: () => performance.now(), o: (a) => {
          var b = x.length;
          a >>>= 0;
          if (2147483648 < a)
            return false;
          for (var c = 1; 4 >= c; c *= 2) {
            var d = b * (1 + 0.2 / c);
            d = Math.min(d, a + 100663296);
            a: {
              d = (Math.min(2147483648, 65536 * Math.ceil(Math.max(a, d) / 65536)) - Ka.buffer.byteLength + 65535) / 65536 | 0;
              try {
                Ka.grow(d);
                Qa();
                var e = 1;
                break a;
              } catch (h) {
              }
              e = void 0;
            }
            if (e)
              return true;
          }
          return false;
        }, E: (a, b) => {
          var c = 0;
          Sc().forEach((d, e) => {
            var h = b + c;
            e = F[a + 4 * e >> 2] = h;
            for (h = 0; h < d.length; ++h)
              p[e++] = d.charCodeAt(h);
            p[e] = 0;
            c += d.length + 1;
          });
          return 0;
        }, F: (a, b) => {
          var c = Sc();
          F[a >> 2] = c.length;
          var d = 0;
          c.forEach((e) => d += e.length + 1);
          F[b >> 2] = d;
          return 0;
        }, e: function(a) {
          try {
            var b = T(a);
            qa(b);
            return 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return c.Pa;
          }
        }, p: function(a, b) {
          try {
            var c = T(a);
            p[b] = c.tty ? 2 : P(c.mode) ? 3 : 40960 === (c.mode & 61440) ? 7 : 4;
            Na[b + 2 >> 1] = 0;
            H[b + 8 >> 3] = BigInt(0);
            H[b + 16 >> 3] = BigInt(0);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return d.Pa;
          }
        }, w: function(a, b, c, d) {
          try {
            a: {
              var e = T(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var q = F[a >> 2], w = F[a + 4 >> 2];
                a += 8;
                var v = Ec(e, p, q, w, h);
                if (0 > v) {
                  var C = -1;
                  break a;
                }
                b += v;
                if (v < w)
                  break;
                "undefined" != typeof h && (h += v);
              }
              C = b;
            }
            F[d >> 2] = C;
            return 0;
          } catch (G) {
            if ("undefined" == typeof W || "ErrnoError" !== G.name)
              throw G;
            return G.Pa;
          }
        }, D: function(a, b, c, d) {
          b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
          try {
            if (isNaN(b))
              return 61;
            var e = T(a);
            mc(e, b, c);
            H[d >> 3] = BigInt(e.position);
            e.ob && 0 === b && 0 === c && (e.ob = null);
            return 0;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return h.Pa;
          }
        }, I: function(a) {
          var _a;
          try {
            var b = T(a);
            return ((_a = b.Ma) == null ? void 0 : _a.fsync) ? b.Ma.fsync(b) : 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return c.Pa;
          }
        }, t: function(a, b, c, d) {
          try {
            a: {
              var e = T(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var q = F[a >> 2], w = F[a + 4 >> 2];
                a += 8;
                var v = pa(e, p, q, w, h);
                if (0 > v) {
                  var C = -1;
                  break a;
                }
                b += v;
                if (v < w)
                  break;
                "undefined" != typeof h && (h += v);
              }
              C = b;
            }
            F[d >> 2] = C;
            return 0;
          } catch (G) {
            if ("undefined" == typeof W || "ErrnoError" !== G.name)
              throw G;
            return G.Pa;
          }
        }, k: Oc }, Z;
        (async function() {
          var _a;
          function a(c) {
            var _a2;
            Z = c.exports;
            Ka = Z.M;
            Qa();
            Y = Z.O;
            K--;
            (_a2 = f.monitorRunDependencies) == null ? void 0 : _a2.call(f, K);
            0 == K && Sa && (c = Sa, Sa = null, c());
            return Z;
          }
          K++;
          (_a = f.monitorRunDependencies) == null ? void 0 : _a.call(f, K);
          var b = { a: Xc };
          if (f.instantiateWasm)
            return new Promise((c) => {
              f.instantiateWasm(b, (d, e) => {
                a(d, e);
                c(d.exports);
              });
            });
          Ua != null ? Ua : Ua = f.locateFile ? f.locateFile("sql-wasm.wasm", D) : D + "sql-wasm.wasm";
          return a((await Xa(b)).instance);
        })();
        f._sqlite3_free = (a) => (f._sqlite3_free = Z.P)(a);
        f._sqlite3_value_text = (a) => (f._sqlite3_value_text = Z.Q)(a);
        f._sqlite3_prepare_v2 = (a, b, c, d, e) => (f._sqlite3_prepare_v2 = Z.R)(a, b, c, d, e);
        f._sqlite3_step = (a) => (f._sqlite3_step = Z.S)(a);
        f._sqlite3_reset = (a) => (f._sqlite3_reset = Z.T)(a);
        f._sqlite3_exec = (a, b, c, d, e) => (f._sqlite3_exec = Z.U)(a, b, c, d, e);
        f._sqlite3_finalize = (a) => (f._sqlite3_finalize = Z.V)(a);
        f._sqlite3_column_name = (a, b) => (f._sqlite3_column_name = Z.W)(a, b);
        f._sqlite3_column_text = (a, b) => (f._sqlite3_column_text = Z.X)(a, b);
        f._sqlite3_column_type = (a, b) => (f._sqlite3_column_type = Z.Y)(a, b);
        f._sqlite3_errmsg = (a) => (f._sqlite3_errmsg = Z.Z)(a);
        f._sqlite3_clear_bindings = (a) => (f._sqlite3_clear_bindings = Z._)(a);
        f._sqlite3_value_blob = (a) => (f._sqlite3_value_blob = Z.$)(a);
        f._sqlite3_value_bytes = (a) => (f._sqlite3_value_bytes = Z.aa)(a);
        f._sqlite3_value_double = (a) => (f._sqlite3_value_double = Z.ba)(a);
        f._sqlite3_value_int = (a) => (f._sqlite3_value_int = Z.ca)(a);
        f._sqlite3_value_type = (a) => (f._sqlite3_value_type = Z.da)(a);
        f._sqlite3_result_blob = (a, b, c, d) => (f._sqlite3_result_blob = Z.ea)(a, b, c, d);
        f._sqlite3_result_double = (a, b) => (f._sqlite3_result_double = Z.fa)(a, b);
        f._sqlite3_result_error = (a, b, c) => (f._sqlite3_result_error = Z.ga)(a, b, c);
        f._sqlite3_result_int = (a, b) => (f._sqlite3_result_int = Z.ha)(a, b);
        f._sqlite3_result_int64 = (a, b) => (f._sqlite3_result_int64 = Z.ia)(a, b);
        f._sqlite3_result_null = (a) => (f._sqlite3_result_null = Z.ja)(a);
        f._sqlite3_result_text = (a, b, c, d) => (f._sqlite3_result_text = Z.ka)(a, b, c, d);
        f._sqlite3_aggregate_context = (a, b) => (f._sqlite3_aggregate_context = Z.la)(a, b);
        f._sqlite3_column_count = (a) => (f._sqlite3_column_count = Z.ma)(a);
        f._sqlite3_data_count = (a) => (f._sqlite3_data_count = Z.na)(a);
        f._sqlite3_column_blob = (a, b) => (f._sqlite3_column_blob = Z.oa)(a, b);
        f._sqlite3_column_bytes = (a, b) => (f._sqlite3_column_bytes = Z.pa)(a, b);
        f._sqlite3_column_double = (a, b) => (f._sqlite3_column_double = Z.qa)(a, b);
        f._sqlite3_bind_blob = (a, b, c, d, e) => (f._sqlite3_bind_blob = Z.ra)(a, b, c, d, e);
        f._sqlite3_bind_double = (a, b, c) => (f._sqlite3_bind_double = Z.sa)(a, b, c);
        f._sqlite3_bind_int = (a, b, c) => (f._sqlite3_bind_int = Z.ta)(a, b, c);
        f._sqlite3_bind_text = (a, b, c, d, e) => (f._sqlite3_bind_text = Z.ua)(a, b, c, d, e);
        f._sqlite3_bind_parameter_index = (a, b) => (f._sqlite3_bind_parameter_index = Z.va)(a, b);
        f._sqlite3_sql = (a) => (f._sqlite3_sql = Z.wa)(a);
        f._sqlite3_normalized_sql = (a) => (f._sqlite3_normalized_sql = Z.xa)(a);
        f._sqlite3_changes = (a) => (f._sqlite3_changes = Z.ya)(a);
        f._sqlite3_close_v2 = (a) => (f._sqlite3_close_v2 = Z.za)(a);
        f._sqlite3_create_function_v2 = (a, b, c, d, e, h, k, q, w) => (f._sqlite3_create_function_v2 = Z.Aa)(a, b, c, d, e, h, k, q, w);
        f._sqlite3_update_hook = (a, b, c) => (f._sqlite3_update_hook = Z.Ba)(a, b, c);
        f._sqlite3_open = (a, b) => (f._sqlite3_open = Z.Ca)(a, b);
        var ia = f._malloc = (a) => (ia = f._malloc = Z.Da)(a), fa = f._free = (a) => (fa = f._free = Z.Ea)(a);
        f._RegisterExtensionFunctions = (a) => (f._RegisterExtensionFunctions = Z.Fa)(a);
        var Db = (a, b) => (Db = Z.Ga)(a, b), Wc = (a, b) => (Wc = Z.Ha)(a, b), wa = (a) => (wa = Z.Ia)(a), z = (a) => (z = Z.Ja)(a), sa = () => (sa = Z.Ka)();
        f.stackSave = () => sa();
        f.stackRestore = (a) => wa(a);
        f.stackAlloc = (a) => z(a);
        f.cwrap = (a, b, c, d) => {
          var e = !c || c.every((h) => "number" === h || "boolean" === h);
          return "string" !== b && e && !d ? f["_" + a] : (...h) => Tc(a, b, c, h);
        };
        f.addFunction = Aa;
        f.removeFunction = A;
        f.UTF8ToString = ua;
        f.ALLOC_NORMAL = ea;
        f.allocate = da;
        f.allocateUTF8OnStack = xa;
        function Yc() {
          function a() {
            var _a;
            f.calledRun = true;
            if (!La) {
              if (!f.noFSInit && !Ib) {
                var b, c;
                Ib = true;
                d != null ? d : d = f.stdin;
                b != null ? b : b = f.stdout;
                c != null ? c : c = f.stderr;
                d ? V("stdin", d) : Zb("/dev/tty", "/dev/stdin");
                b ? V("stdout", null, b) : Zb("/dev/tty", "/dev/stdout");
                c ? V("stderr", null, c) : Zb("/dev/tty1", "/dev/stderr");
                oa("/dev/stdin", 0);
                oa("/dev/stdout", 1);
                oa("/dev/stderr", 1);
              }
              Z.N();
              Jb = false;
              (_a = f.onRuntimeInitialized) == null ? void 0 : _a.call(f);
              if (f.postRun)
                for ("function" == typeof f.postRun && (f.postRun = [f.postRun]); f.postRun.length; ) {
                  var d = f.postRun.shift();
                  $a.unshift(d);
                }
              Za($a);
            }
          }
          if (0 < K)
            Sa = Yc;
          else {
            if (f.preRun)
              for ("function" == typeof f.preRun && (f.preRun = [f.preRun]); f.preRun.length; )
                bb();
            Za(ab);
            0 < K ? Sa = Yc : f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
              setTimeout(() => f.setStatus(""), 1);
              a();
            }, 1)) : a();
          }
        }
        if (f.preInit)
          for ("function" == typeof f.preInit && (f.preInit = [f.preInit]); 0 < f.preInit.length; )
            f.preInit.pop()();
        Yc();
        return Module;
      });
      return initSqlJsPromise;
    };
    if (typeof exports === "object" && typeof module2 === "object") {
      module2.exports = initSqlJs2;
      module2.exports.default = initSqlJs2;
    } else if (typeof define === "function" && define["amd"]) {
      define([], function() {
        return initSqlJs2;
      });
    } else if (typeof exports === "object") {
      exports["Module"] = initSqlJs2;
    }
  }
});

// src/settings.ts
var settings_exports = {};
__export(settings_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS
});
var DEFAULT_SETTINGS;
var init_settings = __esm({
  "src/settings.ts"() {
    DEFAULT_SETTINGS = {
      fsrs: {
        requestRetention: 0.9,
        maximumInterval: 36500,
        // 100 years
        easyBonus: 1.3,
        hardInterval: 1.2,
        weights: [
          0.4072,
          1.1829,
          3.1262,
          15.4722,
          7.2102,
          0.5316,
          1.0651,
          0.0234,
          1.616,
          0.1544,
          1.0824,
          1.9813,
          0.0953,
          0.2975,
          2.2042,
          0.2407,
          2.9466
        ]
      },
      database: {
        autoBackup: true,
        backupInterval: 7
      },
      review: {
        showProgress: true,
        enableKeyboardShortcuts: true,
        sessionGoal: 20,
        enableSessionLimit: false
      },
      parsing: {
        headerLevel: 2
        // Default to H2 headers
      },
      ui: {
        enableBackgroundRefresh: true,
        backgroundRefreshInterval: 5
      },
      debug: {
        enableLogging: false
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlashcardsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/database/DatabaseService.ts
var import_sql = __toESM(require_sql_wasm());

// src/database/types.ts
var DEFAULT_DECK_CONFIG = {
  newCardsLimit: 20,
  reviewCardsLimit: 100,
  enableNewCardsLimit: false,
  enableReviewCardsLimit: false,
  reviewOrder: "due-date"
};

// src/database/DatabaseService.ts
var DatabaseService = class {
  constructor(dbPath) {
    this.db = null;
    this.SQL = null;
    this.dbPath = dbPath;
  }
  async initialize() {
    try {
      this.SQL = await (0, import_sql.default)({
        locateFile: (file) => `https://sql.js.org/dist/${file}`
      });
      const buffer = await this.loadDatabaseFile();
      if (buffer) {
        this.db = new this.SQL.Database(new Uint8Array(buffer));
        await this.migrateSchemaIfNeeded();
      } else {
        this.db = new this.SQL.Database();
        await this.createTables();
      }
    } catch (error) {
      console.error("Failed to initialize database:", error);
      throw error;
    }
  }
  async loadDatabaseFile() {
    try {
      const adapter = window.app.vault.adapter;
      if (await adapter.exists(this.dbPath)) {
        const data = await adapter.readBinary(this.dbPath);
        return data;
      }
      return null;
    } catch (error) {
      console.log("Database file doesn't exist yet, will create new one");
      return null;
    }
  }
  async save() {
    if (!this.db)
      throw new Error("Database not initialized");
    try {
      const data = this.db.export();
      const adapter = window.app.vault.adapter;
      const dir = this.dbPath.substring(0, this.dbPath.lastIndexOf("/"));
      if (!await adapter.exists(dir)) {
        await adapter.mkdir(dir);
      }
      await adapter.writeBinary(this.dbPath, Buffer.from(data));
    } catch (error) {
      console.error("Failed to save database:", error);
      throw error;
    }
  }
  async createTables() {
    if (!this.db)
      throw new Error("Database not initialized");
    const sql = `
      -- Decks table
      CREATE TABLE IF NOT EXISTS decks (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        filepath TEXT NOT NULL UNIQUE,
        tag TEXT NOT NULL,
        last_reviewed TEXT,
        config TEXT NOT NULL DEFAULT '{"newCardsLimit":20,"reviewCardsLimit":100,"enableNewCardsLimit":false,"enableReviewCardsLimit":false,"reviewOrder":"due-date"}',
        created TEXT NOT NULL,
        modified TEXT NOT NULL
      );

      -- Flashcards table
      CREATE TABLE IF NOT EXISTS flashcards (
        id TEXT PRIMARY KEY,
        deck_id TEXT NOT NULL,
        front TEXT NOT NULL,
        back TEXT NOT NULL,
        type TEXT NOT NULL CHECK (type IN ('header-paragraph', 'table')),
        source_file TEXT NOT NULL,
        line_number INTEGER NOT NULL,
        content_hash TEXT NOT NULL,
        state TEXT NOT NULL DEFAULT 'new' CHECK (state IN ('new', 'learning', 'review')),
        due_date TEXT NOT NULL,
        interval INTEGER NOT NULL DEFAULT 0,
        repetitions INTEGER NOT NULL DEFAULT 0,
        ease_factor REAL NOT NULL DEFAULT 2.5,
        stability REAL NOT NULL DEFAULT 2.5,
        lapses INTEGER NOT NULL DEFAULT 0,
        last_reviewed TEXT,
        created TEXT NOT NULL,
        modified TEXT NOT NULL,
        FOREIGN KEY (deck_id) REFERENCES decks(id) ON DELETE CASCADE
      );

      -- Review logs table
      CREATE TABLE IF NOT EXISTS review_logs (
        id TEXT PRIMARY KEY,
        flashcard_id TEXT NOT NULL,
        reviewed_at TEXT NOT NULL,
        difficulty TEXT NOT NULL CHECK (difficulty IN ('again', 'hard', 'good', 'easy')),
        old_interval INTEGER NOT NULL,
        new_interval INTEGER NOT NULL,
        old_ease_factor REAL NOT NULL,
        new_ease_factor REAL NOT NULL,
        FOREIGN KEY (flashcard_id) REFERENCES flashcards(id)
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_flashcards_deck_id ON flashcards(deck_id);
      CREATE INDEX IF NOT EXISTS idx_flashcards_due_date ON flashcards(due_date);
      CREATE INDEX IF NOT EXISTS idx_review_logs_flashcard_id ON review_logs(flashcard_id);
      CREATE INDEX IF NOT EXISTS idx_review_logs_reviewed_at ON review_logs(reviewed_at);
    `;
    this.db.run(sql);
  }
  // Helper method to parse deck rows
  parseDeckRow(row) {
    return {
      id: row[0],
      name: row[1],
      filepath: row[2],
      tag: row[3],
      lastReviewed: row[4],
      config: row[5] ? JSON.parse(row[5]) : DEFAULT_DECK_CONFIG,
      created: row[6],
      modified: row[7]
    };
  }
  // Deck operations
  async createDeck(deck) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const fullDeck = {
      ...deck,
      created: now,
      modified: now
    };
    try {
      const stmt = this.db.prepare(`
        INSERT INTO decks (id, name, filepath, tag, last_reviewed, config, created, modified)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);
      stmt.run([
        fullDeck.id,
        fullDeck.name,
        fullDeck.filepath,
        fullDeck.tag,
        fullDeck.lastReviewed,
        JSON.stringify(fullDeck.config),
        fullDeck.created,
        fullDeck.modified
      ]);
      stmt.free();
      await this.save();
      return fullDeck;
    } catch (error) {
      throw error;
    }
  }
  async getDeckByTag(tag) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("SELECT * FROM decks WHERE tag = ?");
    stmt.bind([tag]);
    if (stmt.step()) {
      const result = stmt.get();
      stmt.free();
      return this.parseDeckRow(result);
    }
    stmt.free();
    return null;
  }
  async getDeckByFilepath(filepath) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("SELECT * FROM decks WHERE filepath = ?");
    stmt.bind([filepath]);
    if (stmt.step()) {
      const result = stmt.get();
      stmt.free();
      return this.parseDeckRow(result);
    }
    stmt.free();
    return null;
  }
  async getDeckById(id) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("SELECT * FROM decks WHERE id = ?");
    stmt.bind([id]);
    if (stmt.step()) {
      const result = stmt.get();
      stmt.free();
      return this.parseDeckRow(result);
    }
    stmt.free();
    return null;
  }
  async updateDeck(deckId, updates) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updateFields = Object.keys(updates).map((key) => {
      const dbField = key === "lastReviewed" ? "last_reviewed" : key;
      return `${dbField} = ?`;
    }).join(", ");
    const stmt = this.db.prepare(`
      UPDATE decks
      SET ${updateFields}, modified = ?
      WHERE id = ?
    `);
    const values = Object.values(updates).map(
      (value, index) => {
        const key = Object.keys(updates)[index];
        return key === "config" ? JSON.stringify(value) : value;
      }
    );
    values.push(now, deckId);
    stmt.run(values);
    stmt.free();
    await this.save();
  }
  async getAllDecks() {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("SELECT * FROM decks ORDER BY name");
    const decks = [];
    while (stmt.step()) {
      const row = stmt.get();
      decks.push(this.parseDeckRow(row));
    }
    stmt.free();
    return decks;
  }
  async updateDeckLastReviewed(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare(`
      UPDATE decks
      SET last_reviewed = ?, modified = ?
      WHERE id = ?
    `);
    stmt.run([(/* @__PURE__ */ new Date()).toISOString(), (/* @__PURE__ */ new Date()).toISOString(), deckId]);
    stmt.free();
    await this.save();
  }
  async deleteDeckByFilepath(filepath) {
    if (!this.db)
      throw new Error("Database not initialized");
    const deck = await this.getDeckByFilepath(filepath);
    if (!deck)
      return;
    const flashcardsStmt = this.db.prepare(
      "DELETE FROM flashcards WHERE deck_id = ?"
    );
    flashcardsStmt.run([deck.id]);
    flashcardsStmt.free();
    const deckStmt = this.db.prepare("DELETE FROM decks WHERE filepath = ?");
    deckStmt.run([filepath]);
    deckStmt.free();
    await this.save();
  }
  async deleteDeck(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const flashcardsStmt = this.db.prepare(
      "DELETE FROM flashcards WHERE deck_id = ?"
    );
    flashcardsStmt.run([deckId]);
    flashcardsStmt.free();
    const deckStmt = this.db.prepare("DELETE FROM decks WHERE id = ?");
    deckStmt.run([deckId]);
    deckStmt.free();
    await this.save();
  }
  // Flashcard operations
  async createFlashcard(flashcard) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const fullFlashcard = {
      ...flashcard,
      created: now,
      modified: now
    };
    const stmt = this.db.prepare(`
      INSERT OR REPLACE INTO flashcards (
        id, deck_id, front, back, type, source_file, line_number, content_hash,
        state, due_date, interval, repetitions, ease_factor, stability, lapses, last_reviewed, created, modified
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run([
      fullFlashcard.id,
      fullFlashcard.deckId,
      fullFlashcard.front,
      fullFlashcard.back,
      fullFlashcard.type,
      fullFlashcard.sourceFile,
      fullFlashcard.lineNumber,
      fullFlashcard.contentHash,
      fullFlashcard.state,
      fullFlashcard.dueDate,
      fullFlashcard.interval,
      fullFlashcard.repetitions,
      fullFlashcard.easeFactor,
      fullFlashcard.stability,
      fullFlashcard.lapses,
      fullFlashcard.lastReviewed,
      fullFlashcard.created,
      fullFlashcard.modified
    ]);
    stmt.free();
    await this.save();
    return fullFlashcard;
  }
  async updateFlashcard(flashcardId, updates) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updateFields = Object.keys(updates).map((key) => {
      const dbField = key === "contentHash" ? "content_hash" : key === "sourceFile" ? "source_file" : key === "lineNumber" ? "line_number" : key === "dueDate" ? "due_date" : key === "easeFactor" ? "ease_factor" : key === "lastReviewed" ? "last_reviewed" : key.replace(/([A-Z])/g, "_$1").toLowerCase();
      return `${dbField} = ?`;
    }).join(", ");
    const stmt = this.db.prepare(`
      UPDATE flashcards
      SET ${updateFields}, modified = ?
      WHERE id = ?
    `);
    const values = Object.values(updates);
    values.push(now, flashcardId);
    stmt.run(values);
    stmt.free();
    await this.save();
  }
  async deleteFlashcard(flashcardId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("DELETE FROM flashcards WHERE id = ?");
    stmt.run([flashcardId]);
    stmt.free();
    await this.save();
  }
  async getFlashcardsByDeck(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare("SELECT * FROM flashcards WHERE deck_id = ?");
    stmt.bind([deckId]);
    const flashcards = [];
    while (stmt.step()) {
      const row = stmt.get();
      flashcards.push(this.rowToFlashcard(row));
    }
    stmt.free();
    return flashcards;
  }
  async getDueFlashcards(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
      SELECT * FROM flashcards
      WHERE deck_id = ? AND due_date <= ?
      ORDER BY due_date
    `);
    stmt.bind([deckId, now]);
    const flashcards = [];
    while (stmt.step()) {
      const row = stmt.get();
      flashcards.push(this.rowToFlashcard(row));
    }
    stmt.free();
    return flashcards;
  }
  async getDailyReviewCounts(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const todayStart = `${today}T00:00:00.000Z`;
    const todayEnd = `${today}T23:59:59.999Z`;
    const newCardsStmt = this.db.prepare(`
      SELECT COUNT(*) as count FROM review_logs rl
      JOIN flashcards f ON rl.flashcard_id = f.id
      WHERE f.deck_id = ?
        AND rl.reviewed_at >= ?
        AND rl.reviewed_at <= ?
        AND (rl.old_interval = 0 OR f.repetitions = 1)
    `);
    newCardsStmt.bind([deckId, todayStart, todayEnd]);
    const newResult = newCardsStmt.step() ? newCardsStmt.get() : [0];
    const newCount = Number(newResult[0]) || 0;
    newCardsStmt.free();
    const reviewCardsStmt = this.db.prepare(`
      SELECT COUNT(*) as count FROM review_logs rl
      JOIN flashcards f ON rl.flashcard_id = f.id
      WHERE f.deck_id = ?
        AND rl.reviewed_at >= ?
        AND rl.reviewed_at <= ?
        AND rl.old_interval > 0
    `);
    reviewCardsStmt.bind([deckId, todayStart, todayEnd]);
    const reviewResult = reviewCardsStmt.step() ? reviewCardsStmt.get() : [0];
    const reviewCount = Number(reviewResult[0]) || 0;
    reviewCardsStmt.free();
    return { newCount, reviewCount };
  }
  async getReviewableFlashcards(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const deck = await this.getDeckById(deckId);
    if (!deck) {
      throw new Error(`Deck not found: ${deckId}`);
    }
    const config = deck.config;
    const flashcards = [];
    const dailyCounts = await this.getDailyReviewCounts(deckId);
    const learningStmt = this.db.prepare(`
      SELECT * FROM flashcards
      WHERE deck_id = ? AND due_date <= ? AND state = 'learning'
      ORDER BY due_date
    `);
    learningStmt.bind([deckId, now]);
    while (learningStmt.step()) {
      const row = learningStmt.get();
      flashcards.push(this.rowToFlashcard(row));
    }
    learningStmt.free();
    const newCardsLimit = Number(config.newCardsLimit) || 0;
    const newCountToday = Number(dailyCounts.newCount) || 0;
    const remainingNewCards = config.enableNewCardsLimit && newCardsLimit > 0 ? Math.max(0, newCardsLimit - newCountToday) : config.enableNewCardsLimit && newCardsLimit === 0 ? 0 : Number.MAX_SAFE_INTEGER;
    if (remainingNewCards > 0) {
      const newCardsStmt = this.db.prepare(`
        SELECT * FROM flashcards
        WHERE deck_id = ? AND due_date <= ? AND state = 'new'
        ORDER BY due_date
        ${config.enableNewCardsLimit ? `LIMIT ${remainingNewCards}` : ""}
      `);
      newCardsStmt.bind([deckId, now]);
      while (newCardsStmt.step()) {
        const row = newCardsStmt.get();
        flashcards.push(this.rowToFlashcard(row));
      }
      newCardsStmt.free();
    }
    const reviewCardsLimit = Number(config.reviewCardsLimit) || 0;
    const reviewCountToday = Number(dailyCounts.reviewCount) || 0;
    const remainingReviewCards = config.enableReviewCardsLimit && reviewCardsLimit > 0 ? Math.max(0, reviewCardsLimit - reviewCountToday) : config.enableReviewCardsLimit && reviewCardsLimit === 0 ? 0 : Number.MAX_SAFE_INTEGER;
    if (remainingReviewCards > 0) {
      const reviewCardsStmt = this.db.prepare(`
        SELECT * FROM flashcards
        WHERE deck_id = ? AND due_date <= ? AND state = 'review'
        ORDER BY due_date
        ${config.enableReviewCardsLimit ? `LIMIT ${remainingReviewCards}` : ""}
      `);
      reviewCardsStmt.bind([deckId, now]);
      while (reviewCardsStmt.step()) {
        const row = reviewCardsStmt.get();
        flashcards.push(this.rowToFlashcard(row));
      }
      reviewCardsStmt.free();
    }
    flashcards.sort((a, b) => {
      const stateOrder = { learning: 1, review: 2, new: 3 };
      const aOrder = stateOrder[a.state];
      const bOrder = stateOrder[b.state];
      if (aOrder !== bOrder) {
        return aOrder - bOrder;
      }
      if (a.state === "learning") {
        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
      } else if (a.state === "review") {
        if (config.reviewOrder === "random") {
          return Math.random() - 0.5;
        } else {
          return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
        }
      } else {
        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
      }
    });
    return flashcards;
  }
  async deleteFlashcardsByFile(sourceFile) {
    if (!this.db)
      throw new Error("Database not initialized");
    const stmt = this.db.prepare(
      "DELETE FROM flashcards WHERE source_file = ?"
    );
    stmt.run([sourceFile]);
    stmt.free();
    await this.save();
  }
  // Review log operations
  async createReviewLog(log) {
    if (!this.db)
      throw new Error("Database not initialized");
    const id = `review_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const stmt = this.db.prepare(`
      INSERT INTO review_logs (
        id, flashcard_id, reviewed_at, difficulty,
        old_interval, new_interval, old_ease_factor, new_ease_factor
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run([
      id,
      log.flashcardId,
      log.reviewedAt,
      log.difficulty,
      log.oldInterval,
      log.newInterval,
      log.oldEaseFactor,
      log.newEaseFactor
    ]);
    stmt.free();
    await this.save();
  }
  // Statistics operations
  async getDeckStats(deckId) {
    if (!this.db)
      throw new Error("Database not initialized");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const deck = await this.getDeckById(deckId);
    if (!deck) {
      throw new Error(`Deck not found: ${deckId}`);
    }
    const config = deck.config;
    const dailyCounts = await this.getDailyReviewCounts(deckId);
    const newStmt = this.db.prepare(`
      SELECT COUNT(*) FROM flashcards
      WHERE deck_id = ? AND state = 'new' AND due_date <= ?
    `);
    newStmt.bind([deckId, now]);
    newStmt.step();
    const totalNewCards = newStmt.get()[0] || 0;
    newStmt.free();
    let newCount = totalNewCards;
    const newCardsLimit = Number(config.newCardsLimit) || 0;
    const newCountToday = Number(dailyCounts.newCount) || 0;
    if (config.enableNewCardsLimit && newCardsLimit > 0) {
      const remainingNew = Math.max(0, newCardsLimit - newCountToday);
      newCount = Math.min(totalNewCards, remainingNew);
    } else if (config.enableNewCardsLimit && newCardsLimit === 0) {
      newCount = 0;
    }
    const learningStmt = this.db.prepare(`
      SELECT COUNT(*) FROM flashcards
      WHERE deck_id = ? AND state = 'learning' AND due_date <= ?
    `);
    learningStmt.bind([deckId, now]);
    learningStmt.step();
    const learningCount = learningStmt.get()[0] || 0;
    learningStmt.free();
    const dueStmt = this.db.prepare(`
      SELECT COUNT(*) FROM flashcards
      WHERE deck_id = ? AND state = 'review' AND due_date <= ?
    `);
    dueStmt.bind([deckId, now]);
    dueStmt.step();
    const totalDueCards = dueStmt.get()[0] || 0;
    dueStmt.free();
    let dueCount = totalDueCards;
    const reviewCardsLimit = Number(config.reviewCardsLimit) || 0;
    const reviewCountToday = Number(dailyCounts.reviewCount) || 0;
    if (config.enableReviewCardsLimit && reviewCardsLimit > 0) {
      const remainingReview = Math.max(0, reviewCardsLimit - reviewCountToday);
      dueCount = Math.min(totalDueCards, remainingReview);
    } else if (config.enableReviewCardsLimit && reviewCardsLimit === 0) {
      dueCount = 0;
    }
    const totalStmt = this.db.prepare(`
      SELECT COUNT(*) FROM flashcards WHERE deck_id = ?
    `);
    totalStmt.bind([deckId]);
    totalStmt.step();
    const totalCount = totalStmt.get()[0] || 0;
    totalStmt.free();
    return {
      deckId,
      newCount,
      learningCount,
      dueCount,
      totalCount
    };
  }
  async getAllDeckStats() {
    if (!this.db)
      throw new Error("Database not initialized");
    const decks = await this.getAllDecks();
    const stats = [];
    for (const deck of decks) {
      const deckStats = await this.getDeckStats(deck.id);
      stats.push(deckStats);
    }
    return stats;
  }
  async getReviewCountsByDate(days = 365) {
    if (!this.db)
      throw new Error("Database not initialized");
    const endDate = /* @__PURE__ */ new Date();
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(endDate.getDate() - days);
    const stmt = this.db.prepare(`
      SELECT DATE(reviewed_at) as review_date, COUNT(*) as count
      FROM review_logs
      WHERE reviewed_at >= ? AND reviewed_at <= ?
      GROUP BY DATE(reviewed_at)
      ORDER BY review_date
    `);
    stmt.bind([startDate.toISOString(), endDate.toISOString()]);
    const reviewCounts = /* @__PURE__ */ new Map();
    while (stmt.step()) {
      const row = stmt.get();
      const date = row[0];
      const count = row[1];
      reviewCounts.set(date, count);
    }
    stmt.free();
    return reviewCounts;
  }
  async migrateSchemaIfNeeded() {
    if (!this.db)
      return;
    try {
      const stmt = this.db.prepare("PRAGMA table_info(decks)");
      const columns = [];
      while (stmt.step()) {
        columns.push(stmt.get());
      }
      stmt.free();
      const hasFilepath = columns.some((col) => col[1] === "filepath");
      const hasConfig = columns.some((col) => col[1] === "config");
      if (!hasFilepath || !hasConfig) {
        console.log(
          "Migrating database schema to support filepath and config columns..."
        );
        console.log(
          "Clearing old data - decks will be rebuilt from files on next sync"
        );
        this.db.exec(`
          -- Drop existing tables
          DROP TABLE IF EXISTS review_logs;
          DROP TABLE IF EXISTS flashcards;
          DROP TABLE IF EXISTS decks;
        `);
        await this.createTables();
        console.log(
          "Database schema migration completed. Data will be rebuilt from vault files."
        );
        await this.save();
      }
    } catch (error) {
      console.error("Error during schema migration:", error);
    }
  }
  // Helper methods
  rowToFlashcard(row) {
    return {
      id: row[0],
      deckId: row[1],
      front: row[2],
      back: row[3],
      type: row[4],
      sourceFile: row[5],
      lineNumber: row[6],
      contentHash: row[7],
      state: row[8],
      dueDate: row[9],
      interval: row[10],
      repetitions: row[11],
      easeFactor: row[12],
      stability: row[13],
      lapses: row[14],
      lastReviewed: row[15],
      created: row[16],
      modified: row[17]
    };
  }
  async getOverallStatistics(deckFilter = "all", timeframe = "12months") {
    if (!this.db)
      throw new Error("Database not initialized");
    try {
      const cutoffDate = /* @__PURE__ */ new Date();
      if (timeframe === "12months") {
        cutoffDate.setFullYear(cutoffDate.getFullYear() - 1);
      } else {
        cutoffDate.setFullYear(cutoffDate.getFullYear() - 10);
      }
      let deckFilterCondition = "";
      let deckFilterParams = [];
      if (deckFilter.startsWith("deck:")) {
        const deckId = deckFilter.substring(5);
        deckFilterCondition = "AND f.deck_id = ?";
        deckFilterParams.push(deckId);
      } else if (deckFilter.startsWith("tag:")) {
        const tag = deckFilter.substring(4);
        deckFilterCondition = "AND d.tag = ?";
        deckFilterParams.push(tag);
      }
      const dailyStatsStmt = this.db.prepare(`
      SELECT
        DATE(reviewed_at) as date,
        COUNT(*) as reviews,
        COUNT(CASE WHEN difficulty != 'again' THEN 1 END) as correct,
        COUNT(CASE WHEN f.state = 'new' THEN 1 END) as new_cards,
        COUNT(CASE WHEN f.state = 'learning' THEN 1 END) as learning_cards,
        COUNT(CASE WHEN f.state = 'review' THEN 1 END) as review_cards
      FROM review_logs rl
      JOIN flashcards f ON rl.flashcard_id = f.id
      ${deckFilterCondition ? "JOIN decks d ON f.deck_id = d.id" : ""}
      WHERE DATE(reviewed_at) >= DATE(?)
      ${deckFilterCondition}
      GROUP BY DATE(reviewed_at)
      ORDER BY date DESC
    `);
      dailyStatsStmt.bind([
        cutoffDate.toISOString().split("T")[0],
        ...deckFilterParams
      ]);
      const dailyStats = [];
      while (dailyStatsStmt.step()) {
        const row = dailyStatsStmt.get();
        const reviews = row[1];
        const correct = row[2];
        dailyStats.push({
          date: row[0],
          reviews,
          timeSpent: reviews * 30,
          // Estimate 30 seconds per review
          newCards: row[3],
          learningCards: row[4],
          reviewCards: row[5],
          correctRate: reviews > 0 ? correct / reviews * 100 : 0
        });
      }
      dailyStatsStmt.free();
      const cardStatsStmt = this.db.prepare(`
      SELECT
        f.state,
        COUNT(*) as count
      FROM flashcards f
      ${deckFilterCondition ? "JOIN decks d ON f.deck_id = d.id" : ""}
      WHERE 1=1
      ${deckFilterCondition}
      GROUP BY f.state
    `);
      const cardStats = {
        new: 0,
        learning: 0,
        mature: 0
      };
      if (deckFilterCondition) {
        cardStatsStmt.bind(deckFilterParams);
      }
      while (cardStatsStmt.step()) {
        const row = cardStatsStmt.get();
        const state = row[0];
        const count = row[1];
        if (state === "new")
          cardStats.new = count;
        else if (state === "learning")
          cardStats.learning = count;
        else if (state === "review")
          cardStats.mature = count;
      }
      cardStatsStmt.free();
      const answerButtonsStmt = this.db.prepare(`
      SELECT
        rl.difficulty,
        COUNT(*) as count
      FROM review_logs rl
      JOIN flashcards f ON rl.flashcard_id = f.id
      ${deckFilterCondition ? "JOIN decks d ON f.deck_id = d.id" : ""}
      WHERE DATE(rl.reviewed_at) >= DATE(?)
      ${deckFilterCondition}
      GROUP BY rl.difficulty
    `);
      const answerButtons = {
        again: 0,
        hard: 0,
        good: 0,
        easy: 0
      };
      answerButtonsStmt.bind([
        cutoffDate.toISOString().split("T")[0],
        ...deckFilterParams
      ]);
      while (answerButtonsStmt.step()) {
        const row = answerButtonsStmt.get();
        const difficulty = row[0];
        const count = row[1];
        answerButtons[difficulty] = count;
      }
      answerButtonsStmt.free();
      const totalReviews = Object.values(answerButtons).reduce(
        (sum, count) => sum + count,
        0
      );
      const correctReviews = totalReviews - answerButtons.again;
      const retentionRate = totalReviews > 0 ? correctReviews / totalReviews * 100 : 0;
      const intervalsStmt = this.db.prepare(`
      SELECT
        CASE
          WHEN f.interval < 1440 THEN CAST(f.interval / 60 AS INTEGER) || 'h'
          WHEN f.interval < 43200 THEN CAST(f.interval / 1440 AS INTEGER) || 'd'
          ELSE CAST(f.interval / 43200 AS INTEGER) || 'm'
        END as interval_group,
        COUNT(*) as count
      FROM flashcards f
      ${deckFilterCondition ? "JOIN decks d ON f.deck_id = d.id" : ""}
      WHERE f.state != 'new'
      ${deckFilterCondition}
      GROUP BY interval_group
      ORDER BY f.interval
    `);
      if (deckFilterCondition) {
        intervalsStmt.bind(deckFilterParams);
      }
      const intervals = [];
      while (intervalsStmt.step()) {
        const row = intervalsStmt.get();
        intervals.push({
          interval: row[0],
          count: row[1]
        });
      }
      intervalsStmt.free();
      const forecast = [];
      const today = /* @__PURE__ */ new Date();
      for (let i = 0; i < 90; i++) {
        const forecastDate = new Date(today);
        forecastDate.setDate(today.getDate() + i);
        const dateStr = forecastDate.toISOString().split("T")[0];
        const forecastStmt = this.db.prepare(`
        SELECT COUNT(*) as due_count
        FROM flashcards f
        ${deckFilterCondition ? "JOIN decks d ON f.deck_id = d.id" : ""}
        WHERE DATE(f.due_date) = DATE(?)
        ${deckFilterCondition}
      `);
        forecastStmt.bind([dateStr, ...deckFilterParams]);
        let dueCount = 0;
        if (forecastStmt.step()) {
          const row = forecastStmt.get();
          dueCount = row[0];
        }
        forecastStmt.free();
        forecast.push({
          date: dateStr,
          dueCount
        });
      }
      return {
        dailyStats,
        cardStats,
        answerButtons,
        retentionRate,
        intervals,
        forecast
      };
    } catch (error) {
      console.error("Error in getOverallStatistics:", error);
      return {
        dailyStats: [],
        cardStats: { new: 0, learning: 0, mature: 0 },
        answerButtons: { again: 0, hard: 0, good: 0, easy: 0 },
        retentionRate: 0,
        intervals: [],
        forecast: []
      };
    }
  }
  async close() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
};

// src/services/DeckManager.ts
var import_obsidian = require("obsidian");
var DeckManager = class {
  // FlashcardsPlugin reference for debug logging
  constructor(vault, metadataCache, db, plugin) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.db = db;
    this.plugin = plugin;
  }
  debugLog(message, ...args) {
    var _a;
    if ((_a = this.plugin) == null ? void 0 : _a.debugLog) {
      this.plugin.debugLog(message, ...args);
    }
  }
  /**
   * Scan vault for all decks (files with #flashcards tags)
   */
  async scanVaultForDecks() {
    const decksMap = /* @__PURE__ */ new Map();
    const files = this.vault.getMarkdownFiles();
    this.debugLog(`Scanning ${files.length} markdown files for flashcard tags`);
    for (const file of files) {
      const metadata = this.metadataCache.getFileCache(file);
      if (!metadata) {
        this.debugLog(`No metadata for file: ${file.path}`);
        continue;
      }
      this.debugLog(`Checking file: ${file.path}`);
      const allTags = [];
      if (metadata.tags) {
        const inlineTags = metadata.tags.map((t) => t.tag);
        allTags.push(...inlineTags);
        this.debugLog(`File ${file.path} has inline tags:`, inlineTags);
      }
      if (metadata.frontmatter && metadata.frontmatter.tags) {
        const frontmatterTags = Array.isArray(metadata.frontmatter.tags) ? metadata.frontmatter.tags : [metadata.frontmatter.tags];
        const normalizedTags = frontmatterTags.map(
          (tag) => tag.startsWith("#") ? tag : `#${tag}`
        );
        allTags.push(...normalizedTags);
        this.debugLog(
          `File ${file.path} has frontmatter tags:`,
          normalizedTags
        );
      }
      if (allTags.length === 0) {
        continue;
      }
      const flashcardTags = allTags.filter(
        (tag) => tag.startsWith("#flashcards")
      );
      this.debugLog(`All tags for ${file.path}:`, allTags);
      this.debugLog(`Flashcard tags for ${file.path}:`, flashcardTags);
      for (const tag of flashcardTags) {
        if (!decksMap.has(tag)) {
          decksMap.set(tag, []);
        }
        decksMap.get(tag).push(file);
      }
    }
    this.debugLog(`Found ${decksMap.size} decks:`, Array.from(decksMap.keys()));
    return decksMap;
  }
  /**
   * Sync decks with database
   */
  async syncDecks() {
    try {
      this.debugLog("Starting deck sync...");
      const decksMap = await this.scanVaultForDecks();
      this.debugLog("Decks found in vault:", decksMap);
      const existingDecks = await this.db.getAllDecks();
      this.debugLog("Existing decks in database:", existingDecks);
      const existingDecksByFile = /* @__PURE__ */ new Map();
      for (const deck of existingDecks) {
        existingDecksByFile.set(deck.filepath, deck);
      }
      let newDecksCreated = 0;
      let totalFiles = 0;
      for (const [tag, files] of decksMap) {
        for (const file of files) {
          totalFiles++;
          const filePath = file.path;
          const deckName = file.basename;
          const existingDeck = existingDecksByFile.get(filePath);
          this.debugLog(`Checking file: ${filePath}`);
          this.debugLog(
            `Existing deck found:`,
            existingDeck ? `YES (ID: ${existingDeck.id})` : "NO"
          );
          if (existingDeck) {
            if (existingDeck.tag !== tag) {
              this.debugLog(
                `Updating deck "${deckName}" tag from ${existingDeck.tag} to ${tag}`
              );
              await this.db.updateDeck(existingDeck.id, {
                tag
              });
            } else {
              this.debugLog(
                `Deck "${deckName}" already exists with correct tag, no update needed`
              );
            }
          } else {
            const deck = {
              id: this.generateDeckId(filePath),
              name: deckName,
              // Store clean file name
              filepath: filePath,
              // Store full file path separately
              tag,
              lastReviewed: null,
              config: DEFAULT_DECK_CONFIG
            };
            this.debugLog(
              `Creating new deck: "${deckName}" with ID: ${deck.id}, tag: ${tag}, filepath: ${filePath}`
            );
            await this.db.createDeck(deck);
            newDecksCreated++;
          }
        }
      }
      const allFiles = /* @__PURE__ */ new Set();
      for (const [tag, files] of decksMap) {
        for (const file of files) {
          allFiles.add(file.path);
        }
      }
      let deletedDecks = 0;
      for (const deck of existingDecks) {
        if (!allFiles.has(deck.filepath)) {
          this.debugLog(
            `Deleting orphaned deck: "${deck.name}" (${deck.filepath})`
          );
          await this.db.deleteDeckByFilepath(deck.filepath);
          deletedDecks++;
        }
      }
      this.debugLog(
        `Deck sync completed. Processed ${totalFiles} files, created ${newDecksCreated} new decks, deleted ${deletedDecks} orphaned decks.`
      );
    } catch (error) {
      console.error("Error during deck sync:", error);
      throw error;
    }
  }
  /**
   * Parse flashcards from a file
   */
  async parseFlashcardsFromFile(file) {
    var _a, _b, _c;
    const content = await this.vault.read(file);
    const lines = content.split("\n");
    const flashcards = [];
    const tableFlashcards = this.parseTableFlashcards(lines);
    flashcards.push(...tableFlashcards);
    const headerLevel = ((_c = (_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.parsing) == null ? void 0 : _c.headerLevel) || 2;
    const headerFlashcards = this.parseHeaderParagraphFlashcards(
      lines,
      headerLevel
    );
    flashcards.push(...headerFlashcards);
    return flashcards;
  }
  /**
   * Parse table-based flashcards
   */
  parseTableFlashcards(lines) {
    const flashcards = [];
    let inTable = false;
    let tableStartLine = 0;
    let headerSeen = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.startsWith("|") && line.endsWith("|")) {
        if (!inTable) {
          inTable = true;
          tableStartLine = i;
          headerSeen = false;
        }
        if (!headerSeen) {
          headerSeen = true;
          continue;
        }
        if (line.match(/^\|[\s-]+\|[\s-]+\|$/)) {
          continue;
        }
        const cells = line.split("|").map((cell) => cell.trim()).filter((cell) => cell.length > 0);
        if (cells.length >= 2) {
          flashcards.push({
            front: cells[0],
            back: cells[1],
            type: "table",
            lineNumber: i + 1
          });
        }
      } else {
        inTable = false;
      }
    }
    return flashcards;
  }
  /**
   * Parse header+paragraph flashcards
   */
  parseHeaderParagraphFlashcards(lines, headerLevel = 2) {
    const flashcards = [];
    let currentHeader = null;
    let currentContent = [];
    let inFrontmatter = false;
    let skipNextParagraph = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (i === 0 && line === "---") {
        inFrontmatter = true;
        continue;
      }
      if (inFrontmatter && line === "---") {
        inFrontmatter = false;
        continue;
      }
      if (inFrontmatter) {
        continue;
      }
      const headerRegex = new RegExp(`^#{${headerLevel}}\\s+`);
      if (line.match(headerRegex)) {
        if (line.match(/^#\s+/) && line.toLowerCase().includes("flashcard")) {
          skipNextParagraph = true;
          currentHeader = null;
          currentContent = [];
          continue;
        }
        if (currentHeader && currentContent.length > 0) {
          const card = {
            front: currentHeader.text.replace(
              new RegExp(`^#{${headerLevel}}\\s+`),
              ""
            ),
            back: currentContent.join("\n").trim(),
            type: "header-paragraph",
            lineNumber: currentHeader.lineNumber
          };
          flashcards.push(card);
        }
        currentHeader = {
          text: line,
          lineNumber: i + 1
        };
        currentContent = [];
        skipNextParagraph = false;
      } else if (skipNextParagraph) {
        if (line.trim() === "") {
          skipNextParagraph = false;
        }
      } else if (line.match(/^#{1,6}\s+/)) {
        if (currentHeader && currentContent.length > 0) {
          const card = {
            front: currentHeader.text.replace(
              new RegExp(`^#{${headerLevel}}\\s+`),
              ""
            ),
            back: currentContent.join("\n").trim(),
            type: "header-paragraph",
            lineNumber: currentHeader.lineNumber
          };
          flashcards.push(card);
        }
        currentHeader = null;
        currentContent = [];
      } else if (currentHeader) {
        if (line.trim() === "" && currentContent.length === 0) {
          continue;
        }
        currentContent.push(line);
      }
    }
    if (currentHeader && currentContent.length > 0) {
      const card = {
        front: currentHeader.text.replace(
          new RegExp(`^#{${headerLevel}}\\s+`),
          ""
        ),
        back: currentContent.join("\n").trim(),
        type: "header-paragraph",
        lineNumber: currentHeader.lineNumber
      };
      flashcards.push(card);
    }
    return flashcards;
  }
  /**
   * Sync flashcards for a specific deck (file)
   */
  async syncFlashcardsForDeck(filePath) {
    this.debugLog(`Syncing flashcards for deck: ${filePath}`);
    const deck = await this.db.getDeckByFilepath(filePath);
    if (!deck) {
      this.debugLog(`No deck found for filepath: ${filePath}`);
      return;
    }
    this.debugLog(
      `Found deck ID: ${deck.id}, name: ${deck.name}, filepath: ${deck.filepath}`
    );
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const existingFlashcards = await this.db.getFlashcardsByDeck(deck.id);
    this.debugLog(
      `Found ${existingFlashcards.length} existing flashcards for deck ${deck.name}`
    );
    const existingById = /* @__PURE__ */ new Map();
    existingFlashcards.forEach((card) => {
      existingById.set(card.id, card);
      this.debugLog(`Existing card ID: ${card.id}, Front: "${card.front}"`);
    });
    const processedIds = /* @__PURE__ */ new Set();
    const parsedCards = await this.parseFlashcardsFromFile(file);
    this.debugLog(`Parsed ${parsedCards.length} flashcards from ${filePath}`);
    for (const parsed of parsedCards) {
      const flashcardId = this.generateFlashcardId(parsed.front, deck.id);
      const contentHash = this.generateContentHash(parsed.back);
      const existingCard = existingById.get(flashcardId);
      this.debugLog(
        `Processing flashcard: "${parsed.front.substring(0, 50)}..."`
      );
      this.debugLog(
        `Generated ID: ${flashcardId} (from front: "${parsed.front.substring(0, 30)}..." + deck: ${deck.id})`
      );
      this.debugLog(`Content hash: ${contentHash}`);
      this.debugLog(`Existing card found:`, existingCard ? "YES" : "NO");
      if (existingCard) {
        this.debugLog(
          `Existing card - ID: ${existingCard.id}, Front: "${existingCard.front.substring(0, 30)}...", Hash: ${existingCard.contentHash}`
        );
      }
      processedIds.add(flashcardId);
      if (existingCard) {
        if (existingCard.contentHash !== contentHash) {
          this.debugLog(
            `Content changed, updating flashcard: ${parsed.front.substring(0, 30)}...`
          );
          await this.db.updateFlashcard(existingCard.id, {
            front: parsed.front,
            back: parsed.back,
            type: parsed.type,
            contentHash
          });
        } else {
          this.debugLog(
            `No content change, skipping update: ${parsed.front.substring(0, 30)}...`
          );
        }
      } else {
        const flashcard = {
          id: flashcardId,
          deckId: deck.id,
          front: parsed.front,
          back: parsed.back,
          type: parsed.type,
          sourceFile: file.path,
          lineNumber: parsed.lineNumber,
          contentHash,
          state: "new",
          dueDate: (/* @__PURE__ */ new Date()).toISOString(),
          interval: 0,
          repetitions: 0,
          easeFactor: 5,
          // FSRS initial difficulty
          stability: 2.5,
          // FSRS initial stability
          lapses: 0,
          lastReviewed: null
        };
        this.debugLog(`Creating new flashcard: ${flashcard.front}`);
        await this.db.createFlashcard(flashcard);
      }
    }
    for (const [flashcardId, existingCard] of existingById) {
      if (!processedIds.has(flashcardId)) {
        this.debugLog(`Deleting flashcard: ${existingCard.front}`);
        await this.db.deleteFlashcard(existingCard.id);
      }
    }
    this.debugLog(`Flashcard sync completed for ${filePath}`);
  }
  /**
   * Sync flashcards for a specific deck by name (file path)
   */
  async syncFlashcardsForDeckByName(deckName) {
    await this.syncFlashcardsForDeck(deckName);
  }
  /**
   * Create deck for a single file without running full sync
   */
  async createDeckForFile(filePath, tag) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const deckName = file.basename;
    const existingDeck = await this.db.getDeckByFilepath(filePath);
    if (!existingDeck) {
      const deck = {
        id: this.generateDeckId(filePath),
        name: deckName,
        filepath: filePath,
        tag,
        lastReviewed: null,
        config: DEFAULT_DECK_CONFIG
      };
      this.debugLog(
        `Creating new deck: "${deckName}" with ID: ${deck.id}, tag: ${tag}, filepath: ${filePath}`
      );
      await this.db.createDeck(deck);
    }
  }
  /**
   * Generate content hash for flashcard back content (front is used for ID)
   */
  generateContentHash(back) {
    let hash = 0;
    for (let i = 0; i < back.length; i++) {
      const char = back.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  /**
   * Extract deck name from files (use the first file's name)
   */
  extractDeckNameFromFiles(files) {
    if (files.length === 0) {
      return "General";
    }
    const firstFile = files[0];
    return firstFile.basename;
  }
  /**
   * Extract deck name from tag (legacy method for compatibility)
   */
  extractDeckName(tag) {
    let name = tag.replace("#flashcards", "");
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    if (!name) {
      return "General";
    }
    const parts = name.split("/");
    return parts.map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(" - ");
  }
  /**
   * Generate deterministic deck ID based on filepath
   */
  generateDeckId(filepath) {
    if (filepath) {
      let hash = 0;
      for (let i = 0; i < filepath.length; i++) {
        const char = filepath.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return `deck_${Math.abs(hash).toString(36)}`;
    }
    return `deck_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Generate unique flashcard ID using hash of front text and deck ID
   */
  generateFlashcardId(frontText, deckId) {
    const combined = `${deckId}:${frontText}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
      const char = combined.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return `card_${Math.abs(hash).toString(36)}`;
  }
};

// src/algorithm/fsrs.ts
var FSRS = class {
  constructor(params) {
    this.params = {
      w: [
        0.4072,
        1.1829,
        3.1262,
        15.4722,
        7.2102,
        0.5316,
        1.0651,
        0.0234,
        1.616,
        0.1544,
        1.0824,
        1.9813,
        0.0953,
        0.2975,
        2.2042,
        0.2407,
        2.9466
      ],
      requestRetention: 0.9,
      maximumInterval: 60,
      // 100 years
      easyBonus: 1.3,
      hardInterval: 1.2,
      ...params
    };
  }
  /**
   * Update FSRS parameters
   */
  updateParameters(params) {
    this.params = { ...this.params, ...params };
  }
  /**
   * Calculate the next scheduling info for a flashcard based on review difficulty
   */
  getSchedulingInfo(card) {
    const fsrsCard = this.flashcardToFSRS(card);
    const now = /* @__PURE__ */ new Date();
    return {
      again: this.calculateScheduleForRating(fsrsCard, 1, now),
      hard: this.calculateScheduleForRating(fsrsCard, 2, now),
      good: this.calculateScheduleForRating(fsrsCard, 3, now),
      easy: this.calculateScheduleForRating(fsrsCard, 4, now)
    };
  }
  /**
   * Update a flashcard based on the selected difficulty
   */
  updateCard(card, difficulty) {
    const rating = this.difficultyToRating(difficulty);
    const fsrsCard = this.flashcardToFSRS(card);
    const now = /* @__PURE__ */ new Date();
    const schedule = this.calculateScheduleForRating(fsrsCard, rating, now);
    return {
      ...card,
      state: schedule.state,
      dueDate: schedule.dueDate,
      interval: schedule.interval,
      easeFactor: schedule.difficulty,
      // Store FSRS difficulty in easeFactor field
      repetitions: schedule.repetitions,
      modified: now.toISOString()
    };
  }
  calculateScheduleForRating(card, rating, now) {
    let newCard;
    if (card.state === "New") {
      newCard = this.initDS(card);
      newCard.elapsedDays = 0;
      newCard.scheduledDays = 0;
      newCard.reps = 1;
      newCard.lapses = rating === 1 ? 1 : 0;
      newCard.state = "Learning";
      const minuteInterval = this.getNewCardInterval(rating);
      return this.createSchedulingCard(
        now,
        minuteInterval,
        newCard,
        "learning"
      );
    } else if (card.state === "Learning" || card.state === "Relearning") {
      newCard = { ...card };
      newCard.reps += 1;
      if (rating === 1) {
        newCard.lapses += 1;
        newCard.state = "Learning";
        const minuteInterval = 1;
        return this.createSchedulingCard(
          now,
          minuteInterval,
          newCard,
          "learning"
        );
      } else if (rating === 2) {
        newCard.state = "Learning";
        const minuteInterval = Math.max(
          6,
          Math.round(card.scheduledDays * 1440 * 1.2)
        );
        return this.createSchedulingCard(
          now,
          minuteInterval,
          newCard,
          "learning"
        );
      } else if (rating === 3) {
        if (card.scheduledDays * 1440 < 1440) {
          newCard.state = "Learning";
          const minuteInterval = Math.min(
            1440,
            Math.round(card.scheduledDays * 1440 * 2.5)
          );
          const finalState = minuteInterval >= 1440 ? "review" : "learning";
          return this.createSchedulingCard(
            now,
            minuteInterval,
            newCard,
            finalState
          );
        } else {
          newCard.state = "Review";
          newCard.stability = this.initStability(3);
          newCard.difficulty = this.initDifficulty(3);
        }
      } else {
        newCard.state = "Review";
        newCard.stability = this.initStability(4);
        newCard.difficulty = this.initDifficulty(4);
      }
    } else {
      newCard = { ...card };
      newCard.elapsedDays = this.getElapsedDays(card.lastReview, now);
      newCard.reps += 1;
      if (rating === 1) {
        newCard.lapses += 1;
        newCard.state = "Learning";
        const minuteInterval = 1;
        return this.createSchedulingCard(
          now,
          minuteInterval,
          newCard,
          "learning"
        );
      }
      const retrievability = this.forgettingCurve(
        newCard.elapsedDays,
        newCard.stability
      );
      newCard.difficulty = this.nextDifficulty(newCard.difficulty, rating);
      newCard.stability = this.nextStability(
        newCard.difficulty,
        newCard.stability,
        retrievability,
        rating
      );
      newCard.state = "Review";
    }
    const intervalDays = this.nextInterval(newCard.stability);
    newCard.scheduledDays = intervalDays;
    newCard.lastReview = now;
    const intervalMinutes = Math.round(intervalDays * 1440);
    return this.createSchedulingCard(
      now,
      intervalMinutes,
      newCard,
      this.fsrsStateToFlashcardState(newCard.state)
    );
  }
  getNewCardInterval(rating) {
    switch (rating) {
      case 1:
        return 1;
      case 2:
        return 6;
      case 3:
        return 10;
      case 4:
        return 4 * 1440;
      default:
        return 10;
    }
  }
  createSchedulingCard(now, intervalMinutes, card, state) {
    const dueDate = new Date(now.getTime() + intervalMinutes * 60 * 1e3);
    return {
      dueDate: dueDate.toISOString(),
      interval: intervalMinutes,
      easeFactor: Number(card.difficulty.toFixed(2)),
      repetitions: card.reps,
      stability: Number(card.stability.toFixed(2)),
      difficulty: Number(card.difficulty.toFixed(2)),
      state
    };
  }
  initDS(card) {
    return {
      ...card,
      stability: 0,
      difficulty: 0,
      elapsedDays: 0,
      scheduledDays: 0,
      reps: 0,
      lapses: 0,
      state: "New",
      lastReview: /* @__PURE__ */ new Date()
    };
  }
  initStability(rating) {
    return Math.max(this.params.w[rating - 1], 0.1);
  }
  initDifficulty(rating) {
    return Math.min(
      Math.max(this.params.w[4] - this.params.w[5] * (rating - 3), 1),
      10
    );
  }
  forgettingCurve(elapsedDays, stability) {
    return Math.pow(1 + elapsedDays / (9 * stability), -1);
  }
  nextDifficulty(difficulty, rating) {
    const nextD = difficulty - this.params.w[6] * (rating - 3);
    return Math.min(
      Math.max(this.meanReversion(this.params.w[4], nextD), 1),
      10
    );
  }
  meanReversion(init2, current) {
    return this.params.w[7] * init2 + (1 - this.params.w[7]) * current;
  }
  nextStability(difficulty, stability, retrievability, rating) {
    const hardPenalty = rating === 2 ? this.params.w[15] : 1;
    const easyBonus = rating === 4 ? this.params.w[16] : 1;
    return stability * (1 + Math.exp(this.params.w[8]) * (11 - difficulty) * Math.pow(stability, -this.params.w[9]) * (Math.exp((1 - retrievability) * this.params.w[10]) - 1) * hardPenalty * easyBonus);
  }
  nextInterval(stability) {
    const interval = stability * (Math.log(this.params.requestRetention) / Math.log(0.9));
    return Math.min(
      Math.max(Math.round(interval), 1),
      this.params.maximumInterval
    );
  }
  getElapsedDays(lastReview, now) {
    return Math.max(
      0,
      (now.getTime() - lastReview.getTime()) / (1e3 * 60 * 60 * 24)
    );
  }
  flashcardToFSRS(card) {
    const lastReview = card.modified ? new Date(card.modified) : /* @__PURE__ */ new Date();
    const elapsedDays = this.getElapsedDays(lastReview, /* @__PURE__ */ new Date());
    return {
      stability: card.easeFactor || 2.5,
      // Use easeFactor as stability storage
      difficulty: card.easeFactor || 5,
      // Default difficulty
      elapsedDays,
      scheduledDays: card.interval / 1440,
      // Convert minutes to days
      reps: card.repetitions,
      lapses: 0,
      // We don't track lapses in current model
      state: this.flashcardStateToFSRSState(card.state),
      lastReview
    };
  }
  flashcardStateToFSRSState(state) {
    switch (state) {
      case "new":
        return "New";
      case "learning":
        return "Learning";
      case "review":
        return "Review";
      default:
        return "New";
    }
  }
  fsrsStateToFlashcardState(state) {
    switch (state) {
      case "New":
        return "new";
      case "Learning":
      case "Relearning":
        return "learning";
      case "Review":
        return "review";
      default:
        return "new";
    }
  }
  difficultyToRating(difficulty) {
    switch (difficulty) {
      case "again":
        return 1;
      case "hard":
        return 2;
      case "good":
        return 3;
      case "easy":
        return 4;
      default:
        return 3;
    }
  }
  /**
   * Get display text for intervals
   */
  static getIntervalDisplay(minutes) {
    if (minutes < 60) {
      return `${Math.round(minutes)}m`;
    } else if (minutes < 1440) {
      return `${Math.round(minutes / 60)}h`;
    } else {
      const days = Math.round(minutes / 1440);
      if (days < 30) {
        return `${days}d`;
      } else if (days < 365) {
        return `${Math.round(days / 30)}mo`;
      } else {
        return `${(days / 365).toFixed(1)}y`;
      }
    }
  }
};

// src/main.ts
init_settings();

// src/components/SettingsTab.ts
var import_obsidian2 = require("obsidian");
var FlashcardsSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flashcards Plugin Settings" });
    this.addFSRSSettings(containerEl);
    this.addDatabaseSettings(containerEl);
    this.addReviewSettings(containerEl);
    this.addParsingSettings(containerEl);
    this.addUISettings(containerEl);
    this.addDebugSettings(containerEl);
  }
  addFSRSSettings(containerEl) {
    containerEl.createEl("h3", { text: "FSRS Algorithm" });
    containerEl.createEl("p", {
      text: "Configure the Free Spaced Repetition Scheduler algorithm parameters.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Target Retention").setDesc("Desired retention rate for flashcards (0.8 = 80%)").addSlider(
      (slider) => slider.setLimits(0.7, 0.98, 0.01).setValue(this.plugin.settings.fsrs.requestRetention).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fsrs.requestRetention = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Maximum Interval").setDesc("Maximum number of days between reviews").addText(
      (text2) => text2.setPlaceholder("36500").setValue(this.plugin.settings.fsrs.maximumInterval.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.fsrs.maximumInterval = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Easy Bonus").setDesc("Multiplier for easy cards (higher = longer intervals)").addSlider(
      (slider) => slider.setLimits(1.1, 2, 0.1).setValue(this.plugin.settings.fsrs.easyBonus).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fsrs.easyBonus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Hard Interval").setDesc("Multiplier for hard cards in learning phase").addSlider(
      (slider) => slider.setLimits(1, 2, 0.1).setValue(this.plugin.settings.fsrs.hardInterval).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fsrs.hardInterval = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset FSRS parameters to default values").addButton(
      (button) => button.setButtonText("Reset").setWarning().onClick(async () => {
        const defaultSettings = (await Promise.resolve().then(() => (init_settings(), settings_exports))).DEFAULT_SETTINGS;
        this.plugin.settings.fsrs = { ...defaultSettings.fsrs };
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  addDatabaseSettings(containerEl) {
    containerEl.createEl("h3", { text: "Database" });
    new import_obsidian2.Setting(containerEl).setName("Database Path").setDesc("Custom path for the database file (leave empty for default)").addText(
      (text2) => text2.setPlaceholder(
        ".obsidian/plugins/obsidian-flashcards-plugin/flashcards.db"
      ).setValue(this.plugin.settings.database.customPath || "").onChange(async (value) => {
        this.plugin.settings.database.customPath = value.trim() || void 0;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Auto Backup").setDesc("Automatically backup the database").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.database.autoBackup).onChange(async (value) => {
        this.plugin.settings.database.autoBackup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Backup Interval").setDesc("Number of days between automatic backups").addText(
      (text2) => text2.setPlaceholder("7").setValue(this.plugin.settings.database.backupInterval.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.database.backupInterval = num;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addReviewSettings(containerEl) {
    containerEl.createEl("h3", { text: "Review Sessions" });
    new import_obsidian2.Setting(containerEl).setName("Show Progress").setDesc("Display progress bar during review sessions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.review.showProgress).onChange(async (value) => {
        this.plugin.settings.review.showProgress = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Keyboard Shortcuts").setDesc("Enable keyboard shortcuts in review modal (1-4 for difficulty)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.review.enableKeyboardShortcuts).onChange(async (value) => {
        this.plugin.settings.review.enableKeyboardShortcuts = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Session Limit").setDesc("Limit the number of cards per review session").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.review.enableSessionLimit).onChange(async (value) => {
        this.plugin.settings.review.enableSessionLimit = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Session Goal").setDesc("Target number of cards per review session").addText(
      (text2) => text2.setPlaceholder("20").setValue(this.plugin.settings.review.sessionGoal.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.review.sessionGoal = num;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addParsingSettings(containerEl) {
    containerEl.createEl("h3", { text: "Parsing Settings" });
    containerEl.createEl("p", {
      text: "Configure how flashcards are parsed from your notes.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Header Level for Flashcards").setDesc(
      "Which header level to use for header-paragraph flashcards (H1 = 1, H2 = 2, etc.)"
    ).addDropdown(
      (dropdown) => dropdown.addOption("1", "H1 (#)").addOption("2", "H2 (##)").addOption("3", "H3 (###)").addOption("4", "H4 (####)").addOption("5", "H5 (#####)").addOption("6", "H6 (######)").setValue(this.plugin.settings.parsing.headerLevel.toString()).onChange(async (value) => {
        this.plugin.settings.parsing.headerLevel = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
  }
  addUISettings(containerEl) {
    containerEl.createEl("h3", { text: "User Interface" });
    const intervalSetting = new import_obsidian2.Setting(containerEl).setName("Background Refresh Interval").setDesc("How often to refresh deck stats in the side panel (in seconds)").addText(
      (text2) => text2.setPlaceholder("5").setValue(
        this.plugin.settings.ui.backgroundRefreshInterval.toString()
      ).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 1 && num <= 60) {
          this.plugin.settings.ui.backgroundRefreshInterval = num;
          await this.plugin.saveSettings();
          if (this.plugin.view) {
            this.plugin.view.restartBackgroundRefresh();
          }
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Enable Background Refresh").setDesc("Automatically refresh deck stats in the side panel").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ui.enableBackgroundRefresh).onChange(async (value) => {
        this.plugin.settings.ui.enableBackgroundRefresh = value;
        await this.plugin.saveSettings();
        intervalSetting.setDisabled(!value);
        if (this.plugin.view) {
          if (value) {
            this.plugin.view.startBackgroundRefresh();
          } else {
            this.plugin.view.stopBackgroundRefresh();
          }
        }
      })
    );
    intervalSetting.setDisabled(
      !this.plugin.settings.ui.enableBackgroundRefresh
    );
  }
  addDebugSettings(containerEl) {
    containerEl.createEl("h3", { text: "Debug" });
    containerEl.createEl("p", {
      text: "Debug settings for troubleshooting and development.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Enable Debug Logging").setDesc(
      "Show detailed logging in the console for sync operations and flashcard processing"
    ).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue(((_a = this.plugin.settings.debug) == null ? void 0 : _a.enableLogging) || false).onChange(async (value) => {
          if (!this.plugin.settings.debug) {
            this.plugin.settings.debug = { enableLogging: false };
          }
          this.plugin.settings.debug.enableLogging = value;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/components/ReviewHeatmap.svelte
function add_css(target) {
  append_styles(target, "svelte-7nm5s5", ".heatmap-container.svelte-7nm5s5.svelte-7nm5s5{padding:16px;border-top:1px solid var(--background-modifier-border);background:var(--background-primary);display:flex;flex-direction:column;align-items:stretch}.heatmap-header.svelte-7nm5s5.svelte-7nm5s5{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;width:100%}.header-left.svelte-7nm5s5.svelte-7nm5s5{display:flex;flex-direction:column;align-items:flex-start}.year-navigation.svelte-7nm5s5.svelte-7nm5s5{display:flex;align-items:center;gap:8px}.nav-button.svelte-7nm5s5.svelte-7nm5s5{background:none;border:1px solid var(--background-modifier-border);border-radius:4px;padding:4px;cursor:pointer;color:var(--text-muted);transition:all 0.2s ease;display:flex;align-items:center;justify-content:center;width:24px;height:24px}.nav-button.svelte-7nm5s5.svelte-7nm5s5:hover{background:var(--background-modifier-hover);color:var(--text-normal);border-color:var(--text-muted)}.current-year.svelte-7nm5s5.svelte-7nm5s5{font-size:14px;font-weight:600;color:var(--text-normal);min-width:40px;text-align:center}.heatmap-header.svelte-7nm5s5 h4.svelte-7nm5s5{margin:0;font-size:14px;font-weight:600;color:var(--text-normal)}.total-reviews.svelte-7nm5s5.svelte-7nm5s5{font-size:12px;color:var(--text-muted)}.loading.svelte-7nm5s5.svelte-7nm5s5{text-align:center;padding:20px;color:var(--text-muted);font-size:12px}.heatmap.svelte-7nm5s5.svelte-7nm5s5{position:relative;margin-top:12px;overflow-x:auto;overflow-y:hidden;max-width:100%;padding-bottom:8px;display:flex;justify-content:center}.heatmap-content.svelte-7nm5s5.svelte-7nm5s5{position:relative;min-width:fit-content;width:max-content}.month-labels.svelte-7nm5s5.svelte-7nm5s5{position:relative;height:12px;margin-bottom:2px;margin-left:18px}.month-label.svelte-7nm5s5.svelte-7nm5s5{position:absolute;font-size:9px;color:var(--text-muted)}.day-labels.svelte-7nm5s5.svelte-7nm5s5{position:absolute;left:-18px;top:16px}.day-label.svelte-7nm5s5.svelte-7nm5s5{position:absolute;font-size:9px;color:var(--text-muted);width:16px;text-align:right}.heatmap-grid.svelte-7nm5s5.svelte-7nm5s5{display:flex;gap:2px;padding-right:16px}.week.svelte-7nm5s5.svelte-7nm5s5{display:flex;flex-direction:column;gap:2px}.day.svelte-7nm5s5.svelte-7nm5s5{width:10px;height:10px;border-radius:2px;cursor:pointer;transition:all 0.1s ease;flex-shrink:0}.day.svelte-7nm5s5.svelte-7nm5s5:hover{transform:scale(1.3);outline:1px solid var(--text-muted);z-index:10;position:relative}.day.today.svelte-7nm5s5.svelte-7nm5s5{outline:2px solid var(--interactive-accent);outline-offset:1px}.day.today.svelte-7nm5s5.svelte-7nm5s5:hover{outline:2px solid var(--interactive-accent);outline-offset:1px}.intensity-0.svelte-7nm5s5.svelte-7nm5s5{background-color:var(--background-modifier-border)}.intensity-1.svelte-7nm5s5.svelte-7nm5s5{background-color:#0e4429}.intensity-2.svelte-7nm5s5.svelte-7nm5s5{background-color:#006d32}.intensity-3.svelte-7nm5s5.svelte-7nm5s5{background-color:#26a641}.intensity-4.svelte-7nm5s5.svelte-7nm5s5{background-color:#39d353}.legend.svelte-7nm5s5.svelte-7nm5s5{display:flex;align-items:center;justify-content:center;gap:3px;margin-top:6px}.legend-label.svelte-7nm5s5.svelte-7nm5s5{font-size:8px;color:var(--text-muted)}.legend-colors.svelte-7nm5s5.svelte-7nm5s5{display:flex;gap:2px}.legend-square.svelte-7nm5s5.svelte-7nm5s5{width:10px;height:10px;border-radius:2px}.day.outside-year.svelte-7nm5s5.svelte-7nm5s5{opacity:0.3;pointer-events:none}.heatmap.svelte-7nm5s5.svelte-7nm5s5::-webkit-scrollbar{height:8px}.heatmap.svelte-7nm5s5.svelte-7nm5s5::-webkit-scrollbar-track{background:var(--background-primary);border-radius:4px}.heatmap.svelte-7nm5s5.svelte-7nm5s5::-webkit-scrollbar-thumb{background:var(--background-modifier-border);border-radius:4px}.heatmap.svelte-7nm5s5.svelte-7nm5s5::-webkit-scrollbar-thumb:hover{background:var(--text-muted)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  const constants_0 = new Date(
    /*day*/
    child_ctx[23].date
  ).getFullYear();
  child_ctx[24] = constants_0;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i].month;
  child_ctx[28] = list[i].offset;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let span;
  let t0_value = Array.from(
    /*reviewCounts*/
    ctx[0].values()
  ).reduce(func, 0) + "";
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" reviews");
      attr(span, "class", "total-reviews svelte-7nm5s5");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*reviewCounts*/
      1 && t0_value !== (t0_value = Array.from(
        /*reviewCounts*/
        ctx2[0].values()
      ).reduce(func, 0) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block(ctx) {
  let div4;
  let div3;
  let div0;
  let t0;
  let div1;
  let t8;
  let div2;
  let t9;
  let div11;
  let each_value_2 = (
    /*getMonthLabels*/
    ctx[6]()
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = (
    /*weeks*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<span class="day-label svelte-7nm5s5" style="top: 0px">S</span> 
                    <span class="day-label svelte-7nm5s5" style="top: 18px">T</span> 
                    <span class="day-label svelte-7nm5s5" style="top: 36px">T</span> 
                    <span class="day-label svelte-7nm5s5" style="top: 54px">S</span>`;
      t8 = space();
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t9 = space();
      div11 = element("div");
      div11.innerHTML = `<span class="legend-label svelte-7nm5s5">Less</span> 
            <div class="legend-colors svelte-7nm5s5"><div class="legend-square intensity-0 svelte-7nm5s5"></div> 
                <div class="legend-square intensity-1 svelte-7nm5s5"></div> 
                <div class="legend-square intensity-2 svelte-7nm5s5"></div> 
                <div class="legend-square intensity-3 svelte-7nm5s5"></div> 
                <div class="legend-square intensity-4 svelte-7nm5s5"></div></div> 
            <span class="legend-label svelte-7nm5s5">More</span>`;
      attr(div0, "class", "month-labels svelte-7nm5s5");
      attr(div1, "class", "day-labels svelte-7nm5s5");
      attr(div2, "class", "heatmap-grid svelte-7nm5s5");
      attr(div3, "class", "heatmap-content svelte-7nm5s5");
      attr(div4, "class", "heatmap svelte-7nm5s5");
      attr(div11, "class", "legend svelte-7nm5s5");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      append(div3, t0);
      append(div3, div1);
      append(div3, t8);
      append(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      insert(target, t9, anchor);
      insert(target, div11, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*getMonthLabels*/
      64) {
        each_value_2 = /*getMonthLabels*/
        ctx2[6]();
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty & /*weeks, getIntensityClass, formatDate, isToday, Date, currentYear*/
      50) {
        each_value = /*weeks*/
        ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(div11);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Loading...";
      attr(div, "class", "loading svelte-7nm5s5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_2(ctx) {
  let span;
  let t_value = (
    /*month*/
    ctx[27] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "month-label svelte-7nm5s5");
      set_style(
        span,
        "left",
        /*offset*/
        ctx[28] + "px"
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let div_class_value;
  let div_title_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "day " + /*getIntensityClass*/
      ctx[5](
        /*day*/
        ctx[23].count
      ) + " svelte-7nm5s5");
      attr(div, "title", div_title_value = /*day*/
      ctx[23].count + " reviews on " + formatDate(
        /*day*/
        ctx[23].date
      ));
      toggle_class(div, "today", isToday(
        /*day*/
        ctx[23].date
      ));
      toggle_class(
        div,
        "outside-year",
        /*dayYear*/
        ctx[24] !== /*currentYear*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*weeks*/
      2 && div_class_value !== (div_class_value = "day " + /*getIntensityClass*/
      ctx2[5](
        /*day*/
        ctx2[23].count
      ) + " svelte-7nm5s5")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*weeks*/
      2 && div_title_value !== (div_title_value = /*day*/
      ctx2[23].count + " reviews on " + formatDate(
        /*day*/
        ctx2[23].date
      ))) {
        attr(div, "title", div_title_value);
      }
      if (dirty & /*weeks, isToday, weeks*/
      2) {
        toggle_class(div, "today", isToday(
          /*day*/
          ctx2[23].date
        ));
      }
      if (dirty & /*weeks, Date, weeks, currentYear*/
      18) {
        toggle_class(
          div,
          "outside-year",
          /*dayYear*/
          ctx2[24] !== /*currentYear*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t;
  let each_value_1 = (
    /*week*/
    ctx[20]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "week svelte-7nm5s5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*getIntensityClass, weeks, formatDate, isToday, Date, currentYear*/
      50) {
        each_value_1 = /*week*/
        ctx2[20];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div3;
  let div2;
  let div0;
  let h4;
  let t1;
  let t2;
  let div1;
  let button0;
  let t3;
  let span;
  let t4;
  let t5;
  let button1;
  let t6;
  let mounted;
  let dispose;
  let if_block0 = !/*isLoading*/
  ctx[2] && create_if_block_1(ctx);
  function select_block_type(ctx2, dirty) {
    if (
      /*isLoading*/
      ctx2[2]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h4 = element("h4");
      h4.textContent = "Review Activity";
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div1 = element("div");
      button0 = element("button");
      button0.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>`;
      t3 = space();
      span = element("span");
      t4 = text(
        /*currentYear*/
        ctx[4]
      );
      t5 = space();
      button1 = element("button");
      button1.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></svg>`;
      t6 = space();
      if_block1.c();
      attr(h4, "class", "svelte-7nm5s5");
      attr(div0, "class", "header-left svelte-7nm5s5");
      attr(button0, "class", "nav-button svelte-7nm5s5");
      attr(span, "class", "current-year svelte-7nm5s5");
      attr(button1, "class", "nav-button svelte-7nm5s5");
      attr(div1, "class", "year-navigation svelte-7nm5s5");
      attr(div2, "class", "heatmap-header svelte-7nm5s5");
      attr(div3, "class", "heatmap-container svelte-7nm5s5");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h4);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t3);
      append(div1, span);
      append(span, t4);
      append(div1, t5);
      append(div1, button1);
      append(div3, t6);
      if_block1.m(div3, null);
      ctx[14](div3);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*isLoading*/
      ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*currentYear*/
      16)
        set_data(
          t4,
          /*currentYear*/
          ctx2[4]
        );
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div3, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function formatDate(dateStr) {
  const date = new Date(dateStr);
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
}
function isToday(dateStr) {
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  return dateStr === today;
}
function calculateMaxWeeks(width) {
  if (width === 0)
    return 20;
  const availableWidth = width - 50;
  const weekWidth = 12;
  const calculatedWeeks = Math.floor(availableWidth / weekWidth);
  return Math.min(Math.max(calculatedWeeks, 8), 52);
}
var func = (sum, count) => sum + count;
function instance($$self, $$props, $$invalidate) {
  let { getReviewCounts } = $$props;
  let reviewCounts = /* @__PURE__ */ new Map();
  let days = [];
  let weeks = [];
  let maxCount = 0;
  let isLoading = true;
  let containerElement;
  let maxWeeks = 52;
  let containerWidth = 0;
  let currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function generateDays() {
    const yearStart = new Date(currentYear, 0, 1);
    const yearEnd = new Date(currentYear, 11, 31);
    const startDate = new Date(yearStart);
    const startDayOfWeek = startDate.getDay();
    startDate.setDate(startDate.getDate() - startDayOfWeek);
    const endDate = new Date(yearEnd);
    const endDayOfWeek = endDate.getDay();
    endDate.setDate(endDate.getDate() + (6 - endDayOfWeek));
    const daysArray = [];
    const current = new Date(startDate);
    while (current <= endDate) {
      const dateStr = current.toISOString().split("T")[0];
      const currentDateYear = current.getFullYear();
      if (currentDateYear === currentYear) {
        const count = reviewCounts.get(dateStr) || 0;
        daysArray.push({
          date: dateStr,
          count,
          dayOfWeek: current.getDay()
        });
        if (count > maxCount) {
          maxCount = count;
        }
      } else {
        daysArray.push({
          date: dateStr,
          count: 0,
          dayOfWeek: current.getDay()
        });
      }
      current.setDate(current.getDate() + 1);
    }
    days = daysArray;
    $$invalidate(1, weeks = []);
    for (let i = 0; i < days.length; i += 7) {
      weeks.push(days.slice(i, i + 7));
    }
  }
  function getIntensityClass(count) {
    if (count === 0)
      return "intensity-0";
    const intensity = Math.min(Math.ceil(count / maxCount * 4), 4);
    return `intensity-${intensity}`;
  }
  function getMonthLabels() {
    if (weeks.length === 0)
      return [];
    const labels = [];
    let currentMonth = -1;
    weeks.forEach((week, weekIndex) => {
      const firstDay = week[0];
      if (firstDay) {
        const date = new Date(firstDay.date);
        const month = date.getMonth();
        const year = date.getFullYear();
        if (year === currentYear && month !== currentMonth) {
          currentMonth = month;
          labels.push({
            month: months[month],
            offset: weekIndex * 12
            // 12px per week (10px square + 2px gap)
          });
        }
      }
    });
    return labels;
  }
  function updateContainerWidth() {
    if (containerElement) {
      $$invalidate(11, containerWidth = containerElement.clientWidth);
    }
  }
  function navigateYear(direction) {
    if (direction === "prev") {
      $$invalidate(4, currentYear--, currentYear);
    } else {
      $$invalidate(4, currentYear++, currentYear);
    }
    refresh();
  }
  function refresh() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(2, isLoading = true);
      try {
        $$invalidate(0, reviewCounts = yield getReviewCounts(366));
        maxCount = 0;
        generateDays();
      } catch (error) {
        console.error("Failed to load review counts:", error);
      } finally {
        $$invalidate(2, isLoading = false);
      }
    });
  }
  onMount(() => {
    setTimeout(
      () => {
        updateContainerWidth();
        refresh();
      },
      100
    );
  });
  const click_handler = () => navigateYear("prev");
  const click_handler_1 = () => navigateYear("next");
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(3, containerElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("getReviewCounts" in $$props2)
      $$invalidate(8, getReviewCounts = $$props2.getReviewCounts);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*containerWidth, maxWeeks*/
    3072) {
      $:
        if (containerWidth > 0) {
          const newMaxWeeks = calculateMaxWeeks(containerWidth);
          if (newMaxWeeks !== maxWeeks) {
            $$invalidate(10, maxWeeks = newMaxWeeks);
            refresh();
          }
        }
    }
  };
  return [
    reviewCounts,
    weeks,
    isLoading,
    containerElement,
    currentYear,
    getIntensityClass,
    getMonthLabels,
    navigateYear,
    getReviewCounts,
    refresh,
    maxWeeks,
    containerWidth,
    click_handler,
    click_handler_1,
    div3_binding
  ];
}
var ReviewHeatmap = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { getReviewCounts: 8, refresh: 9 }, add_css);
  }
  get refresh() {
    return this.$$.ctx[9];
  }
};
var ReviewHeatmap_default = ReviewHeatmap;

// src/components/DeckConfigModal.ts
var import_obsidian3 = require("obsidian");

// src/components/DeckConfigUI.svelte
function add_css2(target) {
  append_styles(target, "svelte-xukw2q", '.deck-config-ui.svelte-xukw2q.svelte-xukw2q{padding:0}.deck-info-section.svelte-xukw2q.svelte-xukw2q{margin-bottom:24px;padding:16px;background:var(--background-secondary);border-radius:6px;border:1px solid var(--background-modifier-border)}.deck-info-section.svelte-xukw2q h3.svelte-xukw2q{margin:0 0 12px 0;font-size:1.1em;color:var(--text-normal);font-weight:600}.deck-info-list.svelte-xukw2q.svelte-xukw2q{margin:0;padding:0;list-style:none}.deck-info-list.svelte-xukw2q li.svelte-xukw2q{margin:0 0 8px 0;font-size:0.9em;color:var(--text-muted)}.deck-info-list.svelte-xukw2q li.svelte-xukw2q:last-child{margin-bottom:0}.deck-info-list.svelte-xukw2q strong.svelte-xukw2q{color:var(--text-normal)}.deck-settings-section.svelte-xukw2q.svelte-xukw2q{margin-bottom:24px}.deck-settings-section.svelte-xukw2q h3.svelte-xukw2q{margin:0 0 16px 0;font-size:1.1em;color:var(--text-normal);font-weight:600}.setting-item-description-global.svelte-xukw2q.svelte-xukw2q{font-size:0.8em;color:var(--text-muted);line-height:1.4;margin-bottom:20px;padding:12px;background:var(--background-secondary);border-radius:4px;border-left:3px solid var(--interactive-accent)}.setting-item.svelte-xukw2q.svelte-xukw2q{display:flex;align-items:flex-start;justify-content:space-between;margin-bottom:20px;padding:12px 0;border-bottom:1px solid var(--background-modifier-border)}.setting-item.svelte-xukw2q.svelte-xukw2q:last-child{border-bottom:none;margin-bottom:0}.setting-item.disabled.svelte-xukw2q.svelte-xukw2q{opacity:0.5}.setting-item-info.svelte-xukw2q.svelte-xukw2q{flex:1;margin-right:16px}.setting-item-name.svelte-xukw2q.svelte-xukw2q{font-weight:500;color:var(--text-normal);margin-bottom:4px;font-size:0.9em}.setting-item-description.svelte-xukw2q.svelte-xukw2q{font-size:0.8em;color:var(--text-muted);line-height:1.4}.setting-item-control.svelte-xukw2q.svelte-xukw2q{flex-shrink:0}.checkbox-container.svelte-xukw2q.svelte-xukw2q{position:relative;display:inline-block;cursor:pointer}.checkbox-input.svelte-xukw2q.svelte-xukw2q{position:absolute;opacity:0;cursor:pointer}.checkbox-slider.svelte-xukw2q.svelte-xukw2q{width:42px;height:24px;background:var(--background-modifier-border);border-radius:12px;position:relative;transition:background-color 0.2s ease}.checkbox-slider.svelte-xukw2q.svelte-xukw2q::before{content:"";position:absolute;width:18px;height:18px;border-radius:50%;background:white;top:3px;left:3px;transition:transform 0.2s ease}.checkbox-input.svelte-xukw2q:checked+.checkbox-slider.svelte-xukw2q{background:var(--interactive-accent)}.checkbox-input.svelte-xukw2q:checked+.checkbox-slider.svelte-xukw2q::before{transform:translateX(18px)}.session-limit-input.svelte-xukw2q.svelte-xukw2q{width:80px;padding:6px 8px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:0.9em}.session-limit-input.svelte-xukw2q.svelte-xukw2q:focus{outline:none;border-color:var(--interactive-accent);box-shadow:0 0 0 2px var(--interactive-accent-hover)}.session-limit-input.svelte-xukw2q.svelte-xukw2q:disabled{opacity:0.5;cursor:not-allowed;background:var(--background-modifier-border-hover)}.review-order-select.svelte-xukw2q.svelte-xukw2q{padding:6px 8px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:0.9em;min-width:140px}.review-order-select.svelte-xukw2q.svelte-xukw2q:focus{outline:none;border-color:var(--interactive-accent);box-shadow:0 0 0 2px var(--interactive-accent-hover)}.modal-footer.svelte-xukw2q.svelte-xukw2q{display:flex;align-items:center;justify-content:flex-end;gap:12px;margin-top:24px;padding-top:16px;border-top:1px solid var(--background-modifier-border)}.modal-footer.svelte-xukw2q button.svelte-xukw2q{padding:8px 16px;border-radius:4px;border:1px solid var(--background-modifier-border);background:var(--background-primary);color:var(--text-normal);cursor:pointer;font-size:0.9em;transition:all 0.2s ease}.modal-footer.svelte-xukw2q button.svelte-xukw2q:hover:not(:disabled){background:var(--background-modifier-hover)}.modal-footer.svelte-xukw2q button.svelte-xukw2q:disabled{opacity:0.5;cursor:not-allowed}.modal-footer.svelte-xukw2q button.mod-cta.svelte-xukw2q{background:var(--interactive-accent);color:var(--text-on-accent);border-color:var(--interactive-accent)}.modal-footer.svelte-xukw2q button.mod-cta.svelte-xukw2q:hover:not(:disabled){background:var(--interactive-accent-hover);border-color:var(--interactive-accent-hover)}.modal-footer.svelte-xukw2q button.svelte-xukw2q:focus{outline:2px solid var(--interactive-accent);outline-offset:2px}');
}
function create_fragment2(ctx) {
  let div31;
  let div0;
  let h30;
  let t1;
  let ul;
  let li0;
  let strong0;
  let t3;
  let t4_value = (
    /*deck*/
    ctx[0].name + ""
  );
  let t4;
  let t5;
  let li1;
  let strong1;
  let t7;
  let t8_value = (
    /*deck*/
    ctx[0].tag + ""
  );
  let t8;
  let t9;
  let li2;
  let strong2;
  let t11;
  let t12_value = (
    /*deck*/
    ctx[0].filepath + ""
  );
  let t12;
  let t13;
  let div29;
  let h31;
  let t15;
  let div1;
  let t17;
  let div7;
  let div4;
  let t21;
  let div6;
  let label0;
  let input0;
  let t22;
  let div5;
  let t23;
  let div12;
  let div10;
  let t27;
  let div11;
  let input1;
  let input1_disabled_value;
  let t28;
  let div18;
  let div15;
  let t32;
  let div17;
  let label1;
  let input2;
  let t33;
  let div16;
  let t34;
  let div23;
  let div21;
  let t38;
  let div22;
  let input3;
  let input3_disabled_value;
  let t39;
  let div28;
  let div26;
  let t43;
  let div27;
  let select;
  let option0;
  let option1;
  let t46;
  let div30;
  let button0;
  let t47_value = (
    /*saving*/
    ctx[6] ? "Saving..." : "Save"
  );
  let t47;
  let t48;
  let button1;
  let t49;
  let mounted;
  let dispose;
  return {
    c() {
      div31 = element("div");
      div0 = element("div");
      h30 = element("h3");
      h30.textContent = "Deck Information";
      t1 = space();
      ul = element("ul");
      li0 = element("li");
      strong0 = element("strong");
      strong0.textContent = "Name:";
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      strong1 = element("strong");
      strong1.textContent = "Tag:";
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      li2 = element("li");
      strong2 = element("strong");
      strong2.textContent = "File:";
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      div29 = element("div");
      h31 = element("h3");
      h31.textContent = "Daily Card Limits";
      t15 = space();
      div1 = element("div");
      div1.textContent = "Learning/relearning cards are always shown and not subject to these\n            limits.";
      t17 = space();
      div7 = element("div");
      div4 = element("div");
      div4.innerHTML = `<div class="setting-item-name svelte-xukw2q">Enable New Cards Limit</div> 
                <div class="setting-item-description svelte-xukw2q">Limit how many new cards (never seen before) can be shown
                    per day</div>`;
      t21 = space();
      div6 = element("div");
      label0 = element("label");
      input0 = element("input");
      t22 = space();
      div5 = element("div");
      t23 = space();
      div12 = element("div");
      div10 = element("div");
      div10.innerHTML = `<div class="setting-item-name svelte-xukw2q">New Cards per Day</div> 
                <div class="setting-item-description svelte-xukw2q">Maximum number of new cards to introduce per day</div>`;
      t27 = space();
      div11 = element("div");
      input1 = element("input");
      t28 = space();
      div18 = element("div");
      div15 = element("div");
      div15.innerHTML = `<div class="setting-item-name svelte-xukw2q">Enable Review Cards Limit</div> 
                <div class="setting-item-description svelte-xukw2q">Limit how many review cards (due for repetition) can be
                    shown per day</div>`;
      t32 = space();
      div17 = element("div");
      label1 = element("label");
      input2 = element("input");
      t33 = space();
      div16 = element("div");
      t34 = space();
      div23 = element("div");
      div21 = element("div");
      div21.innerHTML = `<div class="setting-item-name svelte-xukw2q">Review Cards per Day</div> 
                <div class="setting-item-description svelte-xukw2q">Maximum number of review cards to show per day</div>`;
      t38 = space();
      div22 = element("div");
      input3 = element("input");
      t39 = space();
      div28 = element("div");
      div26 = element("div");
      div26.innerHTML = `<div class="setting-item-name svelte-xukw2q">Review Order</div> 
                <div class="setting-item-description svelte-xukw2q">Order in which review cards are presented during study</div>`;
      t43 = space();
      div27 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = "Oldest due first";
      option1 = element("option");
      option1.textContent = "Random order";
      t46 = space();
      div30 = element("div");
      button0 = element("button");
      t47 = text(t47_value);
      t48 = space();
      button1 = element("button");
      t49 = text("Cancel");
      attr(h30, "class", "svelte-xukw2q");
      attr(strong0, "class", "svelte-xukw2q");
      attr(li0, "class", "svelte-xukw2q");
      attr(strong1, "class", "svelte-xukw2q");
      attr(li1, "class", "svelte-xukw2q");
      attr(strong2, "class", "svelte-xukw2q");
      attr(li2, "class", "svelte-xukw2q");
      attr(ul, "class", "deck-info-list svelte-xukw2q");
      attr(div0, "class", "deck-info-section svelte-xukw2q");
      attr(h31, "class", "svelte-xukw2q");
      attr(div1, "class", "setting-item-description-global svelte-xukw2q");
      attr(div4, "class", "setting-item-info svelte-xukw2q");
      attr(input0, "type", "checkbox");
      attr(input0, "class", "checkbox-input svelte-xukw2q");
      attr(div5, "class", "checkbox-slider svelte-xukw2q");
      attr(label0, "class", "checkbox-container svelte-xukw2q");
      attr(div6, "class", "setting-item-control svelte-xukw2q");
      attr(div7, "class", "setting-item svelte-xukw2q");
      attr(div10, "class", "setting-item-info svelte-xukw2q");
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "999");
      input1.disabled = input1_disabled_value = !/*enableNewCardsLimit*/
      ctx[3];
      attr(input1, "class", "session-limit-input svelte-xukw2q");
      attr(input1, "placeholder", "20");
      attr(div11, "class", "setting-item-control svelte-xukw2q");
      attr(div12, "class", "setting-item svelte-xukw2q");
      toggle_class(div12, "disabled", !/*enableNewCardsLimit*/
      ctx[3]);
      attr(div15, "class", "setting-item-info svelte-xukw2q");
      attr(input2, "type", "checkbox");
      attr(input2, "class", "checkbox-input svelte-xukw2q");
      attr(div16, "class", "checkbox-slider svelte-xukw2q");
      attr(label1, "class", "checkbox-container svelte-xukw2q");
      attr(div17, "class", "setting-item-control svelte-xukw2q");
      attr(div18, "class", "setting-item svelte-xukw2q");
      attr(div21, "class", "setting-item-info svelte-xukw2q");
      attr(input3, "type", "number");
      attr(input3, "min", "0");
      attr(input3, "max", "9999");
      input3.disabled = input3_disabled_value = !/*enableReviewCardsLimit*/
      ctx[4];
      attr(input3, "class", "session-limit-input svelte-xukw2q");
      attr(input3, "placeholder", "100");
      attr(div22, "class", "setting-item-control svelte-xukw2q");
      attr(div23, "class", "setting-item svelte-xukw2q");
      toggle_class(div23, "disabled", !/*enableReviewCardsLimit*/
      ctx[4]);
      attr(div26, "class", "setting-item-info svelte-xukw2q");
      option0.__value = "due-date";
      option0.value = option0.__value;
      option1.__value = "random";
      option1.value = option1.__value;
      attr(select, "class", "review-order-select svelte-xukw2q");
      if (
        /*reviewOrder*/
        ctx[5] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[15].call(select)
        ));
      attr(div27, "class", "setting-item-control svelte-xukw2q");
      attr(div28, "class", "setting-item svelte-xukw2q");
      attr(div29, "class", "deck-settings-section svelte-xukw2q");
      attr(button0, "class", "mod-cta svelte-xukw2q");
      button0.disabled = /*saving*/
      ctx[6];
      button1.disabled = /*saving*/
      ctx[6];
      attr(button1, "class", "svelte-xukw2q");
      attr(div30, "class", "modal-footer svelte-xukw2q");
      attr(div31, "class", "deck-config-ui svelte-xukw2q");
    },
    m(target, anchor) {
      insert(target, div31, anchor);
      append(div31, div0);
      append(div0, h30);
      append(div0, t1);
      append(div0, ul);
      append(ul, li0);
      append(li0, strong0);
      append(li0, t3);
      append(li0, t4);
      append(ul, t5);
      append(ul, li1);
      append(li1, strong1);
      append(li1, t7);
      append(li1, t8);
      append(ul, t9);
      append(ul, li2);
      append(li2, strong2);
      append(li2, t11);
      append(li2, t12);
      append(div31, t13);
      append(div31, div29);
      append(div29, h31);
      append(div29, t15);
      append(div29, div1);
      append(div29, t17);
      append(div29, div7);
      append(div7, div4);
      append(div7, t21);
      append(div7, div6);
      append(div6, label0);
      append(label0, input0);
      input0.checked = /*enableNewCardsLimit*/
      ctx[3];
      append(label0, t22);
      append(label0, div5);
      append(div29, t23);
      append(div29, div12);
      append(div12, div10);
      append(div12, t27);
      append(div12, div11);
      append(div11, input1);
      set_input_value(
        input1,
        /*newCardsLimit*/
        ctx[1]
      );
      append(div29, t28);
      append(div29, div18);
      append(div18, div15);
      append(div18, t32);
      append(div18, div17);
      append(div17, label1);
      append(label1, input2);
      input2.checked = /*enableReviewCardsLimit*/
      ctx[4];
      append(label1, t33);
      append(label1, div16);
      append(div29, t34);
      append(div29, div23);
      append(div23, div21);
      append(div23, t38);
      append(div23, div22);
      append(div22, input3);
      set_input_value(
        input3,
        /*reviewCardsLimit*/
        ctx[2]
      );
      append(div29, t39);
      append(div29, div28);
      append(div28, div26);
      append(div28, t43);
      append(div28, div27);
      append(div27, select);
      append(select, option0);
      append(select, option1);
      select_option(
        select,
        /*reviewOrder*/
        ctx[5],
        true
      );
      append(div31, t46);
      append(div31, div30);
      append(div30, button0);
      append(button0, t47);
      append(div30, t48);
      append(div30, button1);
      append(button1, t49);
      if (!mounted) {
        dispose = [
          listen(
            window,
            "keydown",
            /*handleKeydown*/
            ctx[9]
          ),
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[12]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[13]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[14]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[15]
          ),
          listen(
            button0,
            "click",
            /*handleSave*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*handleCancel*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*deck*/
      1 && t4_value !== (t4_value = /*deck*/
      ctx2[0].name + ""))
        set_data(t4, t4_value);
      if (dirty & /*deck*/
      1 && t8_value !== (t8_value = /*deck*/
      ctx2[0].tag + ""))
        set_data(t8, t8_value);
      if (dirty & /*deck*/
      1 && t12_value !== (t12_value = /*deck*/
      ctx2[0].filepath + ""))
        set_data(t12, t12_value);
      if (dirty & /*enableNewCardsLimit*/
      8) {
        input0.checked = /*enableNewCardsLimit*/
        ctx2[3];
      }
      if (dirty & /*enableNewCardsLimit*/
      8 && input1_disabled_value !== (input1_disabled_value = !/*enableNewCardsLimit*/
      ctx2[3])) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*newCardsLimit*/
      2 && to_number(input1.value) !== /*newCardsLimit*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*newCardsLimit*/
          ctx2[1]
        );
      }
      if (dirty & /*enableNewCardsLimit*/
      8) {
        toggle_class(div12, "disabled", !/*enableNewCardsLimit*/
        ctx2[3]);
      }
      if (dirty & /*enableReviewCardsLimit*/
      16) {
        input2.checked = /*enableReviewCardsLimit*/
        ctx2[4];
      }
      if (dirty & /*enableReviewCardsLimit*/
      16 && input3_disabled_value !== (input3_disabled_value = !/*enableReviewCardsLimit*/
      ctx2[4])) {
        input3.disabled = input3_disabled_value;
      }
      if (dirty & /*reviewCardsLimit*/
      4 && to_number(input3.value) !== /*reviewCardsLimit*/
      ctx2[2]) {
        set_input_value(
          input3,
          /*reviewCardsLimit*/
          ctx2[2]
        );
      }
      if (dirty & /*enableReviewCardsLimit*/
      16) {
        toggle_class(div23, "disabled", !/*enableReviewCardsLimit*/
        ctx2[4]);
      }
      if (dirty & /*reviewOrder*/
      32) {
        select_option(
          select,
          /*reviewOrder*/
          ctx2[5]
        );
      }
      if (dirty & /*saving*/
      64 && t47_value !== (t47_value = /*saving*/
      ctx2[6] ? "Saving..." : "Save"))
        set_data(t47, t47_value);
      if (dirty & /*saving*/
      64) {
        button0.disabled = /*saving*/
        ctx2[6];
      }
      if (dirty & /*saving*/
      64) {
        button1.disabled = /*saving*/
        ctx2[6];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div31);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { deck } = $$props;
  let { config } = $$props;
  const dispatch = createEventDispatcher();
  let newCardsLimit = config.newCardsLimit;
  let reviewCardsLimit = config.reviewCardsLimit;
  let enableNewCardsLimit = config.enableNewCardsLimit;
  let enableReviewCardsLimit = config.enableReviewCardsLimit;
  let reviewOrder = config.reviewOrder;
  let saving = false;
  function handleSave() {
    $$invalidate(6, saving = true);
    const finalConfig = {
      newCardsLimit: Number(newCardsLimit) || 0,
      reviewCardsLimit: Number(reviewCardsLimit) || 0,
      enableNewCardsLimit,
      enableReviewCardsLimit,
      reviewOrder
    };
    dispatch("save", finalConfig);
  }
  function handleCancel() {
    dispatch("cancel");
  }
  function handleKeydown(event) {
    if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
      handleSave();
    }
  }
  function input0_change_handler() {
    enableNewCardsLimit = this.checked;
    $$invalidate(3, enableNewCardsLimit);
  }
  function input1_input_handler() {
    newCardsLimit = to_number(this.value);
    $$invalidate(1, newCardsLimit);
  }
  function input2_change_handler() {
    enableReviewCardsLimit = this.checked;
    $$invalidate(4, enableReviewCardsLimit);
  }
  function input3_input_handler() {
    reviewCardsLimit = to_number(this.value);
    $$invalidate(2, reviewCardsLimit);
  }
  function select_change_handler() {
    reviewOrder = select_value(this);
    $$invalidate(5, reviewOrder);
  }
  $$self.$$set = ($$props2) => {
    if ("deck" in $$props2)
      $$invalidate(0, deck = $$props2.deck);
    if ("config" in $$props2)
      $$invalidate(10, config = $$props2.config);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*newCardsLimit, reviewCardsLimit, enableNewCardsLimit, enableReviewCardsLimit, reviewOrder*/
    62) {
      $: {
        const newConfig = {
          newCardsLimit: Number(newCardsLimit) || 0,
          reviewCardsLimit: Number(reviewCardsLimit) || 0,
          enableNewCardsLimit,
          enableReviewCardsLimit,
          reviewOrder
        };
        dispatch("configChange", newConfig);
      }
    }
  };
  return [
    deck,
    newCardsLimit,
    reviewCardsLimit,
    enableNewCardsLimit,
    enableReviewCardsLimit,
    reviewOrder,
    saving,
    handleSave,
    handleCancel,
    handleKeydown,
    config,
    input0_change_handler,
    input1_input_handler,
    input2_change_handler,
    input3_input_handler,
    select_change_handler
  ];
}
var DeckConfigUI = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { deck: 0, config: 10 }, add_css2);
  }
};
var DeckConfigUI_default = DeckConfigUI;

// src/components/DeckConfigModal.ts
var DeckConfigModal = class extends import_obsidian3.Modal {
  constructor(plugin, deck, onSave) {
    super(plugin.app);
    this.component = null;
    this.plugin = plugin;
    this.deck = deck;
    this.onSave = onSave;
    this.config = { ...deck.config };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Configure Deck: ${this.deck.name}` });
    const componentContainer = contentEl.createDiv("deck-config-container");
    componentContainer.style.padding = "0";
    componentContainer.style.margin = "0";
    this.component = new DeckConfigUI_default({
      target: componentContainer,
      props: {
        deck: this.deck,
        config: this.config
      }
    });
    this.component.$on("save", (event) => {
      this.handleSave(event.detail);
    });
    this.component.$on("cancel", () => {
      this.close();
    });
    this.component.$on("configChange", (event) => {
      this.config = event.detail;
    });
  }
  async handleSave(config) {
    try {
      await this.onSave(config);
      this.close();
    } catch (error) {
      console.error("Error saving deck configuration:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    if (this.component) {
      this.component.$destroy();
      this.component = null;
    }
    contentEl.empty();
  }
};

// src/components/DeckListPanel.svelte
function add_css3(target) {
  append_styles(target, "svelte-1ufhkzf", ".deck-list-panel.svelte-1ufhkzf.svelte-1ufhkzf{min-width:400px;height:100%;display:flex;flex-direction:column;background:var(--background-primary);color:var(--text-normal)}.panel-header.svelte-1ufhkzf.svelte-1ufhkzf{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--background-modifier-border)}.header-buttons.svelte-1ufhkzf.svelte-1ufhkzf{display:flex;gap:8px;align-items:center}.filter-section.svelte-1ufhkzf.svelte-1ufhkzf{padding:8px 16px;border-bottom:1px solid var(--background-modifier-border)}.filter-input.svelte-1ufhkzf.svelte-1ufhkzf{width:100%;padding:6px 8px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:14px;transition:border-color 0.2s ease}.filter-input.svelte-1ufhkzf.svelte-1ufhkzf:focus{outline:none;border-color:var(--interactive-accent)}.filter-input.svelte-1ufhkzf.svelte-1ufhkzf::placeholder{color:var(--text-muted)}.panel-title.svelte-1ufhkzf.svelte-1ufhkzf{margin:0;font-size:16px;font-weight:600}.stats-button.svelte-1ufhkzf.svelte-1ufhkzf{padding:6px;background:var(--interactive-normal);border:none;border-radius:4px;cursor:pointer;color:var(--text-muted);transition:all 0.2s ease}.stats-button.svelte-1ufhkzf.svelte-1ufhkzf:hover{background:var(--interactive-hover);color:var(--text-normal)}.refresh-button.svelte-1ufhkzf.svelte-1ufhkzf{background:none;border:none;cursor:pointer;padding:4px;border-radius:4px;color:var(--text-muted);transition:all 0.2s ease;position:relative;z-index:1}.refresh-button.svelte-1ufhkzf.svelte-1ufhkzf:hover{background:var(--background-modifier-hover);color:var(--text-normal)}.refresh-button.svelte-1ufhkzf.svelte-1ufhkzf:disabled{opacity:0.5;cursor:not-allowed}.refresh-button.refreshing.svelte-1ufhkzf svg.svelte-1ufhkzf{animation:svelte-1ufhkzf-spin 1s linear infinite}@keyframes svelte-1ufhkzf-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.empty-state.svelte-1ufhkzf.svelte-1ufhkzf{flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:32px;text-align:center}.empty-state.svelte-1ufhkzf p.svelte-1ufhkzf{margin:8px 0}.help-text.svelte-1ufhkzf.svelte-1ufhkzf{font-size:14px;color:var(--text-muted)}.deck-table.svelte-1ufhkzf.svelte-1ufhkzf{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header.svelte-1ufhkzf.svelte-1ufhkzf{display:grid;grid-template-columns:1fr 60px 60px 60px 40px;gap:8px;padding:8px 16px;font-weight:600;font-size:14px;border-bottom:1px solid var(--background-modifier-border);background:var(--background-secondary);align-items:center}.table-body.svelte-1ufhkzf.svelte-1ufhkzf{flex:1;overflow-y:auto}.deck-row.svelte-1ufhkzf.svelte-1ufhkzf{display:grid;grid-template-columns:1fr 60px 60px 60px 40px;gap:8px;padding:12px 16px;border-bottom:1px solid var(--background-modifier-border);align-items:center}.deck-name-link.svelte-1ufhkzf.svelte-1ufhkzf{cursor:pointer;color:var(--text-normal);text-decoration:underline;text-decoration-color:transparent;transition:text-decoration-color 0.2s ease;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;max-width:100%}.deck-name-link.svelte-1ufhkzf.svelte-1ufhkzf:hover{text-decoration-color:var(--text-accent);color:var(--text-accent)}.deck-name-link.svelte-1ufhkzf.svelte-1ufhkzf:focus{outline:2px solid var(--interactive-accent);outline-offset:2px;border-radius:3px}.col-config.svelte-1ufhkzf.svelte-1ufhkzf{display:flex;align-items:center;justify-content:center}.deck-config-button.svelte-1ufhkzf.svelte-1ufhkzf{background:transparent;border:none;color:var(--text-muted);cursor:pointer;padding:6px;border-radius:3px;display:flex;align-items:center;justify-content:center;transition:all 0.2s ease}.deck-config-button.svelte-1ufhkzf.svelte-1ufhkzf:hover{background:var(--background-modifier-hover);color:var(--text-normal)}.deck-config-button.svelte-1ufhkzf.svelte-1ufhkzf:focus{outline:2px solid var(--interactive-accent);outline-offset:2px}.col-deck.svelte-1ufhkzf.svelte-1ufhkzf{font-size:14px;color:var(--text-normal);justify-self:start;min-width:0}.col-stat.svelte-1ufhkzf.svelte-1ufhkzf{text-align:center;font-size:14px;color:var(--text-muted);justify-self:center}.table-header.svelte-1ufhkzf .col-deck.svelte-1ufhkzf{font-size:14px;color:var(--text-normal);justify-self:start}.table-header.svelte-1ufhkzf .col-stat.svelte-1ufhkzf{text-align:center;font-size:14px;color:var(--text-normal);justify-self:center}.col-stat.has-cards.svelte-1ufhkzf.svelte-1ufhkzf{color:#4aa3df;font-weight:500}.col-stat.updating.svelte-1ufhkzf.svelte-1ufhkzf{opacity:0.6;transition:opacity 0.3s ease}.col-stat.has-limit.svelte-1ufhkzf.svelte-1ufhkzf{position:relative;border-left:2px solid var(--interactive-accent);padding-left:6px}.limit-indicator.svelte-1ufhkzf.svelte-1ufhkzf{font-size:10px;margin-left:4px;opacity:0.7}.table-body.svelte-1ufhkzf.svelte-1ufhkzf::-webkit-scrollbar{width:8px}.table-body.svelte-1ufhkzf.svelte-1ufhkzf::-webkit-scrollbar-track{background:transparent}.table-body.svelte-1ufhkzf.svelte-1ufhkzf::-webkit-scrollbar-thumb{background:var(--background-modifier-border);border-radius:4px}.table-body.svelte-1ufhkzf.svelte-1ufhkzf::-webkit-scrollbar-thumb:hover{background:var(--background-modifier-border-hover)}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  const constants_0 = (
    /*getDeckStats*/
    child_ctx[9](
      /*deck*/
      child_ctx[28].id
    )
  );
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_else_block2(ctx) {
  let div7;
  let div5;
  let t8;
  let div6;
  let each_value = (
    /*decks*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div7 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="col-deck svelte-1ufhkzf">Deck</div> 
                <div class="col-stat svelte-1ufhkzf">New</div> 
                <div class="col-stat svelte-1ufhkzf">Learn</div> 
                <div class="col-stat svelte-1ufhkzf">Due</div> 
                <div class="col-config svelte-1ufhkzf"></div>`;
      t8 = space();
      div6 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div5, "class", "table-header svelte-1ufhkzf");
      attr(div6, "class", "table-body svelte-1ufhkzf");
      attr(div7, "class", "deck-table svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div5);
      append(div7, t8);
      append(div7, div6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div6, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*decks, handleConfigClick, getDeckStats, isUpdatingStats, handleDeckClick, formatDeckName*/
      12932) {
        each_value = /*decks*/
        ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div6, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-1ufhkzf">No decks match your filter.</p> 
            <p class="help-text svelte-1ufhkzf">Try adjusting your search terms.</p>`;
      attr(div, "class", "empty-state svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-1ufhkzf">No flashcard decks found.</p> 
            <p class="help-text svelte-1ufhkzf">Tag your notes with #flashcards to create decks.</p>`;
      attr(div, "class", "empty-state svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "\u{1F4C5}";
      attr(span, "class", "limit-indicator svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "\u{1F4C5}";
      attr(span, "class", "limit-indicator svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block2(ctx) {
  let div5;
  let div0;
  let span;
  let t0_value = formatDeckName(
    /*deck*/
    ctx[28]
  ) + "";
  let t0;
  let span_title_value;
  let t1;
  let div1;
  let t2_value = (
    /*stats*/
    ctx[8].newCount + ""
  );
  let t2;
  let t3;
  let div1_title_value;
  let t4;
  let div2;
  let t5_value = (
    /*stats*/
    ctx[8].learningCount + ""
  );
  let t5;
  let t6;
  let div3;
  let t7_value = (
    /*stats*/
    ctx[8].dueCount + ""
  );
  let t7;
  let t8;
  let div3_title_value;
  let t9;
  let div4;
  let button;
  let svg;
  let circle;
  let path;
  let button_aria_label_value;
  let t10;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[23](
        /*deck*/
        ctx[28]
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[24](
        /*deck*/
        ctx[28],
        ...args
      )
    );
  }
  let if_block0 = (
    /*deck*/
    ctx[28].config.enableNewCardsLimit && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*deck*/
    ctx[28].config.enableReviewCardsLimit && create_if_block_2(ctx)
  );
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[25](
        /*deck*/
        ctx[28],
        ...args
      )
    );
  }
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div3 = element("div");
      t7 = text(t7_value);
      t8 = space();
      if (if_block1)
        if_block1.c();
      t9 = space();
      div4 = element("div");
      button = element("button");
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t10 = space();
      attr(span, "class", "deck-name-link svelte-1ufhkzf");
      attr(span, "role", "button");
      attr(span, "tabindex", "0");
      attr(span, "title", span_title_value = "Click to review " + /*deck*/
      ctx[28].name);
      attr(div0, "class", "col-deck svelte-1ufhkzf");
      attr(div1, "class", "col-stat svelte-1ufhkzf");
      attr(div1, "title", div1_title_value = /*deck*/
      ctx[28].config.enableNewCardsLimit ? `${/*stats*/
      ctx[8].newCount} new cards available today (limit: ${/*deck*/
      ctx[28].config.newCardsLimit})` : `${/*stats*/
      ctx[8].newCount} new cards due`);
      toggle_class(
        div1,
        "has-cards",
        /*stats*/
        ctx[8].newCount > 0
      );
      toggle_class(
        div1,
        "updating",
        /*isUpdatingStats*/
        ctx[7]
      );
      toggle_class(
        div1,
        "has-limit",
        /*deck*/
        ctx[28].config.enableNewCardsLimit
      );
      attr(div2, "class", "col-stat svelte-1ufhkzf");
      toggle_class(
        div2,
        "has-cards",
        /*stats*/
        ctx[8].learningCount > 0
      );
      toggle_class(
        div2,
        "updating",
        /*isUpdatingStats*/
        ctx[7]
      );
      attr(div3, "class", "col-stat svelte-1ufhkzf");
      attr(div3, "title", div3_title_value = /*deck*/
      ctx[28].config.enableReviewCardsLimit ? `${/*stats*/
      ctx[8].dueCount} review cards available today (limit: ${/*deck*/
      ctx[28].config.reviewCardsLimit})` : `${/*stats*/
      ctx[8].dueCount} review cards due`);
      toggle_class(
        div3,
        "has-cards",
        /*stats*/
        ctx[8].dueCount > 0
      );
      toggle_class(
        div3,
        "updating",
        /*isUpdatingStats*/
        ctx[7]
      );
      toggle_class(
        div3,
        "has-limit",
        /*deck*/
        ctx[28].config.enableReviewCardsLimit
      );
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "3");
      attr(path, "d", "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(button, "class", "deck-config-button svelte-1ufhkzf");
      attr(button, "title", "Configure deck settings");
      attr(button, "aria-label", button_aria_label_value = "Configure " + /*deck*/
      ctx[28].name);
      attr(div4, "class", "col-config svelte-1ufhkzf");
      attr(div5, "class", "deck-row svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, span);
      append(span, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, t2);
      append(div1, t3);
      if (if_block0)
        if_block0.m(div1, null);
      append(div5, t4);
      append(div5, div2);
      append(div2, t5);
      append(div5, t6);
      append(div5, div3);
      append(div3, t7);
      append(div3, t8);
      if (if_block1)
        if_block1.m(div3, null);
      append(div5, t9);
      append(div5, div4);
      append(div4, button);
      append(button, svg);
      append(svg, circle);
      append(svg, path);
      append(div5, t10);
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler),
          listen(span, "keydown", keydown_handler),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*decks*/
      4 && t0_value !== (t0_value = formatDeckName(
        /*deck*/
        ctx[28]
      ) + ""))
        set_data(t0, t0_value);
      if (dirty & /*decks*/
      4 && span_title_value !== (span_title_value = "Click to review " + /*deck*/
      ctx[28].name)) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*decks*/
      4 && t2_value !== (t2_value = /*stats*/
      ctx[8].newCount + ""))
        set_data(t2, t2_value);
      if (
        /*deck*/
        ctx[28].config.enableNewCardsLimit
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*decks*/
      4 && div1_title_value !== (div1_title_value = /*deck*/
      ctx[28].config.enableNewCardsLimit ? `${/*stats*/
      ctx[8].newCount} new cards available today (limit: ${/*deck*/
      ctx[28].config.newCardsLimit})` : `${/*stats*/
      ctx[8].newCount} new cards due`)) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty & /*getDeckStats, decks*/
      516) {
        toggle_class(
          div1,
          "has-cards",
          /*stats*/
          ctx[8].newCount > 0
        );
      }
      if (dirty & /*isUpdatingStats*/
      128) {
        toggle_class(
          div1,
          "updating",
          /*isUpdatingStats*/
          ctx[7]
        );
      }
      if (dirty & /*decks*/
      4) {
        toggle_class(
          div1,
          "has-limit",
          /*deck*/
          ctx[28].config.enableNewCardsLimit
        );
      }
      if (dirty & /*decks*/
      4 && t5_value !== (t5_value = /*stats*/
      ctx[8].learningCount + ""))
        set_data(t5, t5_value);
      if (dirty & /*getDeckStats, decks*/
      516) {
        toggle_class(
          div2,
          "has-cards",
          /*stats*/
          ctx[8].learningCount > 0
        );
      }
      if (dirty & /*isUpdatingStats*/
      128) {
        toggle_class(
          div2,
          "updating",
          /*isUpdatingStats*/
          ctx[7]
        );
      }
      if (dirty & /*decks*/
      4 && t7_value !== (t7_value = /*stats*/
      ctx[8].dueCount + ""))
        set_data(t7, t7_value);
      if (
        /*deck*/
        ctx[28].config.enableReviewCardsLimit
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*decks*/
      4 && div3_title_value !== (div3_title_value = /*deck*/
      ctx[28].config.enableReviewCardsLimit ? `${/*stats*/
      ctx[8].dueCount} review cards available today (limit: ${/*deck*/
      ctx[28].config.reviewCardsLimit})` : `${/*stats*/
      ctx[8].dueCount} review cards due`)) {
        attr(div3, "title", div3_title_value);
      }
      if (dirty & /*getDeckStats, decks*/
      516) {
        toggle_class(
          div3,
          "has-cards",
          /*stats*/
          ctx[8].dueCount > 0
        );
      }
      if (dirty & /*isUpdatingStats*/
      128) {
        toggle_class(
          div3,
          "updating",
          /*isUpdatingStats*/
          ctx[7]
        );
      }
      if (dirty & /*decks*/
      4) {
        toggle_class(
          div3,
          "has-limit",
          /*deck*/
          ctx[28].config.enableReviewCardsLimit
        );
      }
      if (dirty & /*decks*/
      4 && button_aria_label_value !== (button_aria_label_value = "Configure " + /*deck*/
      ctx[28].name)) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let div3;
  let div1;
  let h3;
  let t1;
  let div0;
  let button0;
  let t2;
  let button1;
  let svg1;
  let path4;
  let path5;
  let path6;
  let t3;
  let div2;
  let input;
  let t4;
  let t5;
  let reviewheatmap;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*allDecks*/
      ctx2[3].length === 0
    )
      return create_if_block2;
    if (
      /*decks*/
      ctx2[2].length === 0
    )
      return create_if_block_12;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let reviewheatmap_props = {
    getReviewCounts: (
      /*getReviewCounts*/
      ctx[0]
    )
  };
  reviewheatmap = new ReviewHeatmap_default({ props: reviewheatmap_props });
  ctx[26](reviewheatmap);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      h3 = element("h3");
      h3.textContent = "Flashcard Decks";
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"></path><path d="M18 17V9"></path><path d="M13 17V5"></path><path d="M8 17v-3"></path></svg>`;
      t2 = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      t3 = space();
      div2 = element("div");
      input = element("input");
      t4 = space();
      if_block.c();
      t5 = space();
      create_component(reviewheatmap.$$.fragment);
      attr(h3, "class", "panel-title svelte-1ufhkzf");
      attr(button0, "class", "stats-button svelte-1ufhkzf");
      attr(button0, "title", "View Overall Statistics");
      attr(path4, "d", "M23 4v6h-6");
      attr(path5, "d", "M1 20v-6h6");
      attr(path6, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
      attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg1, "width", "14");
      attr(svg1, "height", "14");
      attr(svg1, "viewBox", "0 0 24 24");
      attr(svg1, "fill", "none");
      attr(svg1, "stroke", "currentColor");
      attr(svg1, "stroke-width", "2");
      attr(svg1, "stroke-linecap", "round");
      attr(svg1, "stroke-linejoin", "round");
      attr(svg1, "class", "svelte-1ufhkzf");
      attr(button1, "class", "refresh-button svelte-1ufhkzf");
      button1.disabled = /*isRefreshing*/
      ctx[6];
      toggle_class(
        button1,
        "refreshing",
        /*isRefreshing*/
        ctx[6]
      );
      attr(div0, "class", "header-buttons svelte-1ufhkzf");
      attr(div1, "class", "panel-header svelte-1ufhkzf");
      attr(input, "type", "text");
      attr(input, "class", "filter-input svelte-1ufhkzf");
      attr(input, "placeholder", "Filter by name or tag...");
      attr(div2, "class", "filter-section svelte-1ufhkzf");
      attr(div3, "class", "deck-list-panel svelte-1ufhkzf");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, h3);
      append(div1, t1);
      append(div1, div0);
      append(div0, button0);
      append(div0, t2);
      append(div0, button1);
      append(button1, svg1);
      append(svg1, path4);
      append(svg1, path5);
      append(svg1, path6);
      append(div3, t3);
      append(div3, div2);
      append(div2, input);
      set_input_value(
        input,
        /*filterText*/
        ctx[4]
      );
      append(div3, t4);
      if_block.m(div3, null);
      append(div3, t5);
      mount_component(reviewheatmap, div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*onOpenStatistics*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(
            button1,
            "click",
            /*handleRefresh*/
            ctx[10]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[22]
          ),
          listen(
            input,
            "input",
            /*handleFilterInput*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*isRefreshing*/
      64) {
        button1.disabled = /*isRefreshing*/
        ctx[6];
      }
      if (!current || dirty & /*isRefreshing*/
      64) {
        toggle_class(
          button1,
          "refreshing",
          /*isRefreshing*/
          ctx[6]
        );
      }
      if (dirty & /*filterText*/
      16 && input.value !== /*filterText*/
      ctx[4]) {
        set_input_value(
          input,
          /*filterText*/
          ctx[4]
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div3, t5);
        }
      }
      const reviewheatmap_changes = {};
      if (dirty & /*getReviewCounts*/
      1)
        reviewheatmap_changes.getReviewCounts = /*getReviewCounts*/
        ctx[0];
      reviewheatmap.$set(reviewheatmap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(reviewheatmap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(reviewheatmap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
      ctx[26](null);
      destroy_component(reviewheatmap);
      mounted = false;
      run_all(dispose);
    }
  };
}
function formatDeckName(deck) {
  return deck.name;
}
function instance3($$self, $$props, $$invalidate) {
  let decks = [];
  let allDecks = [];
  let stats = /* @__PURE__ */ new Map();
  let filterText = "";
  let heatmapComponent;
  let { onDeckClick } = $$props;
  let { onRefresh } = $$props;
  let { getReviewCounts } = $$props;
  let { onUpdateDeckConfig } = $$props;
  let { onOpenStatistics } = $$props;
  let { plugin } = $$props;
  let isRefreshing = false;
  let isUpdatingStats = false;
  function getDeckStats(deckId) {
    var _a;
    return (_a = stats.get(deckId)) !== null && _a !== void 0 ? _a : {
      deckId,
      newCount: 0,
      learningCount: 0,
      dueCount: 0,
      totalCount: 0
    };
  }
  function handleRefresh() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(6, isRefreshing = true);
      try {
        onRefresh();
        refreshHeatmap();
      } catch (error) {
        console.error("Error during refresh:", error);
      } finally {
        $$invalidate(6, isRefreshing = false);
      }
    });
  }
  function updateStatsById(deckId, newStats) {
    $$invalidate(7, isUpdatingStats = true);
    stats.set(deckId, newStats);
    $$invalidate(2, decks);
    $$invalidate(7, isUpdatingStats = false);
  }
  function updateStats(newStats) {
    $$invalidate(7, isUpdatingStats = true);
    $$invalidate(8, stats = newStats);
    $$invalidate(2, decks);
    $$invalidate(7, isUpdatingStats = false);
  }
  function updateDecks(newDecks) {
    $$invalidate(3, allDecks = newDecks);
    applyFilter();
  }
  function applyFilter() {
    if (!filterText.trim()) {
      $$invalidate(2, decks = allDecks);
    } else {
      const filter = filterText.toLowerCase();
      $$invalidate(2, decks = allDecks.filter((deck) => deck.name.toLowerCase().includes(filter) || deck.tag.toLowerCase().includes(filter)));
    }
  }
  function handleFilterInput(event) {
    const target = event.target;
    $$invalidate(4, filterText = target.value);
    applyFilter();
  }
  function handleDeckClick(deck) {
    onDeckClick(deck);
  }
  function refreshHeatmap() {
    if (heatmapComponent) {
      heatmapComponent.refresh();
    }
  }
  function handleConfigClick(deck, event) {
    event.stopPropagation();
    const modal = new DeckConfigModal(
      plugin,
      deck,
      (config) => __awaiter(this, void 0, void 0, function* () {
        if (onUpdateDeckConfig) {
          yield onUpdateDeckConfig(deck.id, config);
          const deckIndex = allDecks.findIndex((d) => d.id === deck.id);
          if (deckIndex !== -1) {
            $$invalidate(3, allDecks[deckIndex].config = config, allDecks);
            $$invalidate(3, allDecks = [...allDecks]);
            applyFilter();
          }
        }
      })
    );
    modal.open();
  }
  onMount(() => {
    handleRefresh();
  });
  function input_input_handler() {
    filterText = this.value;
    $$invalidate(4, filterText);
  }
  const click_handler = (deck) => handleDeckClick(deck);
  const keydown_handler = (deck, e) => e.key === "Enter" && handleDeckClick(deck);
  const click_handler_1 = (deck, e) => handleConfigClick(deck, e);
  function reviewheatmap_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      heatmapComponent = $$value;
      $$invalidate(5, heatmapComponent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("onDeckClick" in $$props2)
      $$invalidate(14, onDeckClick = $$props2.onDeckClick);
    if ("onRefresh" in $$props2)
      $$invalidate(15, onRefresh = $$props2.onRefresh);
    if ("getReviewCounts" in $$props2)
      $$invalidate(0, getReviewCounts = $$props2.getReviewCounts);
    if ("onUpdateDeckConfig" in $$props2)
      $$invalidate(16, onUpdateDeckConfig = $$props2.onUpdateDeckConfig);
    if ("onOpenStatistics" in $$props2)
      $$invalidate(1, onOpenStatistics = $$props2.onOpenStatistics);
    if ("plugin" in $$props2)
      $$invalidate(17, plugin = $$props2.plugin);
  };
  return [
    getReviewCounts,
    onOpenStatistics,
    decks,
    allDecks,
    filterText,
    heatmapComponent,
    isRefreshing,
    isUpdatingStats,
    stats,
    getDeckStats,
    handleRefresh,
    handleFilterInput,
    handleDeckClick,
    handleConfigClick,
    onDeckClick,
    onRefresh,
    onUpdateDeckConfig,
    plugin,
    updateStatsById,
    updateStats,
    updateDecks,
    refreshHeatmap,
    input_input_handler,
    click_handler,
    keydown_handler,
    click_handler_1,
    reviewheatmap_binding
  ];
}
var DeckListPanel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        onDeckClick: 14,
        onRefresh: 15,
        getReviewCounts: 0,
        onUpdateDeckConfig: 16,
        onOpenStatistics: 1,
        plugin: 17,
        updateStatsById: 18,
        updateStats: 19,
        updateDecks: 20,
        refreshHeatmap: 21
      },
      add_css3
    );
  }
  get updateStatsById() {
    return this.$$.ctx[18];
  }
  get updateStats() {
    return this.$$.ctx[19];
  }
  get updateDecks() {
    return this.$$.ctx[20];
  }
  get refreshHeatmap() {
    return this.$$.ctx[21];
  }
};
var DeckListPanel_default = DeckListPanel;

// src/components/StatisticsModal.ts
var import_obsidian4 = require("obsidian");

// src/components/StatisticsUI.svelte
function add_css4(target) {
  append_styles(target, "svelte-lbb1rg", `.statistics-container.svelte-lbb1rg.svelte-lbb1rg{padding:20px;font-family:var(--font-interface);width:100%;overflow-x:hidden}.loading.svelte-lbb1rg.svelte-lbb1rg,.error.svelte-lbb1rg.svelte-lbb1rg{text-align:center;padding:40px;color:var(--text-muted)}.filters.svelte-lbb1rg.svelte-lbb1rg{display:flex;gap:24px;margin-bottom:24px;padding:20px;background:var(--background-secondary);border-radius:10px;flex-wrap:wrap;justify-content:center}.filter-group.svelte-lbb1rg.svelte-lbb1rg{display:flex;flex-direction:column;gap:8px;min-width:200px}.filter-group.svelte-lbb1rg label.svelte-lbb1rg{font-size:14px;color:var(--text-muted);font-weight:600}.filter-group.svelte-lbb1rg select.svelte-lbb1rg{padding:10px 12px;border:2px solid var(--background-modifier-border);border-radius:6px;background:var(--background-primary);color:var(--text-normal);font-size:14px;font-weight:500;appearance:none;-webkit-appearance:none;-moz-appearance:none;cursor:pointer;min-width:180px;background-image:url("data:image/svg+xml;charset=US-ASCII,<svg xmlns='http://www.w3.org/2000/svg' width='4' height='5'><path fill='%23666' d='m0 0 2 2 2-2z'/></svg>");background-repeat:no-repeat;background-position:right 12px center;background-size:12px}.filter-group.svelte-lbb1rg select.svelte-lbb1rg:focus{outline:none;border-color:var(--interactive-accent);box-shadow:0 0 0 2px var(--interactive-accent-hover)}.filter-group.svelte-lbb1rg select option.svelte-lbb1rg{background:var(--background-primary);color:var(--text-normal);font-weight:500;padding:8px}.stats-section.svelte-lbb1rg.svelte-lbb1rg{margin-bottom:32px;padding-bottom:24px;border-bottom:1px solid var(--background-modifier-border)}.stats-section.svelte-lbb1rg.svelte-lbb1rg:last-of-type{border-bottom:none}.stats-section.svelte-lbb1rg h3.svelte-lbb1rg{margin:0 0 20px 0;color:var(--text-normal);font-size:18px;font-weight:600}.stats-section.svelte-lbb1rg h4.svelte-lbb1rg{margin:24px 0 12px 0;color:var(--text-normal);font-size:16px;font-weight:500}.stats-grid.svelte-lbb1rg.svelte-lbb1rg{display:grid;grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));gap:16px;margin-bottom:20px}.stat-card.svelte-lbb1rg.svelte-lbb1rg{background:var(--background-secondary);padding:16px;border-radius:8px;text-align:center;border:1px solid var(--background-modifier-border);min-height:80px;display:flex;flex-direction:column;justify-content:center}.stat-value.svelte-lbb1rg.svelte-lbb1rg{font-size:24px;font-weight:600;color:var(--text-normal);margin-bottom:4px}.stat-label.svelte-lbb1rg.svelte-lbb1rg{font-size:12px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px}.metrics-grid.svelte-lbb1rg.svelte-lbb1rg{display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:16px;margin-bottom:24px}.metric-card.svelte-lbb1rg.svelte-lbb1rg{background:var(--background-secondary);padding:20px;border-radius:8px;border:1px solid var(--background-modifier-border);min-height:100px}.metric-value.svelte-lbb1rg.svelte-lbb1rg{font-size:28px;font-weight:700;color:var(--text-accent);margin-bottom:8px}.metric-label.svelte-lbb1rg.svelte-lbb1rg{font-size:14px;font-weight:600;color:var(--text-normal);margin-bottom:4px}.metric-description.svelte-lbb1rg.svelte-lbb1rg{font-size:11px;color:var(--text-muted);line-height:1.3}.forecast-chart.svelte-lbb1rg.svelte-lbb1rg{display:flex;gap:4px;align-items:flex-end;padding:16px;background:var(--background-secondary);border-radius:8px;min-height:150px;overflow-x:auto;overflow-y:hidden;max-width:100%}.forecast-bar.svelte-lbb1rg.svelte-lbb1rg{display:flex;flex-direction:column;align-items:center;gap:4px;min-width:20px;flex-shrink:0}.bar.svelte-lbb1rg.svelte-lbb1rg{background:var(--text-accent);width:12px;border-radius:2px 2px 0 0;transition:background 0.2s}.bar-label.svelte-lbb1rg.svelte-lbb1rg{font-size:8px;color:var(--text-muted);writing-mode:vertical-rl;text-orientation:mixed}.bar-value.svelte-lbb1rg.svelte-lbb1rg{font-size:10px;color:var(--text-normal)}.forecast-note.svelte-lbb1rg.svelte-lbb1rg{margin-top:8px;font-size:12px;color:var(--text-muted);text-align:center}.button-stats.svelte-lbb1rg.svelte-lbb1rg{display:flex;flex-direction:column;gap:12px}.button-bar.svelte-lbb1rg.svelte-lbb1rg{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-radius:6px;background:var(--background-secondary);border:1px solid var(--background-modifier-border)}.button-bar.again.svelte-lbb1rg.svelte-lbb1rg{border-left:4px solid #ef4444}.button-bar.hard.svelte-lbb1rg.svelte-lbb1rg{border-left:4px solid #f97316}.button-bar.good.svelte-lbb1rg.svelte-lbb1rg{border-left:4px solid #22c55e}.button-bar.easy.svelte-lbb1rg.svelte-lbb1rg{border-left:4px solid #3b82f6}.button-label.svelte-lbb1rg.svelte-lbb1rg{font-weight:500;color:var(--text-normal)}.button-count.svelte-lbb1rg.svelte-lbb1rg{font-weight:600;color:var(--text-normal);font-size:18px}.button-percentage.svelte-lbb1rg.svelte-lbb1rg{font-size:12px;color:var(--text-muted)}.intervals-chart.svelte-lbb1rg.svelte-lbb1rg{display:flex;flex-wrap:wrap;gap:12px;padding:16px;background:var(--background-secondary);border-radius:8px;max-width:100%;overflow-x:hidden}.interval-bar.svelte-lbb1rg.svelte-lbb1rg{display:flex;flex-direction:column;align-items:center;padding:12px 8px;background:var(--background-primary);border-radius:6px;min-width:60px;border:1px solid var(--background-modifier-border)}.interval-label.svelte-lbb1rg.svelte-lbb1rg{font-size:12px;color:var(--text-muted);margin-bottom:4px}.interval-value.svelte-lbb1rg.svelte-lbb1rg{font-size:16px;font-weight:600;color:var(--text-normal)}.modal-actions.svelte-lbb1rg.svelte-lbb1rg{display:flex;justify-content:flex-end;gap:8px;margin-top:24px;padding:16px 20px;border-top:1px solid var(--background-modifier-border);background:var(--background-primary);position:sticky;bottom:0;margin-left:-20px;margin-right:-20px}.close-button.svelte-lbb1rg.svelte-lbb1rg{padding:8px 16px;background:var(--interactive-accent);color:var(--text-on-accent);border:none;border-radius:4px;cursor:pointer;font-weight:500}.close-button.svelte-lbb1rg.svelte-lbb1rg:hover{background:var(--interactive-accent-hover)}.forecast-bar.svelte-lbb1rg.svelte-lbb1rg{cursor:pointer;position:relative}.forecast-bar.svelte-lbb1rg:hover .bar.svelte-lbb1rg{opacity:0.8;transition:opacity 0.2s ease}.no-data-message.svelte-lbb1rg.svelte-lbb1rg{text-align:center;padding:24px;background:var(--background-secondary);border-radius:8px;border:1px solid var(--background-modifier-border)}.no-data-message.svelte-lbb1rg p.svelte-lbb1rg{margin:0 0 8px 0;color:var(--text-muted)}.help-text.svelte-lbb1rg.svelte-lbb1rg{font-size:12px !important;color:var(--text-faint) !important;margin:0 !important}.retry-button.svelte-lbb1rg.svelte-lbb1rg{margin-top:12px;padding:8px 16px;background:var(--interactive-accent);color:var(--text-on-accent);border:none;border-radius:4px;cursor:pointer;font-size:14px}.retry-button.svelte-lbb1rg.svelte-lbb1rg:hover{background:var(--interactive-accent-hover)}`);
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  child_ctx[34] = i;
  const constants_0 = (
    /*statistics*/
    child_ctx[2].forecast.indexOf(
      /*day*/
      child_ctx[31]
    )
  );
  child_ctx[32] = constants_0;
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[38] = list[i];
  return child_ctx;
}
function create_else_block3(ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
  let div2;
  let div0;
  let label0;
  let t1;
  let select0;
  let option0;
  let each0_anchor;
  let t3;
  let div1;
  let label1;
  let t5;
  let select1;
  let option1;
  let option2;
  let t8;
  let div16;
  let h30;
  let t10;
  let div15;
  let div5;
  let div3;
  let t11_value = (
    /*statistics*/
    (((_b = (_a = ctx[2]) == null ? void 0 : _a.cardStats) == null ? void 0 : _b.new) || 0) + ""
  );
  let t11;
  let t12;
  let div4;
  let t14;
  let div8;
  let div6;
  let t15_value = (
    /*statistics*/
    (((_d = (_c = ctx[2]) == null ? void 0 : _c.cardStats) == null ? void 0 : _d.learning) || 0) + ""
  );
  let t15;
  let t16;
  let div7;
  let t18;
  let div11;
  let div9;
  let t19_value = (
    /*statistics*/
    (((_f = (_e = ctx[2]) == null ? void 0 : _e.cardStats) == null ? void 0 : _f.mature) || 0) + ""
  );
  let t19;
  let t20;
  let div10;
  let t22;
  let div14;
  let div12;
  let t24;
  let div13;
  let t26;
  let div17;
  let h31;
  let t28;
  let t29;
  let div18;
  let h32;
  let t31;
  let t32;
  let h33;
  let t34;
  let t35;
  let h34;
  let t37;
  let t38;
  let div62;
  let h35;
  let t40;
  let div51;
  let div22;
  let div19;
  let t41_value = (
    /*statistics*/
    (((_g = ctx[2]) == null ? void 0 : _g.retentionRate) || 0).toFixed(1) + ""
  );
  let t41;
  let t42;
  let t43;
  let div20;
  let t45;
  let div21;
  let t47;
  let div26;
  let div23;
  let t49;
  let div24;
  let t51;
  let div25;
  let t53;
  let div30;
  let div27;
  let t56;
  let div28;
  let t58;
  let div29;
  let t60;
  let div34;
  let div31;
  let t62;
  let div32;
  let t64;
  let div33;
  let t66;
  let div38;
  let div35;
  let t68;
  let div36;
  let t70;
  let div37;
  let t72;
  let div42;
  let div39;
  let t73_value = (
    /*statistics*/
    (((_i = (_h = ctx[2]) == null ? void 0 : _h.cardStats) == null ? void 0 : _i.learning) || 0) + ""
  );
  let t73;
  let t74;
  let div40;
  let t76;
  let div41;
  let t78;
  let div46;
  let div43;
  let t81;
  let div44;
  let t83;
  let div45;
  let t85;
  let div50;
  let div47;
  let t86_value = (
    /*statistics*/
    (((_k = (_j = ctx[2]) == null ? void 0 : _j.cardStats) == null ? void 0 : _k.new) || 0) + /*statistics*/
    (((_m = (_l = ctx[2]) == null ? void 0 : _l.cardStats) == null ? void 0 : _m.learning) || 0) + /*statistics*/
    (((_o = (_n = ctx[2]) == null ? void 0 : _n.cardStats) == null ? void 0 : _o.mature) || 0) + ""
  );
  let t86;
  let t87;
  let div48;
  let t89;
  let div49;
  let t91;
  let h4;
  let t93;
  let div61;
  let div54;
  let div52;
  let t94_value = (
    /*statistics*/
    (((_q = (_p = ctx[2]) == null ? void 0 : _p.cardStats) == null ? void 0 : _q.new) || 0) + ""
  );
  let t94;
  let t95;
  let div53;
  let t97;
  let div57;
  let div55;
  let t98_value = (
    /*statistics*/
    (((_s = (_r = ctx[2]) == null ? void 0 : _r.cardStats) == null ? void 0 : _s.learning) || 0) + ""
  );
  let t98;
  let t99;
  let div56;
  let t101;
  let div60;
  let div58;
  let t102_value = (
    /*statistics*/
    (((_u = (_t = ctx[2]) == null ? void 0 : _t.cardStats) == null ? void 0 : _u.mature) || 0) + ""
  );
  let t102;
  let t103;
  let div59;
  let t105;
  let div63;
  let h36;
  let t107;
  let t108;
  let div64;
  let h37;
  let t110;
  let show_if;
  let t111;
  let div65;
  let h38;
  let t113;
  let t114;
  let div66;
  let h39;
  let t116;
  let p;
  let t118;
  let reviewheatmap;
  let t119;
  let div67;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value_3 = (
    /*availableTags*/
    ctx[6]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = (
    /*availableDecks*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  function select_block_type_1(ctx2, dirty) {
    if (
      /*todayStats*/
      ctx2[11]
    )
      return create_if_block_10;
    return create_else_block_8;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (
      /*weekStats*/
      ctx2[10] && /*weekStats*/
      ctx2[10].reviews > 0
    )
      return create_if_block_9;
    return create_else_block_7;
  }
  let current_block_type_1 = select_block_type_2(ctx, [-1, -1]);
  let if_block1 = current_block_type_1(ctx);
  function select_block_type_3(ctx2, dirty) {
    if (
      /*monthStats*/
      ctx2[9] && /*monthStats*/
      ctx2[9].reviews > 0
    )
      return create_if_block_8;
    return create_else_block_6;
  }
  let current_block_type_2 = select_block_type_3(ctx, [-1, -1]);
  let if_block2 = current_block_type_2(ctx);
  function select_block_type_4(ctx2, dirty) {
    if (
      /*yearStats*/
      ctx2[8] && /*yearStats*/
      ctx2[8].reviews > 0
    )
      return create_if_block_7;
    return create_else_block_5;
  }
  let current_block_type_3 = select_block_type_4(ctx, [-1, -1]);
  let if_block3 = current_block_type_3(ctx);
  function select_block_type_5(ctx2, dirty) {
    var _a2;
    if (
      /*statistics*/
      ((_a2 = ctx2[2]) == null ? void 0 : _a2.answerButtons) && /*statistics*/
      (ctx2[2].answerButtons.again > 0 || /*statistics*/
      ctx2[2].answerButtons.hard > 0 || /*statistics*/
      ctx2[2].answerButtons.good > 0 || /*statistics*/
      ctx2[2].answerButtons.easy > 0)
    )
      return create_if_block_6;
    return create_else_block_4;
  }
  let current_block_type_4 = select_block_type_5(ctx, [-1, -1]);
  let if_block4 = current_block_type_4(ctx);
  function select_block_type_6(ctx2, dirty) {
    var _a2;
    if (dirty[0] & /*statistics*/
    4)
      show_if = null;
    if (show_if == null)
      show_if = !!/*statistics*/
      (((_a2 = ctx2[2]) == null ? void 0 : _a2.forecast) && /*statistics*/
      ctx2[2].forecast.length > 0 && /*statistics*/
      ctx2[2].forecast.some(func2));
    if (show_if)
      return create_if_block_32;
    return create_else_block_3;
  }
  let current_block_type_5 = select_block_type_6(ctx, [-1, -1]);
  let if_block5 = current_block_type_5(ctx);
  function select_block_type_8(ctx2, dirty) {
    var _a2;
    if (
      /*statistics*/
      ((_a2 = ctx2[2]) == null ? void 0 : _a2.intervals) && /*statistics*/
      ctx2[2].intervals.length > 0
    )
      return create_if_block_22;
    return create_else_block_1;
  }
  let current_block_type_6 = select_block_type_8(ctx, [-1, -1]);
  let if_block6 = current_block_type_6(ctx);
  let reviewheatmap_props = { getReviewCounts: (
    /*func_2*/
    ctx[22]
  ) };
  reviewheatmap = new ReviewHeatmap_default({ props: reviewheatmap_props });
  ctx[23](reviewheatmap);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Show data for:";
      t1 = space();
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "All Decks";
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Timeframe:";
      t5 = space();
      select1 = element("select");
      option1 = element("option");
      option1.textContent = "Last 12 Months";
      option2 = element("option");
      option2.textContent = "All History";
      t8 = space();
      div16 = element("div");
      h30 = element("h3");
      h30.textContent = "Current Status";
      t10 = space();
      div15 = element("div");
      div5 = element("div");
      div3 = element("div");
      t11 = text(t11_value);
      t12 = space();
      div4 = element("div");
      div4.textContent = "New Cards";
      t14 = space();
      div8 = element("div");
      div6 = element("div");
      t15 = text(t15_value);
      t16 = space();
      div7 = element("div");
      div7.textContent = "Learning";
      t18 = space();
      div11 = element("div");
      div9 = element("div");
      t19 = text(t19_value);
      t20 = space();
      div10 = element("div");
      div10.textContent = "Mature";
      t22 = space();
      div14 = element("div");
      div12 = element("div");
      div12.textContent = `${/*getDueToday*/
      ctx[17]()}`;
      t24 = space();
      div13 = element("div");
      div13.textContent = "Due Today";
      t26 = space();
      div17 = element("div");
      h31 = element("h3");
      h31.textContent = "Today's Statistics";
      t28 = space();
      if_block0.c();
      t29 = space();
      div18 = element("div");
      h32 = element("h3");
      h32.textContent = "This Week";
      t31 = space();
      if_block1.c();
      t32 = space();
      h33 = element("h3");
      h33.textContent = "This Month";
      t34 = space();
      if_block2.c();
      t35 = space();
      h34 = element("h3");
      h34.textContent = "This Year";
      t37 = space();
      if_block3.c();
      t38 = space();
      div62 = element("div");
      h35 = element("h3");
      h35.textContent = "Deck Statistics & Metrics";
      t40 = space();
      div51 = element("div");
      div22 = element("div");
      div19 = element("div");
      t41 = text(t41_value);
      t42 = text("%");
      t43 = space();
      div20 = element("div");
      div20.textContent = "Retention Rate";
      t45 = space();
      div21 = element("div");
      div21.textContent = '% of reviews answered correctly (excluding "Again")';
      t47 = space();
      div26 = element("div");
      div23 = element("div");
      div23.textContent = `${/*calculateAverageEase*/
      ctx[15]()}`;
      t49 = space();
      div24 = element("div");
      div24.textContent = "Average Ease";
      t51 = space();
      div25 = element("div");
      div25.textContent = "Mean of ease button values";
      t53 = space();
      div30 = element("div");
      div27 = element("div");
      div27.textContent = `${/*calculateAverageInterval*/
      ctx[16]()}d`;
      t56 = space();
      div28 = element("div");
      div28.textContent = "Avg Interval";
      t58 = space();
      div29 = element("div");
      div29.textContent = "Mean interval of all review cards";
      t60 = space();
      div34 = element("div");
      div31 = element("div");
      div31.textContent = `${/*getDueToday*/
      ctx[17]()}`;
      t62 = space();
      div32 = element("div");
      div32.textContent = "Due Today";
      t64 = space();
      div33 = element("div");
      div33.textContent = "Number of cards due today";
      t66 = space();
      div38 = element("div");
      div35 = element("div");
      div35.textContent = `${/*getDueTomorrow*/
      ctx[18]()}`;
      t68 = space();
      div36 = element("div");
      div36.textContent = "Due Tomorrow";
      t70 = space();
      div37 = element("div");
      div37.textContent = "Number of cards due tomorrow";
      t72 = space();
      div42 = element("div");
      div39 = element("div");
      t73 = text(t73_value);
      t74 = space();
      div40 = element("div");
      div40.textContent = "Learning Cards";
      t76 = space();
      div41 = element("div");
      div41.textContent = "Number of cards in the learning queue";
      t78 = space();
      div46 = element("div");
      div43 = element("div");
      div43.textContent = `${/*getMaturityRatio*/
      ctx[19]()}%`;
      t81 = space();
      div44 = element("div");
      div44.textContent = "Maturity Ratio";
      t83 = space();
      div45 = element("div");
      div45.textContent = "Mature cards \xF7 total cards";
      t85 = space();
      div50 = element("div");
      div47 = element("div");
      t86 = text(t86_value);
      t87 = space();
      div48 = element("div");
      div48.textContent = "Total Cards";
      t89 = space();
      div49 = element("div");
      div49.textContent = "All cards in collection";
      t91 = space();
      h4 = element("h4");
      h4.textContent = "Card Status Breakdown";
      t93 = space();
      div61 = element("div");
      div54 = element("div");
      div52 = element("div");
      t94 = text(t94_value);
      t95 = space();
      div53 = element("div");
      div53.textContent = "New Cards";
      t97 = space();
      div57 = element("div");
      div55 = element("div");
      t98 = text(t98_value);
      t99 = space();
      div56 = element("div");
      div56.textContent = "Learning";
      t101 = space();
      div60 = element("div");
      div58 = element("div");
      t102 = text(t102_value);
      t103 = space();
      div59 = element("div");
      div59.textContent = "Mature";
      t105 = space();
      div63 = element("div");
      h36 = element("h3");
      h36.textContent = "Answer Button Usage";
      t107 = space();
      if_block4.c();
      t108 = space();
      div64 = element("div");
      h37 = element("h3");
      h37.textContent = "Review Load Forecast";
      t110 = space();
      if_block5.c();
      t111 = space();
      div65 = element("div");
      h38 = element("h3");
      h38.textContent = "Card Interval Distribution";
      t113 = space();
      if_block6.c();
      t114 = space();
      div66 = element("div");
      h39 = element("h3");
      h39.textContent = "Review Heatmap";
      t116 = space();
      p = element("p");
      p.textContent = "Daily review activity over time";
      t118 = space();
      create_component(reviewheatmap.$$.fragment);
      t119 = space();
      div67 = element("div");
      button = element("button");
      button.textContent = "Close";
      attr(label0, "for", "deck-filter");
      attr(label0, "class", "svelte-lbb1rg");
      option0.__value = "all";
      option0.value = option0.__value;
      attr(option0, "class", "svelte-lbb1rg");
      attr(select0, "id", "deck-filter");
      attr(select0, "class", "svelte-lbb1rg");
      if (
        /*selectedDeckFilter*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[20].call(select0)
        ));
      attr(div0, "class", "filter-group svelte-lbb1rg");
      attr(label1, "for", "timeframe-filter");
      attr(label1, "class", "svelte-lbb1rg");
      option1.__value = "12months";
      option1.value = option1.__value;
      attr(option1, "class", "svelte-lbb1rg");
      option2.__value = "all";
      option2.value = option2.__value;
      attr(option2, "class", "svelte-lbb1rg");
      attr(select1, "id", "timeframe-filter");
      attr(select1, "class", "svelte-lbb1rg");
      if (
        /*selectedTimeframe*/
        ctx[4] === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[21].call(select1)
        ));
      attr(div1, "class", "filter-group svelte-lbb1rg");
      attr(div2, "class", "filters svelte-lbb1rg");
      attr(h30, "class", "svelte-lbb1rg");
      attr(div3, "class", "stat-value svelte-lbb1rg");
      attr(div4, "class", "stat-label svelte-lbb1rg");
      attr(div5, "class", "stat-card svelte-lbb1rg");
      attr(div6, "class", "stat-value svelte-lbb1rg");
      attr(div7, "class", "stat-label svelte-lbb1rg");
      attr(div8, "class", "stat-card svelte-lbb1rg");
      attr(div9, "class", "stat-value svelte-lbb1rg");
      attr(div10, "class", "stat-label svelte-lbb1rg");
      attr(div11, "class", "stat-card svelte-lbb1rg");
      attr(div12, "class", "stat-value svelte-lbb1rg");
      attr(div13, "class", "stat-label svelte-lbb1rg");
      attr(div14, "class", "stat-card svelte-lbb1rg");
      attr(div15, "class", "stats-grid svelte-lbb1rg");
      attr(div16, "class", "stats-section svelte-lbb1rg");
      attr(h31, "class", "svelte-lbb1rg");
      attr(div17, "class", "stats-section svelte-lbb1rg");
      attr(h32, "class", "svelte-lbb1rg");
      attr(h33, "class", "svelte-lbb1rg");
      attr(h34, "class", "svelte-lbb1rg");
      attr(div18, "class", "stats-section svelte-lbb1rg");
      attr(h35, "class", "svelte-lbb1rg");
      attr(div19, "class", "metric-value svelte-lbb1rg");
      attr(div20, "class", "metric-label svelte-lbb1rg");
      attr(div21, "class", "metric-description svelte-lbb1rg");
      attr(div22, "class", "metric-card svelte-lbb1rg");
      attr(div23, "class", "metric-value svelte-lbb1rg");
      attr(div24, "class", "metric-label svelte-lbb1rg");
      attr(div25, "class", "metric-description svelte-lbb1rg");
      attr(div26, "class", "metric-card svelte-lbb1rg");
      attr(div27, "class", "metric-value svelte-lbb1rg");
      attr(div28, "class", "metric-label svelte-lbb1rg");
      attr(div29, "class", "metric-description svelte-lbb1rg");
      attr(div30, "class", "metric-card svelte-lbb1rg");
      attr(div31, "class", "metric-value svelte-lbb1rg");
      attr(div32, "class", "metric-label svelte-lbb1rg");
      attr(div33, "class", "metric-description svelte-lbb1rg");
      attr(div34, "class", "metric-card svelte-lbb1rg");
      attr(div35, "class", "metric-value svelte-lbb1rg");
      attr(div36, "class", "metric-label svelte-lbb1rg");
      attr(div37, "class", "metric-description svelte-lbb1rg");
      attr(div38, "class", "metric-card svelte-lbb1rg");
      attr(div39, "class", "metric-value svelte-lbb1rg");
      attr(div40, "class", "metric-label svelte-lbb1rg");
      attr(div41, "class", "metric-description svelte-lbb1rg");
      attr(div42, "class", "metric-card svelte-lbb1rg");
      attr(div43, "class", "metric-value svelte-lbb1rg");
      attr(div44, "class", "metric-label svelte-lbb1rg");
      attr(div45, "class", "metric-description svelte-lbb1rg");
      attr(div46, "class", "metric-card svelte-lbb1rg");
      attr(div47, "class", "metric-value svelte-lbb1rg");
      attr(div48, "class", "metric-label svelte-lbb1rg");
      attr(div49, "class", "metric-description svelte-lbb1rg");
      attr(div50, "class", "metric-card svelte-lbb1rg");
      attr(div51, "class", "metrics-grid svelte-lbb1rg");
      attr(h4, "class", "svelte-lbb1rg");
      attr(div52, "class", "stat-value svelte-lbb1rg");
      attr(div53, "class", "stat-label svelte-lbb1rg");
      attr(div54, "class", "stat-card svelte-lbb1rg");
      attr(div55, "class", "stat-value svelte-lbb1rg");
      attr(div56, "class", "stat-label svelte-lbb1rg");
      attr(div57, "class", "stat-card svelte-lbb1rg");
      attr(div58, "class", "stat-value svelte-lbb1rg");
      attr(div59, "class", "stat-label svelte-lbb1rg");
      attr(div60, "class", "stat-card svelte-lbb1rg");
      attr(div61, "class", "stats-grid svelte-lbb1rg");
      attr(div62, "class", "stats-section svelte-lbb1rg");
      attr(h36, "class", "svelte-lbb1rg");
      attr(div63, "class", "stats-section svelte-lbb1rg");
      attr(h37, "class", "svelte-lbb1rg");
      attr(div64, "class", "stats-section svelte-lbb1rg");
      attr(h38, "class", "svelte-lbb1rg");
      attr(div65, "class", "stats-section svelte-lbb1rg");
      attr(h39, "class", "svelte-lbb1rg");
      attr(div66, "class", "stats-section svelte-lbb1rg");
      attr(button, "class", "close-button svelte-lbb1rg");
      attr(div67, "class", "modal-actions svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, select0);
      append(select0, option0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      append(select0, each0_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*selectedDeckFilter*/
        ctx[3],
        true
      );
      append(div2, t3);
      append(div2, div1);
      append(div1, label1);
      append(div1, t5);
      append(div1, select1);
      append(select1, option1);
      append(select1, option2);
      select_option(
        select1,
        /*selectedTimeframe*/
        ctx[4],
        true
      );
      insert(target, t8, anchor);
      insert(target, div16, anchor);
      append(div16, h30);
      append(div16, t10);
      append(div16, div15);
      append(div15, div5);
      append(div5, div3);
      append(div3, t11);
      append(div5, t12);
      append(div5, div4);
      append(div15, t14);
      append(div15, div8);
      append(div8, div6);
      append(div6, t15);
      append(div8, t16);
      append(div8, div7);
      append(div15, t18);
      append(div15, div11);
      append(div11, div9);
      append(div9, t19);
      append(div11, t20);
      append(div11, div10);
      append(div15, t22);
      append(div15, div14);
      append(div14, div12);
      append(div14, t24);
      append(div14, div13);
      insert(target, t26, anchor);
      insert(target, div17, anchor);
      append(div17, h31);
      append(div17, t28);
      if_block0.m(div17, null);
      insert(target, t29, anchor);
      insert(target, div18, anchor);
      append(div18, h32);
      append(div18, t31);
      if_block1.m(div18, null);
      append(div18, t32);
      append(div18, h33);
      append(div18, t34);
      if_block2.m(div18, null);
      append(div18, t35);
      append(div18, h34);
      append(div18, t37);
      if_block3.m(div18, null);
      insert(target, t38, anchor);
      insert(target, div62, anchor);
      append(div62, h35);
      append(div62, t40);
      append(div62, div51);
      append(div51, div22);
      append(div22, div19);
      append(div19, t41);
      append(div19, t42);
      append(div22, t43);
      append(div22, div20);
      append(div22, t45);
      append(div22, div21);
      append(div51, t47);
      append(div51, div26);
      append(div26, div23);
      append(div26, t49);
      append(div26, div24);
      append(div26, t51);
      append(div26, div25);
      append(div51, t53);
      append(div51, div30);
      append(div30, div27);
      append(div30, t56);
      append(div30, div28);
      append(div30, t58);
      append(div30, div29);
      append(div51, t60);
      append(div51, div34);
      append(div34, div31);
      append(div34, t62);
      append(div34, div32);
      append(div34, t64);
      append(div34, div33);
      append(div51, t66);
      append(div51, div38);
      append(div38, div35);
      append(div38, t68);
      append(div38, div36);
      append(div38, t70);
      append(div38, div37);
      append(div51, t72);
      append(div51, div42);
      append(div42, div39);
      append(div39, t73);
      append(div42, t74);
      append(div42, div40);
      append(div42, t76);
      append(div42, div41);
      append(div51, t78);
      append(div51, div46);
      append(div46, div43);
      append(div46, t81);
      append(div46, div44);
      append(div46, t83);
      append(div46, div45);
      append(div51, t85);
      append(div51, div50);
      append(div50, div47);
      append(div47, t86);
      append(div50, t87);
      append(div50, div48);
      append(div50, t89);
      append(div50, div49);
      append(div62, t91);
      append(div62, h4);
      append(div62, t93);
      append(div62, div61);
      append(div61, div54);
      append(div54, div52);
      append(div52, t94);
      append(div54, t95);
      append(div54, div53);
      append(div61, t97);
      append(div61, div57);
      append(div57, div55);
      append(div55, t98);
      append(div57, t99);
      append(div57, div56);
      append(div61, t101);
      append(div61, div60);
      append(div60, div58);
      append(div58, t102);
      append(div60, t103);
      append(div60, div59);
      insert(target, t105, anchor);
      insert(target, div63, anchor);
      append(div63, h36);
      append(div63, t107);
      if_block4.m(div63, null);
      insert(target, t108, anchor);
      insert(target, div64, anchor);
      append(div64, h37);
      append(div64, t110);
      if_block5.m(div64, null);
      insert(target, t111, anchor);
      insert(target, div65, anchor);
      append(div65, h38);
      append(div65, t113);
      if_block6.m(div65, null);
      insert(target, t114, anchor);
      insert(target, div66, anchor);
      append(div66, h39);
      append(div66, t116);
      append(div66, p);
      append(div66, t118);
      mount_component(reviewheatmap, div66, null);
      insert(target, t119, anchor);
      insert(target, div67, anchor);
      append(div67, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[20]
          ),
          listen(
            select0,
            "change",
            /*handleFilterChange*/
            ctx[14]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[21]
          ),
          listen(
            select1,
            "change",
            /*handleFilterChange*/
            ctx[14]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r2, _s2, _t2, _u2;
      if (dirty[0] & /*availableTags*/
      64) {
        each_value_3 = /*availableTags*/
        ctx2[6];
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select0, each0_anchor);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty[0] & /*availableDecks*/
      32) {
        each_value_2 = /*availableDecks*/
        ctx2[5];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_22(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & /*selectedDeckFilter, availableDecks, availableTags*/
      104) {
        select_option(
          select0,
          /*selectedDeckFilter*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*selectedTimeframe*/
      16) {
        select_option(
          select1,
          /*selectedTimeframe*/
          ctx2[4]
        );
      }
      if ((!current || dirty[0] & /*statistics*/
      4) && t11_value !== (t11_value = /*statistics*/
      (((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.cardStats) == null ? void 0 : _b2.new) || 0) + ""))
        set_data(t11, t11_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t15_value !== (t15_value = /*statistics*/
      (((_d2 = (_c2 = ctx2[2]) == null ? void 0 : _c2.cardStats) == null ? void 0 : _d2.learning) || 0) + ""))
        set_data(t15, t15_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t19_value !== (t19_value = /*statistics*/
      (((_f2 = (_e2 = ctx2[2]) == null ? void 0 : _e2.cardStats) == null ? void 0 : _f2.mature) || 0) + ""))
        set_data(t19, t19_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div17, null);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div18, t32);
        }
      }
      if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type_2(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div18, t35);
        }
      }
      if (current_block_type_3 === (current_block_type_3 = select_block_type_4(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type_3(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div18, null);
        }
      }
      if ((!current || dirty[0] & /*statistics*/
      4) && t41_value !== (t41_value = /*statistics*/
      (((_g2 = ctx2[2]) == null ? void 0 : _g2.retentionRate) || 0).toFixed(1) + ""))
        set_data(t41, t41_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t73_value !== (t73_value = /*statistics*/
      (((_i2 = (_h2 = ctx2[2]) == null ? void 0 : _h2.cardStats) == null ? void 0 : _i2.learning) || 0) + ""))
        set_data(t73, t73_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t86_value !== (t86_value = /*statistics*/
      (((_k2 = (_j2 = ctx2[2]) == null ? void 0 : _j2.cardStats) == null ? void 0 : _k2.new) || 0) + /*statistics*/
      (((_m2 = (_l2 = ctx2[2]) == null ? void 0 : _l2.cardStats) == null ? void 0 : _m2.learning) || 0) + /*statistics*/
      (((_o2 = (_n2 = ctx2[2]) == null ? void 0 : _n2.cardStats) == null ? void 0 : _o2.mature) || 0) + ""))
        set_data(t86, t86_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t94_value !== (t94_value = /*statistics*/
      (((_q2 = (_p2 = ctx2[2]) == null ? void 0 : _p2.cardStats) == null ? void 0 : _q2.new) || 0) + ""))
        set_data(t94, t94_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t98_value !== (t98_value = /*statistics*/
      (((_s2 = (_r2 = ctx2[2]) == null ? void 0 : _r2.cardStats) == null ? void 0 : _s2.learning) || 0) + ""))
        set_data(t98, t98_value);
      if ((!current || dirty[0] & /*statistics*/
      4) && t102_value !== (t102_value = /*statistics*/
      (((_u2 = (_t2 = ctx2[2]) == null ? void 0 : _t2.cardStats) == null ? void 0 : _u2.mature) || 0) + ""))
        set_data(t102, t102_value);
      if (current_block_type_4 === (current_block_type_4 = select_block_type_5(ctx2, dirty)) && if_block4) {
        if_block4.p(ctx2, dirty);
      } else {
        if_block4.d(1);
        if_block4 = current_block_type_4(ctx2);
        if (if_block4) {
          if_block4.c();
          if_block4.m(div63, null);
        }
      }
      if (current_block_type_5 === (current_block_type_5 = select_block_type_6(ctx2, dirty)) && if_block5) {
        if_block5.p(ctx2, dirty);
      } else {
        if_block5.d(1);
        if_block5 = current_block_type_5(ctx2);
        if (if_block5) {
          if_block5.c();
          if_block5.m(div64, null);
        }
      }
      if (current_block_type_6 === (current_block_type_6 = select_block_type_8(ctx2, dirty)) && if_block6) {
        if_block6.p(ctx2, dirty);
      } else {
        if_block6.d(1);
        if_block6 = current_block_type_6(ctx2);
        if (if_block6) {
          if_block6.c();
          if_block6.m(div65, null);
        }
      }
      const reviewheatmap_changes = {};
      if (dirty[0] & /*plugin*/
      1)
        reviewheatmap_changes.getReviewCounts = /*func_2*/
        ctx2[22];
      reviewheatmap.$set(reviewheatmap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(reviewheatmap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(reviewheatmap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(div16);
      if (detaching)
        detach(t26);
      if (detaching)
        detach(div17);
      if_block0.d();
      if (detaching)
        detach(t29);
      if (detaching)
        detach(div18);
      if_block1.d();
      if_block2.d();
      if_block3.d();
      if (detaching)
        detach(t38);
      if (detaching)
        detach(div62);
      if (detaching)
        detach(t105);
      if (detaching)
        detach(div63);
      if_block4.d();
      if (detaching)
        detach(t108);
      if (detaching)
        detach(div64);
      if_block5.d();
      if (detaching)
        detach(t111);
      if (detaching)
        detach(div65);
      if_block6.d();
      if (detaching)
        detach(t114);
      if (detaching)
        detach(div66);
      ctx[23](null);
      destroy_component(reviewheatmap);
      if (detaching)
        detach(t119);
      if (detaching)
        detach(div67);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  let p;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = "Failed to load statistics";
      t1 = space();
      button = element("button");
      button.textContent = "Retry";
      attr(button, "class", "retry-button svelte-lbb1rg");
      attr(div, "class", "error svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*loadStatistics*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Loading statistics...";
      attr(div, "class", "loading svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_3(ctx) {
  let option;
  let t0;
  let t1_value = (
    /*tag*/
    ctx[38] + ""
  );
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text("Tag: ");
      t1 = text(t1_value);
      option.__value = option_value_value = "tag:" + /*tag*/
      ctx[38];
      option.value = option.__value;
      attr(option, "class", "svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*availableTags*/
      64 && t1_value !== (t1_value = /*tag*/
      ctx2[38] + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*availableTags*/
      64 && option_value_value !== (option_value_value = "tag:" + /*tag*/
      ctx2[38])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_22(ctx) {
  let option;
  let t_value = (
    /*deck*/
    ctx[35].name + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = "deck:" + /*deck*/
      ctx[35].id;
      option.value = option.__value;
      attr(option, "class", "svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*availableDecks*/
      32 && t_value !== (t_value = /*deck*/
      ctx2[35].name + ""))
        set_data(t, t_value);
      if (dirty[0] & /*availableDecks*/
      32 && option_value_value !== (option_value_value = "deck:" + /*deck*/
      ctx2[35].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block_8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No reviews today yet.</p> 
                    <p class="help-text svelte-lbb1rg">Start reviewing flashcards to see your daily statistics
                        here!</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_10(ctx) {
  let div6;
  let div2;
  let div0;
  let t0_value = (
    /*todayStats*/
    ctx[11].reviews + ""
  );
  let t0;
  let t1;
  let div1;
  let t3;
  let div5;
  let div3;
  let t4_value = formatTime(
    /*todayStats*/
    ctx[11].timeSpent
  ) + "";
  let t4;
  let t5;
  let div4;
  let t7;
  let h4;
  let t9;
  let div16;
  let div9;
  let div7;
  let t10_value = (
    /*todayStats*/
    ctx[11].newCards + ""
  );
  let t10;
  let t11;
  let div8;
  let t13;
  let div12;
  let div10;
  let t14_value = (
    /*todayStats*/
    ctx[11].learningCards + ""
  );
  let t14;
  let t15;
  let div11;
  let t17;
  let div15;
  let div13;
  let t18_value = (
    /*todayStats*/
    ctx[11].reviewCards + ""
  );
  let t18;
  let t19;
  let div14;
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      div1.textContent = "Cards Studied";
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      div4.textContent = "Time Spent";
      t7 = space();
      h4 = element("h4");
      h4.textContent = "Breakdown by Card Type";
      t9 = space();
      div16 = element("div");
      div9 = element("div");
      div7 = element("div");
      t10 = text(t10_value);
      t11 = space();
      div8 = element("div");
      div8.textContent = "New Cards";
      t13 = space();
      div12 = element("div");
      div10 = element("div");
      t14 = text(t14_value);
      t15 = space();
      div11 = element("div");
      div11.textContent = "Learning";
      t17 = space();
      div15 = element("div");
      div13 = element("div");
      t18 = text(t18_value);
      t19 = space();
      div14 = element("div");
      div14.textContent = "Review";
      attr(div0, "class", "stat-value svelte-lbb1rg");
      attr(div1, "class", "stat-label svelte-lbb1rg");
      attr(div2, "class", "stat-card svelte-lbb1rg");
      attr(div3, "class", "stat-value svelte-lbb1rg");
      attr(div4, "class", "stat-label svelte-lbb1rg");
      attr(div5, "class", "stat-card svelte-lbb1rg");
      attr(div6, "class", "stats-grid svelte-lbb1rg");
      attr(h4, "class", "svelte-lbb1rg");
      attr(div7, "class", "stat-value svelte-lbb1rg");
      attr(div8, "class", "stat-label svelte-lbb1rg");
      attr(div9, "class", "stat-card svelte-lbb1rg");
      attr(div10, "class", "stat-value svelte-lbb1rg");
      attr(div11, "class", "stat-label svelte-lbb1rg");
      attr(div12, "class", "stat-card svelte-lbb1rg");
      attr(div13, "class", "stat-value svelte-lbb1rg");
      attr(div14, "class", "stat-label svelte-lbb1rg");
      attr(div15, "class", "stat-card svelte-lbb1rg");
      attr(div16, "class", "stats-grid svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div6, t3);
      append(div6, div5);
      append(div5, div3);
      append(div3, t4);
      append(div5, t5);
      append(div5, div4);
      insert(target, t7, anchor);
      insert(target, h4, anchor);
      insert(target, t9, anchor);
      insert(target, div16, anchor);
      append(div16, div9);
      append(div9, div7);
      append(div7, t10);
      append(div9, t11);
      append(div9, div8);
      append(div16, t13);
      append(div16, div12);
      append(div12, div10);
      append(div10, t14);
      append(div12, t15);
      append(div12, div11);
      append(div16, t17);
      append(div16, div15);
      append(div15, div13);
      append(div13, t18);
      append(div15, t19);
      append(div15, div14);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*todayStats*/
      2048 && t0_value !== (t0_value = /*todayStats*/
      ctx2[11].reviews + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*todayStats*/
      2048 && t4_value !== (t4_value = formatTime(
        /*todayStats*/
        ctx2[11].timeSpent
      ) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & /*todayStats*/
      2048 && t10_value !== (t10_value = /*todayStats*/
      ctx2[11].newCards + ""))
        set_data(t10, t10_value);
      if (dirty[0] & /*todayStats*/
      2048 && t14_value !== (t14_value = /*todayStats*/
      ctx2[11].learningCards + ""))
        set_data(t14, t14_value);
      if (dirty[0] & /*todayStats*/
      2048 && t18_value !== (t18_value = /*todayStats*/
      ctx2[11].reviewCards + ""))
        set_data(t18, t18_value);
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(h4);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(div16);
    }
  };
}
function create_else_block_7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No reviews this week yet.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_9(ctx) {
  let div9;
  let div2;
  let div0;
  let t0_value = (
    /*weekStats*/
    ctx[10].reviews + ""
  );
  let t0;
  let t1;
  let div1;
  let t3;
  let div5;
  let div3;
  let t4_value = formatTime(
    /*weekStats*/
    ctx[10].timeSpent
  ) + "";
  let t4;
  let t5;
  let div4;
  let t7;
  let div8;
  let div6;
  let t8_value = (
    /*weekStats*/
    ctx[10].correctRate.toFixed(1) + ""
  );
  let t8;
  let t9;
  let t10;
  let div7;
  return {
    c() {
      div9 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      div1.textContent = "Cards Studied";
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      div4.textContent = "Time Spent";
      t7 = space();
      div8 = element("div");
      div6 = element("div");
      t8 = text(t8_value);
      t9 = text("%");
      t10 = space();
      div7 = element("div");
      div7.textContent = "Success Rate";
      attr(div0, "class", "stat-value svelte-lbb1rg");
      attr(div1, "class", "stat-label svelte-lbb1rg");
      attr(div2, "class", "stat-card svelte-lbb1rg");
      attr(div3, "class", "stat-value svelte-lbb1rg");
      attr(div4, "class", "stat-label svelte-lbb1rg");
      attr(div5, "class", "stat-card svelte-lbb1rg");
      attr(div6, "class", "stat-value svelte-lbb1rg");
      attr(div7, "class", "stat-label svelte-lbb1rg");
      attr(div8, "class", "stat-card svelte-lbb1rg");
      attr(div9, "class", "stats-grid svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div9, t3);
      append(div9, div5);
      append(div5, div3);
      append(div3, t4);
      append(div5, t5);
      append(div5, div4);
      append(div9, t7);
      append(div9, div8);
      append(div8, div6);
      append(div6, t8);
      append(div6, t9);
      append(div8, t10);
      append(div8, div7);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*weekStats*/
      1024 && t0_value !== (t0_value = /*weekStats*/
      ctx2[10].reviews + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*weekStats*/
      1024 && t4_value !== (t4_value = formatTime(
        /*weekStats*/
        ctx2[10].timeSpent
      ) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & /*weekStats*/
      1024 && t8_value !== (t8_value = /*weekStats*/
      ctx2[10].correctRate.toFixed(1) + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(div9);
    }
  };
}
function create_else_block_6(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No reviews this month yet.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_8(ctx) {
  let div9;
  let div2;
  let div0;
  let t0_value = (
    /*monthStats*/
    ctx[9].reviews + ""
  );
  let t0;
  let t1;
  let div1;
  let t3;
  let div5;
  let div3;
  let t4_value = formatTime(
    /*monthStats*/
    ctx[9].timeSpent
  ) + "";
  let t4;
  let t5;
  let div4;
  let t7;
  let div8;
  let div6;
  let t8_value = (
    /*monthStats*/
    ctx[9].correctRate.toFixed(1) + ""
  );
  let t8;
  let t9;
  let t10;
  let div7;
  return {
    c() {
      div9 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      div1.textContent = "Cards Studied";
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      div4.textContent = "Time Spent";
      t7 = space();
      div8 = element("div");
      div6 = element("div");
      t8 = text(t8_value);
      t9 = text("%");
      t10 = space();
      div7 = element("div");
      div7.textContent = "Success Rate";
      attr(div0, "class", "stat-value svelte-lbb1rg");
      attr(div1, "class", "stat-label svelte-lbb1rg");
      attr(div2, "class", "stat-card svelte-lbb1rg");
      attr(div3, "class", "stat-value svelte-lbb1rg");
      attr(div4, "class", "stat-label svelte-lbb1rg");
      attr(div5, "class", "stat-card svelte-lbb1rg");
      attr(div6, "class", "stat-value svelte-lbb1rg");
      attr(div7, "class", "stat-label svelte-lbb1rg");
      attr(div8, "class", "stat-card svelte-lbb1rg");
      attr(div9, "class", "stats-grid svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div9, t3);
      append(div9, div5);
      append(div5, div3);
      append(div3, t4);
      append(div5, t5);
      append(div5, div4);
      append(div9, t7);
      append(div9, div8);
      append(div8, div6);
      append(div6, t8);
      append(div6, t9);
      append(div8, t10);
      append(div8, div7);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*monthStats*/
      512 && t0_value !== (t0_value = /*monthStats*/
      ctx2[9].reviews + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*monthStats*/
      512 && t4_value !== (t4_value = formatTime(
        /*monthStats*/
        ctx2[9].timeSpent
      ) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & /*monthStats*/
      512 && t8_value !== (t8_value = /*monthStats*/
      ctx2[9].correctRate.toFixed(1) + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(div9);
    }
  };
}
function create_else_block_5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No reviews this year yet.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_7(ctx) {
  let div9;
  let div2;
  let div0;
  let t0_value = (
    /*yearStats*/
    ctx[8].reviews + ""
  );
  let t0;
  let t1;
  let div1;
  let t3;
  let div5;
  let div3;
  let t4_value = formatTime(
    /*yearStats*/
    ctx[8].timeSpent
  ) + "";
  let t4;
  let t5;
  let div4;
  let t7;
  let div8;
  let div6;
  let t8_value = (
    /*yearStats*/
    ctx[8].correctRate.toFixed(1) + ""
  );
  let t8;
  let t9;
  let t10;
  let div7;
  return {
    c() {
      div9 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      div1.textContent = "Cards Studied";
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      div4.textContent = "Time Spent";
      t7 = space();
      div8 = element("div");
      div6 = element("div");
      t8 = text(t8_value);
      t9 = text("%");
      t10 = space();
      div7 = element("div");
      div7.textContent = "Success Rate";
      attr(div0, "class", "stat-value svelte-lbb1rg");
      attr(div1, "class", "stat-label svelte-lbb1rg");
      attr(div2, "class", "stat-card svelte-lbb1rg");
      attr(div3, "class", "stat-value svelte-lbb1rg");
      attr(div4, "class", "stat-label svelte-lbb1rg");
      attr(div5, "class", "stat-card svelte-lbb1rg");
      attr(div6, "class", "stat-value svelte-lbb1rg");
      attr(div7, "class", "stat-label svelte-lbb1rg");
      attr(div8, "class", "stat-card svelte-lbb1rg");
      attr(div9, "class", "stats-grid svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div9, t3);
      append(div9, div5);
      append(div5, div3);
      append(div3, t4);
      append(div5, t5);
      append(div5, div4);
      append(div9, t7);
      append(div9, div8);
      append(div8, div6);
      append(div6, t8);
      append(div6, t9);
      append(div8, t10);
      append(div8, div7);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*yearStats*/
      256 && t0_value !== (t0_value = /*yearStats*/
      ctx2[8].reviews + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*yearStats*/
      256 && t4_value !== (t4_value = formatTime(
        /*yearStats*/
        ctx2[8].timeSpent
      ) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & /*yearStats*/
      256 && t8_value !== (t8_value = /*yearStats*/
      ctx2[8].correctRate.toFixed(1) + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(div9);
    }
  };
}
function create_else_block_4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No answer button data available yet.</p> 
                    <p class="help-text svelte-lbb1rg">Complete some reviews to see answer button statistics.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6(ctx) {
  let div16;
  let div3;
  let div0;
  let t1;
  let div1;
  let t2_value = (
    /*statistics*/
    ctx[2].answerButtons.again + ""
  );
  let t2;
  let t3;
  let div2;
  let t4_value = (
    /*statistics*/
    (ctx[2].answerButtons.again / /*statistics*/
    (ctx[2].answerButtons.again + /*statistics*/
    ctx[2].answerButtons.hard + /*statistics*/
    ctx[2].answerButtons.good + /*statistics*/
    ctx[2].answerButtons.easy) * 100).toFixed(1) + ""
  );
  let t4;
  let t5;
  let t6;
  let div7;
  let div4;
  let t8;
  let div5;
  let t9_value = (
    /*statistics*/
    ctx[2].answerButtons.hard + ""
  );
  let t9;
  let t10;
  let div6;
  let t11_value = (
    /*statistics*/
    (ctx[2].answerButtons.hard / /*statistics*/
    (ctx[2].answerButtons.again + /*statistics*/
    ctx[2].answerButtons.hard + /*statistics*/
    ctx[2].answerButtons.good + /*statistics*/
    ctx[2].answerButtons.easy) * 100).toFixed(1) + ""
  );
  let t11;
  let t12;
  let t13;
  let div11;
  let div8;
  let t15;
  let div9;
  let t16_value = (
    /*statistics*/
    ctx[2].answerButtons.good + ""
  );
  let t16;
  let t17;
  let div10;
  let t18_value = (
    /*statistics*/
    (ctx[2].answerButtons.good / /*statistics*/
    (ctx[2].answerButtons.again + /*statistics*/
    ctx[2].answerButtons.hard + /*statistics*/
    ctx[2].answerButtons.good + /*statistics*/
    ctx[2].answerButtons.easy) * 100).toFixed(1) + ""
  );
  let t18;
  let t19;
  let t20;
  let div15;
  let div12;
  let t22;
  let div13;
  let t23_value = (
    /*statistics*/
    ctx[2].answerButtons.easy + ""
  );
  let t23;
  let t24;
  let div14;
  let t25_value = (
    /*statistics*/
    (ctx[2].answerButtons.easy / /*statistics*/
    (ctx[2].answerButtons.again + /*statistics*/
    ctx[2].answerButtons.hard + /*statistics*/
    ctx[2].answerButtons.good + /*statistics*/
    ctx[2].answerButtons.easy) * 100).toFixed(1) + ""
  );
  let t25;
  let t26;
  return {
    c() {
      div16 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.textContent = "Again";
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      t4 = text(t4_value);
      t5 = text("%");
      t6 = space();
      div7 = element("div");
      div4 = element("div");
      div4.textContent = "Hard";
      t8 = space();
      div5 = element("div");
      t9 = text(t9_value);
      t10 = space();
      div6 = element("div");
      t11 = text(t11_value);
      t12 = text("%");
      t13 = space();
      div11 = element("div");
      div8 = element("div");
      div8.textContent = "Good";
      t15 = space();
      div9 = element("div");
      t16 = text(t16_value);
      t17 = space();
      div10 = element("div");
      t18 = text(t18_value);
      t19 = text("%");
      t20 = space();
      div15 = element("div");
      div12 = element("div");
      div12.textContent = "Easy";
      t22 = space();
      div13 = element("div");
      t23 = text(t23_value);
      t24 = space();
      div14 = element("div");
      t25 = text(t25_value);
      t26 = text("%");
      attr(div0, "class", "button-label svelte-lbb1rg");
      attr(div1, "class", "button-count svelte-lbb1rg");
      attr(div2, "class", "button-percentage svelte-lbb1rg");
      attr(div3, "class", "button-bar again svelte-lbb1rg");
      attr(div4, "class", "button-label svelte-lbb1rg");
      attr(div5, "class", "button-count svelte-lbb1rg");
      attr(div6, "class", "button-percentage svelte-lbb1rg");
      attr(div7, "class", "button-bar hard svelte-lbb1rg");
      attr(div8, "class", "button-label svelte-lbb1rg");
      attr(div9, "class", "button-count svelte-lbb1rg");
      attr(div10, "class", "button-percentage svelte-lbb1rg");
      attr(div11, "class", "button-bar good svelte-lbb1rg");
      attr(div12, "class", "button-label svelte-lbb1rg");
      attr(div13, "class", "button-count svelte-lbb1rg");
      attr(div14, "class", "button-percentage svelte-lbb1rg");
      attr(div15, "class", "button-bar easy svelte-lbb1rg");
      attr(div16, "class", "button-stats svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div16, anchor);
      append(div16, div3);
      append(div3, div0);
      append(div3, t1);
      append(div3, div1);
      append(div1, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, t4);
      append(div2, t5);
      append(div16, t6);
      append(div16, div7);
      append(div7, div4);
      append(div7, t8);
      append(div7, div5);
      append(div5, t9);
      append(div7, t10);
      append(div7, div6);
      append(div6, t11);
      append(div6, t12);
      append(div16, t13);
      append(div16, div11);
      append(div11, div8);
      append(div11, t15);
      append(div11, div9);
      append(div9, t16);
      append(div11, t17);
      append(div11, div10);
      append(div10, t18);
      append(div10, t19);
      append(div16, t20);
      append(div16, div15);
      append(div15, div12);
      append(div15, t22);
      append(div15, div13);
      append(div13, t23);
      append(div15, t24);
      append(div15, div14);
      append(div14, t25);
      append(div14, t26);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4 && t2_value !== (t2_value = /*statistics*/
      ctx2[2].answerButtons.again + ""))
        set_data(t2, t2_value);
      if (dirty[0] & /*statistics*/
      4 && t4_value !== (t4_value = /*statistics*/
      (ctx2[2].answerButtons.again / /*statistics*/
      (ctx2[2].answerButtons.again + /*statistics*/
      ctx2[2].answerButtons.hard + /*statistics*/
      ctx2[2].answerButtons.good + /*statistics*/
      ctx2[2].answerButtons.easy) * 100).toFixed(1) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & /*statistics*/
      4 && t9_value !== (t9_value = /*statistics*/
      ctx2[2].answerButtons.hard + ""))
        set_data(t9, t9_value);
      if (dirty[0] & /*statistics*/
      4 && t11_value !== (t11_value = /*statistics*/
      (ctx2[2].answerButtons.hard / /*statistics*/
      (ctx2[2].answerButtons.again + /*statistics*/
      ctx2[2].answerButtons.hard + /*statistics*/
      ctx2[2].answerButtons.good + /*statistics*/
      ctx2[2].answerButtons.easy) * 100).toFixed(1) + ""))
        set_data(t11, t11_value);
      if (dirty[0] & /*statistics*/
      4 && t16_value !== (t16_value = /*statistics*/
      ctx2[2].answerButtons.good + ""))
        set_data(t16, t16_value);
      if (dirty[0] & /*statistics*/
      4 && t18_value !== (t18_value = /*statistics*/
      (ctx2[2].answerButtons.good / /*statistics*/
      (ctx2[2].answerButtons.again + /*statistics*/
      ctx2[2].answerButtons.hard + /*statistics*/
      ctx2[2].answerButtons.good + /*statistics*/
      ctx2[2].answerButtons.easy) * 100).toFixed(1) + ""))
        set_data(t18, t18_value);
      if (dirty[0] & /*statistics*/
      4 && t23_value !== (t23_value = /*statistics*/
      ctx2[2].answerButtons.easy + ""))
        set_data(t23, t23_value);
      if (dirty[0] & /*statistics*/
      4 && t25_value !== (t25_value = /*statistics*/
      (ctx2[2].answerButtons.easy / /*statistics*/
      (ctx2[2].answerButtons.again + /*statistics*/
      ctx2[2].answerButtons.hard + /*statistics*/
      ctx2[2].answerButtons.good + /*statistics*/
      ctx2[2].answerButtons.easy) * 100).toFixed(1) + ""))
        set_data(t25, t25_value);
    },
    d(detaching) {
      if (detaching)
        detach(div16);
    }
  };
}
function create_else_block_3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No upcoming reviews scheduled.</p> 
                    <p class="help-text svelte-lbb1rg">Add flashcards to your decks to see future review
                        forecasts.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  let t0;
  let p;
  let each_value_1 = (
    /*statistics*/
    ctx[2].forecast.filter(func_1).slice(0, 20)
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      p = element("p");
      p.textContent = "Showing days with scheduled reviews based on FSRS intervals.";
      attr(div, "class", "forecast-chart svelte-lbb1rg");
      attr(p, "class", "forecast-note svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      insert(target, t0, anchor);
      insert(target, p, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4) {
        each_value_1 = /*statistics*/
        ctx2[2].forecast.filter(func_1).slice(0, 20);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(p);
    }
  };
}
function create_else_block_2(ctx) {
  let t0;
  let t1_value = (
    /*originalIndex*/
    ctx[32] + ""
  );
  let t1;
  let t2;
  return {
    c() {
      t0 = text("in ");
      t1 = text(t1_value);
      t2 = text("d");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4 && t1_value !== (t1_value = /*originalIndex*/
      ctx2[32] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
    }
  };
}
function create_if_block_5(ctx) {
  let t;
  return {
    c() {
      t = text("Tomorrow");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4(ctx) {
  let t;
  return {
    c() {
      t = text("Today");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_12(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2_value = (
    /*day*/
    ctx[31].dueCount + ""
  );
  let t2;
  let t3;
  let div3_title_value;
  function select_block_type_7(ctx2, dirty) {
    if (
      /*originalIndex*/
      ctx2[32] === 0
    )
      return create_if_block_4;
    if (
      /*originalIndex*/
      ctx2[32] === 1
    )
      return create_if_block_5;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_7(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if_block.c();
      t1 = space();
      div2 = element("div");
      t2 = text(t2_value);
      t3 = space();
      attr(div0, "class", "bar svelte-lbb1rg");
      set_style(div0, "height", Math.max(
        /*day*/
        ctx[31].dueCount * 2,
        2
      ) + "px");
      attr(div1, "class", "bar-label svelte-lbb1rg");
      attr(div2, "class", "bar-value svelte-lbb1rg");
      attr(div3, "class", "forecast-bar svelte-lbb1rg");
      attr(div3, "title", div3_title_value = /*originalIndex*/
      (ctx[32] === 0 ? "Today" : (
        /*originalIndex*/
        ctx[32] === 1 ? "Tomorrow" : `In ${/*originalIndex*/
        ctx[32]} days`
      )) + ": " + /*day*/
      ctx[31].dueCount + " card" + /*day*/
      (ctx[31].dueCount !== 1 ? "s" : ""));
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      if_block.m(div1, null);
      append(div3, t1);
      append(div3, div2);
      append(div2, t2);
      append(div3, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4) {
        set_style(div0, "height", Math.max(
          /*day*/
          ctx2[31].dueCount * 2,
          2
        ) + "px");
      }
      if (current_block_type === (current_block_type = select_block_type_7(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
      if (dirty[0] & /*statistics*/
      4 && t2_value !== (t2_value = /*day*/
      ctx2[31].dueCount + ""))
        set_data(t2, t2_value);
      if (dirty[0] & /*statistics*/
      4 && div3_title_value !== (div3_title_value = /*originalIndex*/
      (ctx2[32] === 0 ? "Today" : (
        /*originalIndex*/
        ctx2[32] === 1 ? "Tomorrow" : `In ${/*originalIndex*/
        ctx2[32]} days`
      )) + ": " + /*day*/
      ctx2[31].dueCount + " card" + /*day*/
      (ctx2[31].dueCount !== 1 ? "s" : ""))) {
        attr(div3, "title", div3_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p class="svelte-lbb1rg">No interval data available.</p> 
                    <p class="help-text svelte-lbb1rg">Review some cards to see interval distribution.</p>`;
      attr(div, "class", "no-data-message svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_22(ctx) {
  let div;
  let each_value = (
    /*statistics*/
    ctx[2].intervals
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "intervals-chart svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4) {
        each_value = /*statistics*/
        ctx2[2].intervals;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div2;
  let div0;
  let t0_value = (
    /*interval*/
    ctx[28].interval + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*interval*/
    ctx[28].count + ""
  );
  let t2;
  let t3;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      attr(div0, "class", "interval-label svelte-lbb1rg");
      attr(div1, "class", "interval-value svelte-lbb1rg");
      attr(div2, "class", "interval-bar svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div2, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*statistics*/
      4 && t0_value !== (t0_value = /*interval*/
      ctx2[28].interval + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*statistics*/
      4 && t2_value !== (t2_value = /*interval*/
      ctx2[28].count + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_13, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[1]
    )
      return 0;
    if (!/*statistics*/
    ctx2[2])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "statistics-container svelte-lbb1rg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function formatTime(seconds) {
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  return `${minutes}m`;
}
var func2 = (day) => day.dueCount > 0;
var func_1 = (day) => day.dueCount > 0;
function instance4($$self, $$props, $$invalidate) {
  let todayStats;
  let weekStats;
  let monthStats;
  let yearStats;
  let { plugin } = $$props;
  const dispatch = createEventDispatcher();
  let loading = true;
  let statistics = null;
  let selectedDeckFilter = "all";
  let selectedTimeframe = "12months";
  let availableDecks = [];
  let availableTags = [];
  let heatmapComponent;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield loadDecksAndTags();
    yield loadStatistics();
  }));
  function loadDecksAndTags() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        $$invalidate(5, availableDecks = yield plugin.getDecks());
        $$invalidate(6, availableTags = [...new Set(availableDecks.map((deck) => deck.tag))]);
      } catch (error) {
        console.error("Error loading decks and tags:", error);
      }
    });
  }
  function loadStatistics() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        $$invalidate(1, loading = true);
        $$invalidate(2, statistics = yield plugin.getOverallStatistics(selectedDeckFilter, selectedTimeframe));
        console.log("Loaded statistics:", statistics);
      } catch (error) {
        console.error("Error loading statistics:", error);
        $$invalidate(2, statistics = {
          dailyStats: [],
          cardStats: { new: 0, learning: 0, mature: 0 },
          answerButtons: { again: 0, hard: 0, good: 0, easy: 0 },
          retentionRate: 0,
          intervals: [],
          forecast: []
        });
      } finally {
        $$invalidate(1, loading = false);
      }
    });
  }
  function handleFilterChange() {
    return __awaiter(this, void 0, void 0, function* () {
      yield loadStatistics();
    });
  }
  function getTodayStats() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.dailyStats) || statistics.dailyStats.length === 0)
      return null;
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return statistics.dailyStats.find((day) => day.date === today) || statistics.dailyStats[0] || null;
  }
  function getTimeframeStats(days) {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.dailyStats)) {
      return {
        reviews: 0,
        timeSpent: 0,
        newCards: 0,
        learningCards: 0,
        reviewCards: 0,
        correctRate: 0
      };
    }
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    const cutoffStr = cutoffDate.toISOString().split("T")[0];
    const filteredStats = statistics.dailyStats.filter((day) => day.date >= cutoffStr);
    if (filteredStats.length === 0) {
      return {
        reviews: 0,
        timeSpent: 0,
        newCards: 0,
        learningCards: 0,
        reviewCards: 0,
        correctRate: 0
      };
    }
    return filteredStats.reduce(
      (acc, day) => ({
        reviews: acc.reviews + day.reviews,
        timeSpent: acc.timeSpent + day.timeSpent,
        newCards: acc.newCards + day.newCards,
        learningCards: acc.learningCards + day.learningCards,
        reviewCards: acc.reviewCards + day.reviewCards,
        correctRate: acc.reviews + day.reviews > 0 ? (acc.correctRate * acc.reviews + day.correctRate * day.reviews) / (acc.reviews + day.reviews) : 0
      }),
      {
        reviews: 0,
        timeSpent: 0,
        newCards: 0,
        learningCards: 0,
        reviewCards: 0,
        correctRate: 0
      }
    );
  }
  function calculateAverageEase() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.answerButtons))
      return 0;
    const { again, hard, good, easy } = statistics.answerButtons;
    const total = again + hard + good + easy;
    if (total === 0)
      return 0;
    const weightedSum = again * 1 + hard * 2 + good * 3 + easy * 4;
    return (weightedSum / total).toFixed(2);
  }
  function calculateAverageInterval() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.intervals))
      return 0;
    let totalInterval = 0;
    let totalCards = 0;
    statistics.intervals.forEach((interval) => {
      const intervalStr = interval.interval;
      let minutes = 0;
      if (intervalStr.endsWith("h")) {
        minutes = parseInt(intervalStr) * 60;
      } else if (intervalStr.endsWith("d")) {
        minutes = parseInt(intervalStr) * 1440;
      } else if (intervalStr.endsWith("m")) {
        minutes = parseInt(intervalStr) * 43200;
      }
      totalInterval += minutes * interval.count;
      totalCards += interval.count;
    });
    if (totalCards === 0)
      return 0;
    const avgMinutes = totalInterval / totalCards;
    return Math.round(avgMinutes / 1440);
  }
  function getDueToday() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.forecast))
      return 0;
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const todayForecast = statistics.forecast.find((day) => day.date === today);
    return todayForecast ? todayForecast.dueCount : 0;
  }
  function getDueTomorrow() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.forecast))
      return 0;
    const tomorrow = /* @__PURE__ */ new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowStr = tomorrow.toISOString().split("T")[0];
    const tomorrowForecast = statistics.forecast.find((day) => day.date === tomorrowStr);
    return tomorrowForecast ? tomorrowForecast.dueCount : 0;
  }
  function getMaturityRatio() {
    if (!(statistics === null || statistics === void 0 ? void 0 : statistics.cardStats))
      return 0;
    const { new: newCards, learning, mature } = statistics.cardStats;
    const total = newCards + learning + mature;
    if (total === 0)
      return 0;
    return (mature / total * 100).toFixed(1);
  }
  function select0_change_handler() {
    selectedDeckFilter = select_value(this);
    $$invalidate(3, selectedDeckFilter);
    $$invalidate(5, availableDecks);
    $$invalidate(6, availableTags);
  }
  function select1_change_handler() {
    selectedTimeframe = select_value(this);
    $$invalidate(4, selectedTimeframe);
  }
  const func_2 = async (days) => {
    return await plugin.getReviewCounts(days);
  };
  function reviewheatmap_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      heatmapComponent = $$value;
      $$invalidate(7, heatmapComponent);
    });
  }
  const click_handler = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $:
    $$invalidate(11, todayStats = getTodayStats());
  $:
    $$invalidate(10, weekStats = getTimeframeStats(7));
  $:
    $$invalidate(9, monthStats = getTimeframeStats(30));
  $:
    $$invalidate(8, yearStats = getTimeframeStats(365));
  return [
    plugin,
    loading,
    statistics,
    selectedDeckFilter,
    selectedTimeframe,
    availableDecks,
    availableTags,
    heatmapComponent,
    yearStats,
    monthStats,
    weekStats,
    todayStats,
    dispatch,
    loadStatistics,
    handleFilterChange,
    calculateAverageEase,
    calculateAverageInterval,
    getDueToday,
    getDueTomorrow,
    getMaturityRatio,
    select0_change_handler,
    select1_change_handler,
    func_2,
    reviewheatmap_binding,
    click_handler
  ];
}
var StatisticsUI = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { plugin: 0 }, add_css4, [-1, -1]);
  }
};
var StatisticsUI_default = StatisticsUI;

// src/components/StatisticsModal.ts
var StatisticsModal = class extends import_obsidian4.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.component = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const modalEl = this.containerEl.querySelector(".modal");
    if (modalEl) {
      modalEl.style.width = "600px";
      modalEl.style.maxWidth = "90vw";
      modalEl.style.height = "80vh";
      modalEl.style.maxHeight = "80vh";
      modalEl.style.margin = "auto";
      modalEl.style.position = "fixed";
      modalEl.style.top = "50%";
      modalEl.style.left = "50%";
      modalEl.style.transform = "translate(-50%, -50%)";
    }
    this.containerEl.style.display = "flex";
    this.containerEl.style.alignItems = "center";
    this.containerEl.style.justifyContent = "center";
    this.containerEl.style.position = "fixed";
    this.containerEl.style.top = "0";
    this.containerEl.style.left = "0";
    this.containerEl.style.width = "100vw";
    this.containerEl.style.height = "100vh";
    this.containerEl.style.zIndex = "1000";
    contentEl.style.overflow = "hidden";
    contentEl.style.height = "100%";
    const titleEl = contentEl.createEl("h2", { text: "Overall Statistics" });
    titleEl.style.margin = "0 0 16px 0";
    titleEl.style.padding = "0 20px";
    const componentContainer = contentEl.createDiv("statistics-container");
    componentContainer.style.padding = "0";
    componentContainer.style.margin = "0";
    componentContainer.style.height = "calc(80vh - 60px)";
    componentContainer.style.width = "100%";
    componentContainer.style.overflowY = "auto";
    componentContainer.style.overflowX = "hidden";
    this.component = new StatisticsUI_default({
      target: componentContainer,
      props: {
        plugin: this.plugin
      }
    });
    this.component.$on("close", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    if (this.component) {
      this.component.$destroy();
      this.component = null;
    }
    contentEl.empty();
  }
};

// src/components/FlashcardReviewModalWrapper.ts
var import_obsidian5 = require("obsidian");

// src/components/FlashcardReviewModal.svelte
function add_css5(target) {
  append_styles(target, "svelte-1opyfa1", ".review-modal.svelte-1opyfa1.svelte-1opyfa1{display:flex;flex-direction:column;height:100%;background:var(--background-primary);color:var(--text-normal);overflow:hidden;width:100%}.modal-header.svelte-1opyfa1.svelte-1opyfa1{display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid var(--background-modifier-border)}.modal-header.svelte-1opyfa1 h3.svelte-1opyfa1{margin:0;font-size:18px;font-weight:600}.progress-info.svelte-1opyfa1.svelte-1opyfa1{display:flex;gap:8px;font-size:14px}.remaining.svelte-1opyfa1.svelte-1opyfa1{color:var(--text-muted)}.review-progress-bar.svelte-1opyfa1.svelte-1opyfa1{height:4px;background:var(--background-modifier-border);position:relative}.progress-fill.svelte-1opyfa1.svelte-1opyfa1{height:100%;background:var(--interactive-accent);transition:width 0.3s ease}.card-content.svelte-1opyfa1.svelte-1opyfa1{flex:1;overflow-y:auto;overflow-x:hidden;padding:32px 16px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:24px;width:100%;box-sizing:border-box;min-height:0}.question-section.svelte-1opyfa1.svelte-1opyfa1,.answer-section.svelte-1opyfa1.svelte-1opyfa1{width:100%;display:flex;justify-content:center}.card-side.svelte-1opyfa1.svelte-1opyfa1{background:var(--background-secondary);border:1px solid var(--background-modifier-border);border-radius:8px;padding:24px;min-height:100px;width:100%;max-width:600px;box-sizing:border-box;word-wrap:break-word;overflow-wrap:break-word}.card-side.front.svelte-1opyfa1.svelte-1opyfa1{text-align:center;font-size:20px;font-weight:500}.card-side.back.svelte-1opyfa1.svelte-1opyfa1{font-size:16px;line-height:1.6}.answer-section.svelte-1opyfa1.svelte-1opyfa1{width:100%;display:flex;flex-direction:column;justify-content:center;align-items:center}.answer-section.hidden.svelte-1opyfa1.svelte-1opyfa1{display:none}.separator.svelte-1opyfa1.svelte-1opyfa1{height:1px;background:var(--background-modifier-border);margin:16px auto;width:100%;max-width:600px}.action-buttons.svelte-1opyfa1.svelte-1opyfa1{padding:20px;border-top:1px solid var(--background-modifier-border);flex-shrink:0;width:100%;box-sizing:border-box}.show-answer-button.svelte-1opyfa1.svelte-1opyfa1{width:100%;max-width:400px;margin:0 auto;padding:12px 24px;font-size:16px;font-weight:500;background:var(--interactive-accent);color:var(--text-on-accent);border:none;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;box-sizing:border-box}.show-answer-button.svelte-1opyfa1.svelte-1opyfa1:hover{background:var(--interactive-accent-hover)}.shortcut.svelte-1opyfa1.svelte-1opyfa1{font-size:12px;opacity:0.8;padding:2px 6px;background:rgba(0, 0, 0, 0.2);border-radius:3px;margin-left:8px;display:inline-block}.difficulty-buttons.svelte-1opyfa1.svelte-1opyfa1{display:flex;gap:8px;justify-content:center;flex-wrap:nowrap;padding:0 10px;box-sizing:border-box;width:100%;max-width:600px;margin:0 auto}.difficulty-button.svelte-1opyfa1.svelte-1opyfa1{flex:1;min-width:0;padding:10px 6px;border:1px solid var(--background-modifier-border);background:var(--background-secondary);border-radius:6px;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:2px;transition:all 0.2s ease;position:relative;box-sizing:border-box;white-space:nowrap}.difficulty-button.svelte-1opyfa1.svelte-1opyfa1:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0, 0, 0, 0.1)}.difficulty-button.svelte-1opyfa1.svelte-1opyfa1:disabled{opacity:0.5;cursor:not-allowed;transform:none}.difficulty-button.again.svelte-1opyfa1.svelte-1opyfa1{border-color:#e74c3c}.difficulty-button.again.svelte-1opyfa1.svelte-1opyfa1:hover:not(:disabled){background:#e74c3c;color:white}.difficulty-button.hard.svelte-1opyfa1.svelte-1opyfa1{border-color:#f39c12}.difficulty-button.hard.svelte-1opyfa1.svelte-1opyfa1:hover:not(:disabled){background:#f39c12;color:white}.difficulty-button.good.svelte-1opyfa1.svelte-1opyfa1{border-color:#27ae60}.difficulty-button.good.svelte-1opyfa1.svelte-1opyfa1:hover:not(:disabled){background:#27ae60;color:white}.difficulty-button.easy.svelte-1opyfa1.svelte-1opyfa1{border-color:#3498db}.difficulty-button.easy.svelte-1opyfa1.svelte-1opyfa1:hover:not(:disabled){background:#3498db;color:white}.button-label.svelte-1opyfa1.svelte-1opyfa1{font-weight:600;font-size:13px}.interval.svelte-1opyfa1.svelte-1opyfa1{font-size:11px;color:var(--text-muted)}.difficulty-button.svelte-1opyfa1:hover .interval.svelte-1opyfa1{color:inherit}.difficulty-button.svelte-1opyfa1 .shortcut.svelte-1opyfa1{position:absolute;top:2px;right:2px;font-size:9px;padding:1px 3px;background:var(--background-modifier-border);border-radius:2px;opacity:0.7}.empty-state.svelte-1opyfa1.svelte-1opyfa1{flex:1;display:flex;align-items:center;justify-content:center;padding:32px;color:var(--text-muted)}.card-side h1,.card-side h2,.card-side h3,.card-side h4,.card-side h5,.card-side h6{margin-top:0;margin-bottom:16px}.card-side p{margin-bottom:16px}.card-side p:last-child{margin-bottom:0}.card-side > *:first-child{margin-top:0}.card-side ul,.card-side ol{margin-bottom:16px;padding-left:24px}.card-side code{background:var(--code-background);padding:2px 4px;border-radius:3px;font-size:0.9em}.card-side pre{background:var(--code-background);padding:16px;border-radius:6px;overflow-x:auto;margin-bottom:16px;max-width:100%}.card-side blockquote{border-left:3px solid var(--blockquote-border);padding-left:16px;margin-left:0;margin-right:0;color:var(--text-muted)}@media(max-width: 500px){.difficulty-buttons.svelte-1opyfa1.svelte-1opyfa1{gap:4px;padding:0 5px}.difficulty-button.svelte-1opyfa1.svelte-1opyfa1{padding:8px 4px}.button-label.svelte-1opyfa1.svelte-1opyfa1{font-size:12px}.interval.svelte-1opyfa1.svelte-1opyfa1{font-size:10px}.difficulty-button.svelte-1opyfa1 .shortcut.svelte-1opyfa1{font-size:8px;padding:1px 2px}.card-content.svelte-1opyfa1.svelte-1opyfa1{padding:16px 8px}}");
}
function create_if_block_33(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "progress-fill svelte-1opyfa1");
      set_style(
        div0,
        "width",
        /*progress*/
        ctx[11] + "%"
      );
      attr(div1, "class", "review-progress-bar svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, dirty) {
      if (dirty & /*progress*/
      2048) {
        set_style(
          div0,
          "width",
          /*progress*/
          ctx2[11] + "%"
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_else_block4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p>No cards to review</p>`;
      attr(div, "class", "empty-state svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block4(ctx) {
  let div5;
  let div1;
  let div0;
  let t0;
  let div4;
  let div2;
  let t1;
  let div3;
  let t2;
  let div6;
  let t3;
  let if_block0 = !/*showAnswer*/
  ctx[5] && create_if_block_23(ctx);
  let if_block1 = (
    /*showAnswer*/
    ctx[5] && /*schedulingInfo*/
    ctx[9] && create_if_block_14(ctx)
  );
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div4 = element("div");
      div2 = element("div");
      t1 = space();
      div3 = element("div");
      t2 = space();
      div6 = element("div");
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "card-side front svelte-1opyfa1");
      attr(div1, "class", "question-section svelte-1opyfa1");
      attr(div2, "class", "separator svelte-1opyfa1");
      attr(div3, "class", "card-side back svelte-1opyfa1");
      attr(div4, "class", "answer-section svelte-1opyfa1");
      toggle_class(div4, "hidden", !/*showAnswer*/
      ctx[5]);
      attr(div5, "class", "card-content svelte-1opyfa1");
      attr(div6, "class", "action-buttons svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      ctx[19](div0);
      append(div5, t0);
      append(div5, div4);
      append(div4, div2);
      append(div4, t1);
      append(div4, div3);
      ctx[20](div3);
      insert(target, t2, anchor);
      insert(target, div6, anchor);
      if (if_block0)
        if_block0.m(div6, null);
      append(div6, t3);
      if (if_block1)
        if_block1.m(div6, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*showAnswer*/
      32) {
        toggle_class(div4, "hidden", !/*showAnswer*/
        ctx2[5]);
      }
      if (!/*showAnswer*/
      ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          if_block0.m(div6, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showAnswer*/
        ctx2[5] && /*schedulingInfo*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      ctx[19](null);
      ctx[20](null);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div6);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_23(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<span>Show Answer</span> 
                    <span class="shortcut svelte-1opyfa1">Space</span>`;
      attr(button, "class", "show-answer-button svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*revealAnswer*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  let div12;
  let button0;
  let div0;
  let t1;
  let div1;
  let t2_value = (
    /*getIntervalDisplay*/
    ctx[14](
      /*schedulingInfo*/
      ctx[9].again.interval
    ) + ""
  );
  let t2;
  let t3;
  let div2;
  let t5;
  let button1;
  let div3;
  let t7;
  let div4;
  let t8_value = (
    /*getIntervalDisplay*/
    ctx[14](
      /*schedulingInfo*/
      ctx[9].hard.interval
    ) + ""
  );
  let t8;
  let t9;
  let div5;
  let t11;
  let button2;
  let div6;
  let t13;
  let div7;
  let t14_value = (
    /*getIntervalDisplay*/
    ctx[14](
      /*schedulingInfo*/
      ctx[9].good.interval
    ) + ""
  );
  let t14;
  let t15;
  let div8;
  let t17;
  let button3;
  let div9;
  let t19;
  let div10;
  let t20_value = (
    /*getIntervalDisplay*/
    ctx[14](
      /*schedulingInfo*/
      ctx[9].easy.interval
    ) + ""
  );
  let t20;
  let t21;
  let div11;
  let mounted;
  let dispose;
  return {
    c() {
      div12 = element("div");
      button0 = element("button");
      div0 = element("div");
      div0.textContent = "Again";
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      div2.textContent = "1";
      t5 = space();
      button1 = element("button");
      div3 = element("div");
      div3.textContent = "Hard";
      t7 = space();
      div4 = element("div");
      t8 = text(t8_value);
      t9 = space();
      div5 = element("div");
      div5.textContent = "2";
      t11 = space();
      button2 = element("button");
      div6 = element("div");
      div6.textContent = "Good";
      t13 = space();
      div7 = element("div");
      t14 = text(t14_value);
      t15 = space();
      div8 = element("div");
      div8.textContent = "3";
      t17 = space();
      button3 = element("button");
      div9 = element("div");
      div9.textContent = "Easy";
      t19 = space();
      div10 = element("div");
      t20 = text(t20_value);
      t21 = space();
      div11 = element("div");
      div11.textContent = "4";
      attr(div0, "class", "button-label svelte-1opyfa1");
      attr(div1, "class", "interval svelte-1opyfa1");
      attr(div2, "class", "shortcut svelte-1opyfa1");
      attr(button0, "class", "difficulty-button again svelte-1opyfa1");
      button0.disabled = /*isLoading*/
      ctx[6];
      attr(div3, "class", "button-label svelte-1opyfa1");
      attr(div4, "class", "interval svelte-1opyfa1");
      attr(div5, "class", "shortcut svelte-1opyfa1");
      attr(button1, "class", "difficulty-button hard svelte-1opyfa1");
      button1.disabled = /*isLoading*/
      ctx[6];
      attr(div6, "class", "button-label svelte-1opyfa1");
      attr(div7, "class", "interval svelte-1opyfa1");
      attr(div8, "class", "shortcut svelte-1opyfa1");
      attr(button2, "class", "difficulty-button good svelte-1opyfa1");
      button2.disabled = /*isLoading*/
      ctx[6];
      attr(div9, "class", "button-label svelte-1opyfa1");
      attr(div10, "class", "interval svelte-1opyfa1");
      attr(div11, "class", "shortcut svelte-1opyfa1");
      attr(button3, "class", "difficulty-button easy svelte-1opyfa1");
      button3.disabled = /*isLoading*/
      ctx[6];
      attr(div12, "class", "difficulty-buttons svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, button0);
      append(button0, div0);
      append(button0, t1);
      append(button0, div1);
      append(div1, t2);
      append(button0, t3);
      append(button0, div2);
      append(div12, t5);
      append(div12, button1);
      append(button1, div3);
      append(button1, t7);
      append(button1, div4);
      append(div4, t8);
      append(button1, t9);
      append(button1, div5);
      append(div12, t11);
      append(div12, button2);
      append(button2, div6);
      append(button2, t13);
      append(button2, div7);
      append(div7, t14);
      append(button2, t15);
      append(button2, div8);
      append(div12, t17);
      append(div12, button3);
      append(button3, div9);
      append(button3, t19);
      append(button3, div10);
      append(div10, t20);
      append(button3, t21);
      append(button3, div11);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[21]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[22]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[23]
          ),
          listen(
            button3,
            "click",
            /*click_handler_3*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*schedulingInfo*/
      512 && t2_value !== (t2_value = /*getIntervalDisplay*/
      ctx2[14](
        /*schedulingInfo*/
        ctx2[9].again.interval
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*isLoading*/
      64) {
        button0.disabled = /*isLoading*/
        ctx2[6];
      }
      if (dirty & /*schedulingInfo*/
      512 && t8_value !== (t8_value = /*getIntervalDisplay*/
      ctx2[14](
        /*schedulingInfo*/
        ctx2[9].hard.interval
      ) + ""))
        set_data(t8, t8_value);
      if (dirty & /*isLoading*/
      64) {
        button1.disabled = /*isLoading*/
        ctx2[6];
      }
      if (dirty & /*schedulingInfo*/
      512 && t14_value !== (t14_value = /*getIntervalDisplay*/
      ctx2[14](
        /*schedulingInfo*/
        ctx2[9].good.interval
      ) + ""))
        set_data(t14, t14_value);
      if (dirty & /*isLoading*/
      64) {
        button2.disabled = /*isLoading*/
        ctx2[6];
      }
      if (dirty & /*schedulingInfo*/
      512 && t20_value !== (t20_value = /*getIntervalDisplay*/
      ctx2[14](
        /*schedulingInfo*/
        ctx2[9].easy.interval
      ) + ""))
        set_data(t20, t20_value);
      if (dirty & /*isLoading*/
      64) {
        button3.disabled = /*isLoading*/
        ctx2[6];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment5(ctx) {
  var _a, _b;
  let div2;
  let div1;
  let h3;
  let t0;
  let t1_value = (
    /*deck*/
    ctx[2].name + ""
  );
  let t1;
  let t2;
  let div0;
  let span0;
  let t3_value = (
    /*currentIndex*/
    ctx[0] + 1 + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*flashcards*/
    ctx[1].length + ""
  );
  let t5;
  let t6;
  let span1;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let if_block0 = (
    /*settings*/
    ((_b = (_a = ctx[3]) == null ? void 0 : _a.review) == null ? void 0 : _b.showProgress) !== false && create_if_block_33(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*currentCard*/
      ctx2[4]
    )
      return create_if_block4;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      h3 = element("h3");
      t0 = text("Review Session - ");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      span0 = element("span");
      t3 = text(t3_value);
      t4 = text(" / ");
      t5 = text(t5_value);
      t6 = space();
      span1 = element("span");
      t7 = text("(");
      t8 = text(
        /*remainingCards*/
        ctx[10]
      );
      t9 = text(" remaining)");
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if_block1.c();
      attr(h3, "class", "svelte-1opyfa1");
      attr(span1, "class", "remaining svelte-1opyfa1");
      attr(div0, "class", "progress-info svelte-1opyfa1");
      attr(div1, "class", "modal-header svelte-1opyfa1");
      attr(div2, "class", "review-modal svelte-1opyfa1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, h3);
      append(h3, t0);
      append(h3, t1);
      append(div1, t2);
      append(div1, div0);
      append(div0, span0);
      append(span0, t3);
      append(span0, t4);
      append(span0, t5);
      append(div0, t6);
      append(div0, span1);
      append(span1, t7);
      append(span1, t8);
      append(span1, t9);
      append(div2, t10);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t11);
      if_block1.m(div2, null);
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if (dirty & /*deck*/
      4 && t1_value !== (t1_value = /*deck*/
      ctx2[2].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*currentIndex*/
      1 && t3_value !== (t3_value = /*currentIndex*/
      ctx2[0] + 1 + ""))
        set_data(t3, t3_value);
      if (dirty & /*flashcards*/
      2 && t5_value !== (t5_value = /*flashcards*/
      ctx2[1].length + ""))
        set_data(t5, t5_value);
      if (dirty & /*remainingCards*/
      1024)
        set_data(
          t8,
          /*remainingCards*/
          ctx2[10]
        );
      if (
        /*settings*/
        ((_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.review) == null ? void 0 : _b2.showProgress) !== false
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(div2, t11);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let currentCard;
  let progress;
  let remainingCards;
  let { flashcards = [] } = $$props;
  let { deck } = $$props;
  let { currentIndex = 0 } = $$props;
  let { onClose } = $$props;
  let { onReview } = $$props;
  let { renderMarkdown } = $$props;
  let { settings } = $$props;
  let { onCardReviewed = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const fsrs = new FSRS();
  let showAnswer = false;
  let isLoading = false;
  let frontEl;
  let backEl;
  let schedulingInfo = null;
  let reviewedCount = 0;
  function loadCard() {
    if (!currentCard)
      return;
    $$invalidate(5, showAnswer = false);
    $$invalidate(9, schedulingInfo = fsrs.getSchedulingInfo(currentCard));
    if (frontEl) {
      $$invalidate(7, frontEl.innerHTML = "", frontEl);
      renderMarkdown(currentCard.front, frontEl);
    }
    tick().then(() => {
      if (backEl) {
        $$invalidate(8, backEl.innerHTML = "", backEl);
        renderMarkdown(currentCard.back, backEl);
      }
    });
  }
  function revealAnswer() {
    $$invalidate(5, showAnswer = true);
    tick().then(() => {
      if (backEl && currentCard) {
        $$invalidate(8, backEl.innerHTML = "", backEl);
        renderMarkdown(currentCard.back, backEl);
      }
    });
  }
  function handleDifficulty(difficulty) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!currentCard || isLoading)
        return;
      $$invalidate(6, isLoading = true);
      try {
        yield onReview(currentCard, difficulty);
        reviewedCount++;
        if (onCardReviewed) {
          yield onCardReviewed(currentCard);
        }
        if (currentIndex < flashcards.length - 1) {
          $$invalidate(0, currentIndex++, currentIndex);
          loadCard();
        } else {
          dispatch("complete", {
            reason: "no-more-cards",
            reviewed: reviewedCount
          });
          onClose();
        }
      } catch (error) {
        console.error("Error reviewing card:", error);
      } finally {
        $$invalidate(6, isLoading = false);
      }
    });
  }
  function getIntervalDisplay(minutes) {
    return FSRS.getIntervalDisplay(minutes);
  }
  function handleKeydown(event) {
    if (isLoading)
      return;
    if (!showAnswer && event.key === " ") {
      event.preventDefault();
      revealAnswer();
    } else if (showAnswer) {
      switch (event.key) {
        case "1":
          handleDifficulty("again");
          break;
        case "2":
          handleDifficulty("hard");
          break;
        case "3":
        case " ":
          handleDifficulty("good");
          break;
        case "4":
          handleDifficulty("easy");
          break;
      }
    }
  }
  onMount(() => {
    loadCard();
    window.addEventListener("keydown", handleKeydown);
    return () => {
      window.removeEventListener("keydown", handleKeydown);
    };
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      frontEl = $$value;
      $$invalidate(7, frontEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backEl = $$value;
      $$invalidate(8, backEl);
    });
  }
  const click_handler = () => handleDifficulty("again");
  const click_handler_1 = () => handleDifficulty("hard");
  const click_handler_2 = () => handleDifficulty("good");
  const click_handler_3 = () => handleDifficulty("easy");
  $$self.$$set = ($$props2) => {
    if ("flashcards" in $$props2)
      $$invalidate(1, flashcards = $$props2.flashcards);
    if ("deck" in $$props2)
      $$invalidate(2, deck = $$props2.deck);
    if ("currentIndex" in $$props2)
      $$invalidate(0, currentIndex = $$props2.currentIndex);
    if ("onClose" in $$props2)
      $$invalidate(15, onClose = $$props2.onClose);
    if ("onReview" in $$props2)
      $$invalidate(16, onReview = $$props2.onReview);
    if ("renderMarkdown" in $$props2)
      $$invalidate(17, renderMarkdown = $$props2.renderMarkdown);
    if ("settings" in $$props2)
      $$invalidate(3, settings = $$props2.settings);
    if ("onCardReviewed" in $$props2)
      $$invalidate(18, onCardReviewed = $$props2.onCardReviewed);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*flashcards, currentIndex*/
    3) {
      $:
        $$invalidate(4, currentCard = flashcards[currentIndex] || null);
    }
    if ($$self.$$.dirty & /*flashcards, currentIndex*/
    3) {
      $:
        $$invalidate(11, progress = flashcards.length > 0 ? currentIndex / flashcards.length * 100 : 0);
    }
    if ($$self.$$.dirty & /*flashcards, currentIndex*/
    3) {
      $:
        $$invalidate(10, remainingCards = flashcards.length - currentIndex);
    }
    if ($$self.$$.dirty & /*currentCard*/
    16) {
      $:
        if (currentCard) {
          loadCard();
        }
    }
  };
  return [
    currentIndex,
    flashcards,
    deck,
    settings,
    currentCard,
    showAnswer,
    isLoading,
    frontEl,
    backEl,
    schedulingInfo,
    remainingCards,
    progress,
    revealAnswer,
    handleDifficulty,
    getIntervalDisplay,
    onClose,
    onReview,
    renderMarkdown,
    onCardReviewed,
    div0_binding,
    div3_binding,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
var FlashcardReviewModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        flashcards: 1,
        deck: 2,
        currentIndex: 0,
        onClose: 15,
        onReview: 16,
        renderMarkdown: 17,
        settings: 3,
        onCardReviewed: 18
      },
      add_css5
    );
  }
};
var FlashcardReviewModal_default = FlashcardReviewModal;

// src/components/FlashcardReviewModalWrapper.ts
var FlashcardReviewModalWrapper = class extends import_obsidian5.Modal {
  constructor(app, plugin, deck, flashcards) {
    super(app);
    this.component = null;
    this.markdownComponents = [];
    this.plugin = plugin;
    this.deck = deck;
    this.flashcards = flashcards;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flashcard-review-modal");
    const container = contentEl.createDiv();
    this.component = new FlashcardReviewModal_default({
      target: container,
      props: {
        flashcards: this.flashcards,
        deck: this.deck,
        currentIndex: 0,
        onClose: () => this.close(),
        onReview: async (card, difficulty) => {
          await this.plugin.reviewFlashcard(card, difficulty);
        },
        renderMarkdown: (content, el) => {
          const component = this.plugin.renderMarkdown(content, el);
          if (component) {
            this.markdownComponents.push(component);
          }
        },
        settings: this.plugin.settings,
        onCardReviewed: async (reviewedCard) => {
          if (this.plugin.view && reviewedCard) {
            await this.plugin.view.refreshStatsById(reviewedCard.deckId);
          }
        }
      }
    });
    this.component.$on("complete", (event) => {
      const { reason, reviewed } = event.detail;
      let message = `Review session complete for ${this.deck.name}!`;
      if (reason === "no-more-cards") {
        message = `All available cards reviewed! Completed ${reviewed} cards from ${this.deck.name}.`;
      }
      new import_obsidian5.Notice(message);
      if (this.plugin.view) {
        this.plugin.view.refresh();
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
      this.component = null;
    }
    this.markdownComponents.forEach((comp) => comp.unload());
    this.markdownComponents = [];
    if (this.plugin.view) {
      this.plugin.view.refresh();
    }
  }
};

// src/main.ts
var VIEW_TYPE_FLASHCARDS = "flashcards-view";
var DATABASE_PATH = ".obsidian/plugins/obsidian-flashcards-plugin/flashcards.db";
var FlashcardsPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
  }
  // Debug logging utility
  debugLog(message, ...args) {
    var _a, _b;
    if ((_b = (_a = this.settings) == null ? void 0 : _a.debug) == null ? void 0 : _b.enableLogging) {
      console.log(`[Flashcards Debug] ${message}`, ...args);
    }
  }
  async onload() {
    console.log("Loading Flashcards plugin");
    await this.loadSettings();
    try {
      const adapter = this.app.vault.adapter;
      const pluginDir = ".obsidian/plugins/obsidian-flashcards-plugin";
      if (!await adapter.exists(pluginDir)) {
        await adapter.mkdir(pluginDir);
      }
      const dbPath = this.settings.database.customPath || DATABASE_PATH;
      this.db = new DatabaseService(dbPath);
      await this.db.initialize();
      this.deckManager = new DeckManager(
        this.app.vault,
        this.app.metadataCache,
        this.db,
        this
      );
      this.fsrs = new FSRS({
        requestRetention: this.settings.fsrs.requestRetention,
        maximumInterval: this.settings.fsrs.maximumInterval,
        easyBonus: this.settings.fsrs.easyBonus,
        hardInterval: this.settings.fsrs.hardInterval,
        w: this.settings.fsrs.weights
      });
      this.registerView(
        VIEW_TYPE_FLASHCARDS,
        (leaf) => new FlashcardsView(leaf, this)
      );
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.performSync();
        }, 2e3);
      });
      this.addRibbonIcon("brain", "Flashcards", () => {
        this.activateView();
      });
      this.addCommand({
        id: "show-flashcards-panel",
        name: "Show Flashcards Panel",
        callback: () => {
          this.activateView();
        }
      });
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (file instanceof import_obsidian6.TFile && file.extension === "md") {
            await this.handleFileChange(file);
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", async (file) => {
          if (file instanceof import_obsidian6.TFile && file.extension === "md") {
            await this.handleFileDelete(file);
          }
        })
      );
      this.loadStyles();
      this.addSettingTab(new FlashcardsSettingTab(this.app, this));
      console.log("Flashcards plugin loaded successfully");
    } catch (error) {
      console.error("Error loading Flashcards plugin:", error);
      new import_obsidian6.Notice(
        "Failed to load Flashcards plugin. Check console for details."
      );
    }
  }
  async onunload() {
    console.log("Unloading Flashcards plugin");
    if (this.db) {
      await this.db.close();
    }
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_FLASHCARDS);
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (!this.settings.debug) {
      this.settings.debug = DEFAULT_SETTINGS.debug;
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.fsrs = new FSRS({
      requestRetention: this.settings.fsrs.requestRetention,
      maximumInterval: this.settings.fsrs.maximumInterval,
      easyBonus: this.settings.fsrs.easyBonus,
      hardInterval: this.settings.fsrs.hardInterval,
      w: this.settings.fsrs.weights
    });
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "flashcards-plugin-styles";
    styleEl.textContent = `
      /* Custom styles for flashcards plugin */
      .flashcards-view {
        padding: 0;
        overflow: hidden;
      }

      /* Modal styles */
      .flashcard-review-modal {
        height: 90vh;
        max-height: 700px;
      }

      .flashcard-review-modal .modal-content {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 0;
        overflow: hidden;
        width: 100%;
        box-sizing: border-box;
      }

      .flashcard-review-modal .modal {
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .flashcard-review-modal .modal-container {
        overflow: hidden;
        width: 100%;
        height: 100%;
      }
    `;
    document.head.appendChild(styleEl);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_FLASHCARDS);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_FLASHCARDS,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      const decks = await this.db.getAllDecks();
      if (decks.length === 0) {
        this.debugLog("No decks found, triggering fallback sync...");
        await this.performSync();
      }
    }
  }
  async handleFileChange(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    this.debugLog(`File changed: ${file.path}, metadata:`, metadata);
    if (!metadata)
      return;
    const allTags = [];
    if (metadata.tags) {
      allTags.push(...metadata.tags.map((t) => t.tag));
    }
    if (metadata.frontmatter && metadata.frontmatter.tags) {
      const frontmatterTags = Array.isArray(metadata.frontmatter.tags) ? metadata.frontmatter.tags : [metadata.frontmatter.tags];
      allTags.push(
        ...frontmatterTags.map(
          (tag) => tag.startsWith("#") ? tag : `#${tag}`
        )
      );
    }
    const hasFlashcardsTag = allTags.some(
      (tag) => tag.startsWith("#flashcards")
    );
    this.debugLog(`File ${file.path} has flashcards tag:`, hasFlashcardsTag);
    if (hasFlashcardsTag) {
      const existingDeck = await this.db.getDeckByFilepath(file.path);
      if (existingDeck) {
        const newTag = allTags.find((tag) => tag.startsWith("#flashcards")) || "#flashcards";
        if (existingDeck.tag !== newTag) {
          this.debugLog(
            `Updating deck tag from ${existingDeck.tag} to ${newTag}`
          );
          await this.db.updateDeck(existingDeck.id, { tag: newTag });
        }
        await this.deckManager.syncFlashcardsForDeck(file.path);
        if (this.view) {
          await this.view.refreshStatsById(existingDeck.id);
        }
      } else {
        const newTag = allTags.find((tag) => tag.startsWith("#flashcards")) || "#flashcards";
        await this.deckManager.createDeckForFile(file.path, newTag);
        await this.deckManager.syncFlashcardsForDeck(file.path);
        if (this.view) {
          await this.view.refreshStats();
        }
      }
    }
  }
  async performSync() {
    try {
      this.debugLog("Performing sync of decks and flashcards...");
      await this.deckManager.syncDecks();
      const decks = await this.db.getAllDecks();
      this.debugLog(
        `Found ${decks.length} decks after sync:`,
        decks.map((d) => d.name)
      );
      for (const deck of decks) {
        this.debugLog(
          `Syncing flashcards for deck: ${deck.name} (${deck.filepath})`
        );
        await this.deckManager.syncFlashcardsForDeck(deck.filepath);
        const flashcards = await this.db.getFlashcardsByDeck(deck.id);
        this.debugLog(
          `Deck ${deck.name} now has ${flashcards.length} flashcards`
        );
      }
      this.debugLog(`Sync completed for ${decks.length} decks`);
      if (this.view) {
        const updatedDecks = await this.getDecks();
        const deckStats = await this.getDeckStats();
        this.view.update(updatedDecks, deckStats);
      }
    } catch (error) {
      console.error("Error during initial sync:", error);
    }
  }
  async handleFileDelete(file) {
    await this.db.deleteDeckByFilepath(file.path);
    if (this.view) {
      await this.view.refreshStats();
    }
  }
  async syncDecks() {
    await this.deckManager.syncDecks();
  }
  async syncFlashcardsForDeck(deckName) {
    await this.deckManager.syncFlashcardsForDeckByName(deckName);
  }
  async getReviewCounts(days = 365) {
    return await this.db.getReviewCountsByDate(days);
  }
  async getDecks() {
    return await this.db.getAllDecks();
  }
  async getDeckStats() {
    const stats = await this.db.getAllDeckStats();
    const statsMap = /* @__PURE__ */ new Map();
    for (const stat of stats) {
      statsMap.set(stat.deckId, stat);
    }
    return statsMap;
  }
  async getDueFlashcards(deckId) {
    return await this.db.getDueFlashcards(deckId);
  }
  async getFlashcardsByDeck(deckId) {
    return await this.db.getFlashcardsByDeck(deckId);
  }
  async getReviewableFlashcards(deckId) {
    return await this.db.getReviewableFlashcards(deckId);
  }
  async getDailyReviewCounts(deckId) {
    return await this.db.getDailyReviewCounts(deckId);
  }
  async getDeckStatsById(deckId) {
    return await this.db.getDeckStats(deckId);
  }
  async updateDeckConfig(deckId, config) {
    await this.db.updateDeck(deckId, { config });
    if (this.view) {
      await this.view.refreshStatsById(deckId);
    }
  }
  async reviewFlashcard(flashcard, difficulty) {
    const updatedCard = this.fsrs.updateCard(flashcard, difficulty);
    await this.db.updateFlashcard(updatedCard.id, {
      state: updatedCard.state,
      dueDate: updatedCard.dueDate,
      interval: updatedCard.interval,
      repetitions: updatedCard.repetitions,
      easeFactor: updatedCard.easeFactor,
      stability: updatedCard.stability,
      lapses: updatedCard.lapses,
      lastReviewed: updatedCard.lastReviewed
    });
    await this.db.createReviewLog({
      flashcardId: flashcard.id,
      reviewedAt: (/* @__PURE__ */ new Date()).toISOString(),
      difficulty,
      oldInterval: flashcard.interval,
      newInterval: updatedCard.interval,
      oldEaseFactor: flashcard.easeFactor,
      newEaseFactor: updatedCard.easeFactor
    });
    await this.db.updateDeckLastReviewed(flashcard.deckId);
    if (this.view) {
      await this.view.refreshStatsById(flashcard.deckId);
      await this.view.refreshHeatmap();
    }
  }
  async getOverallStatistics(deckFilter = "all", timeframe = "12months") {
    return await this.db.getOverallStatistics(deckFilter, timeframe);
  }
  openStatisticsModal() {
    const modal = new StatisticsModal(this);
    modal.open();
  }
  renderMarkdown(content, el) {
    const component = new import_obsidian6.Component();
    component.load();
    import_obsidian6.MarkdownRenderer.renderMarkdown(content, el, "", component);
    return component;
  }
};
var FlashcardsView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.component = null;
    this.markdownComponents = [];
    this.statsRefreshTimeout = null;
    this.backgroundRefreshInterval = null;
    this.plugin = plugin;
    this.plugin.view = this;
  }
  getViewType() {
    return VIEW_TYPE_FLASHCARDS;
  }
  getDisplayText() {
    return "Flashcards";
  }
  getIcon() {
    return "brain";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("flashcards-view");
    this.component = new DeckListPanel_default({
      target: container,
      props: {
        onDeckClick: (deck) => this.startReview(deck),
        onRefresh: async () => {
          this.plugin.debugLog("onRefresh callback invoked");
          await this.refresh();
        },
        getReviewCounts: async (days) => {
          return await this.plugin.getReviewCounts(days);
        },
        onUpdateDeckConfig: async (deckId, config) => {
          await this.plugin.updateDeckConfig(deckId, config);
        },
        onOpenStatistics: () => {
          this.plugin.openStatisticsModal();
        },
        plugin: this.plugin
      }
    });
    await this.refresh();
    if (this.plugin.settings.ui.enableBackgroundRefresh) {
      this.startBackgroundRefresh();
    }
  }
  async onClose() {
    if (this.component) {
      this.component.$destroy();
      this.component = null;
    }
    if (this.statsRefreshTimeout) {
      clearTimeout(this.statsRefreshTimeout);
      this.statsRefreshTimeout = null;
    }
    this.stopBackgroundRefresh();
    this.markdownComponents.forEach((comp) => comp.unload());
    this.markdownComponents = [];
    if (this.plugin.view === this) {
      this.plugin.view = null;
    }
  }
  async update(updatedDecks, deckStats) {
    var _a, _b;
    (_a = this.component) == null ? void 0 : _a.updateDecks(updatedDecks);
    (_b = this.component) == null ? void 0 : _b.updateStats(deckStats);
  }
  async refresh() {
    this.plugin.debugLog("FlashcardsView.refresh() called");
    try {
      await this.plugin.performSync();
      this.plugin.debugLog("Refresh complete");
    } catch (error) {
      console.error("Error refreshing flashcards:", error);
      new import_obsidian6.Notice("Error refreshing flashcards. Check console for details.");
    }
  }
  async refreshStats() {
    this.plugin.debugLog("FlashcardsView.refreshStats() executing");
    try {
      const deckStats = await this.plugin.getDeckStats();
      this.plugin.debugLog("Updated deck stats:", deckStats);
      if (this.component) {
        this.component.updateStats(deckStats);
      }
    } catch (error) {
      console.error("Error refreshing deck stats:", error);
    }
  }
  async refreshStatsById(deckId) {
    this.plugin.debugLog(
      `FlashcardsView.refreshStatsById() executing for deck: ${deckId}`
    );
    try {
      const deckStats = await this.plugin.getDeckStatsById(deckId);
      this.plugin.debugLog("Updated all deck stats");
      if (this.component && deckStats) {
        this.component.updateStatsById(deckId, deckStats);
      }
    } catch (error) {
      console.error(`Error refreshing stats for deck ${deckId}:`, error);
    }
  }
  startBackgroundRefresh() {
    if (!this.plugin.settings.ui.enableBackgroundRefresh) {
      return;
    }
    this.stopBackgroundRefresh();
    this.plugin.debugLog(
      `Starting background refresh job (every ${this.plugin.settings.ui.backgroundRefreshInterval} seconds)`
    );
    this.backgroundRefreshInterval = setInterval(async () => {
      this.plugin.debugLog("Background refresh tick");
      this.refresh();
    }, this.plugin.settings.ui.backgroundRefreshInterval * 1e3);
  }
  stopBackgroundRefresh() {
    if (this.backgroundRefreshInterval) {
      this.plugin.debugLog("Stopping background refresh job");
      clearInterval(this.backgroundRefreshInterval);
      this.backgroundRefreshInterval = null;
    }
  }
  restartBackgroundRefresh() {
    this.stopBackgroundRefresh();
    if (this.plugin.settings.ui.enableBackgroundRefresh) {
      this.startBackgroundRefresh();
    }
  }
  async refreshHeatmap() {
    if (this.component) {
      await this.component.refreshHeatmap();
    }
  }
  // Test method to check if background job is running
  checkBackgroundJobStatus() {
    this.plugin.debugLog("Background job status:", {
      isRunning: !!this.backgroundRefreshInterval,
      intervalId: this.backgroundRefreshInterval,
      componentExists: !!this.component,
      refreshInterval: this.plugin.settings.ui.backgroundRefreshInterval
    });
    return !!this.backgroundRefreshInterval;
  }
  async startReview(deck) {
    try {
      console.log(`Syncing flashcards for deck before review: ${deck.name}`);
      await this.plugin.syncFlashcardsForDeck(deck.name);
      const dailyCounts = await this.plugin.getDailyReviewCounts(deck.id);
      const config = deck.config;
      const remainingNew = config.enableNewCardsLimit ? Math.max(0, config.newCardsLimit - dailyCounts.newCount) : "unlimited";
      const remainingReview = config.enableReviewCardsLimit ? Math.max(0, config.reviewCardsLimit - dailyCounts.reviewCount) : "unlimited";
      const flashcards = await this.plugin.getReviewableFlashcards(deck.id);
      if (flashcards.length === 0) {
        let message = `No cards due for review in ${deck.name}`;
        const newLimitReached = config.enableNewCardsLimit && remainingNew === 0;
        const reviewLimitReached = config.enableReviewCardsLimit && remainingReview === 0;
        if (newLimitReached && reviewLimitReached) {
          message += `

Daily limits reached:`;
          message += `
New cards: ${config.newCardsLimit}/${config.newCardsLimit}`;
          message += `
Review cards: ${config.reviewCardsLimit}/${config.reviewCardsLimit}`;
        } else if (newLimitReached) {
          message += `

Daily new cards limit reached: ${config.newCardsLimit}/${config.newCardsLimit}`;
        } else if (reviewLimitReached) {
          message += `

Daily review cards limit reached: ${config.reviewCardsLimit}/${config.reviewCardsLimit}`;
        }
        new import_obsidian6.Notice(message);
        return;
      }
      if (config.enableNewCardsLimit || config.enableReviewCardsLimit) {
        let limitInfo = `Daily progress for ${deck.name}:
`;
        if (config.enableNewCardsLimit) {
          if (dailyCounts.newCount >= config.newCardsLimit) {
            limitInfo += `New cards: ${dailyCounts.newCount}/${config.newCardsLimit} (LIMIT EXCEEDED)
`;
          } else {
            limitInfo += `New cards: ${dailyCounts.newCount}/${config.newCardsLimit} (${remainingNew} remaining)
`;
          }
        }
        if (config.enableReviewCardsLimit) {
          if (dailyCounts.reviewCount >= config.reviewCardsLimit) {
            limitInfo += `Review cards: ${dailyCounts.reviewCount}/${config.reviewCardsLimit} (LIMIT EXCEEDED)`;
          } else {
            limitInfo += `Review cards: ${dailyCounts.reviewCount}/${config.reviewCardsLimit} (${remainingReview} remaining)`;
          }
        }
        const newLimitExceeded = config.enableNewCardsLimit && dailyCounts.newCount >= config.newCardsLimit;
        const reviewLimitExceeded = config.enableReviewCardsLimit && dailyCounts.reviewCount >= config.reviewCardsLimit;
        if (newLimitExceeded || reviewLimitExceeded) {
          limitInfo += `

Note: Only learning cards will be shown (limits exceeded)`;
        }
        new import_obsidian6.Notice(limitInfo, 5e3);
      }
      new FlashcardReviewModalWrapper(
        this.app,
        this.plugin,
        deck,
        flashcards
      ).open();
    } catch (error) {
      console.error("Error starting review:", error);
      new import_obsidian6.Notice("Error starting review. Check console for details.");
    }
  }
};
